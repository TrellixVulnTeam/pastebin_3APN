commit 1f261ce019430be02d5d9a3822719b6317170053
Author: njalsson <fridriknj339@nemi.tskoli.is>
Date:   Fri May 5 16:10:17 2017 +0000

    added slim framework

diff --git a/composer.json b/composer.json
new file mode 100644
index 0000000..49b7ae5
--- /dev/null
+++ b/composer.json
@@ -0,0 +1,5 @@
+{
+    "require": {
+        "slim/slim": "^3.0"
+    }
+}
diff --git a/composer.lock b/composer.lock
new file mode 100644
index 0000000..7dbd547
--- /dev/null
+++ b/composer.lock
@@ -0,0 +1,308 @@
+{
+    "_readme": [
+        "This file locks the dependencies of your project to a known state",
+        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file",
+        "This file is @generated automatically"
+    ],
+    "content-hash": "3b0766dbcef4dfb1a4a2012fef8611d8",
+    "packages": [
+        {
+            "name": "container-interop/container-interop",
+            "version": "1.2.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/container-interop/container-interop.git",
+                "reference": "79cbf1341c22ec75643d841642dd5d6acd83bdb8"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/container-interop/container-interop/zipball/79cbf1341c22ec75643d841642dd5d6acd83bdb8",
+                "reference": "79cbf1341c22ec75643d841642dd5d6acd83bdb8",
+                "shasum": ""
+            },
+            "require": {
+                "psr/container": "^1.0"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Interop\\Container\\": "src/Interop/Container/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "description": "Promoting the interoperability of container objects (DIC, SL, etc.)",
+            "homepage": "https://github.com/container-interop/container-interop",
+            "time": "2017-02-14T19:40:03+00:00"
+        },
+        {
+            "name": "nikic/fast-route",
+            "version": "v1.2.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/nikic/FastRoute.git",
+                "reference": "b5f95749071c82a8e0f58586987627054400cdf6"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/nikic/FastRoute/zipball/b5f95749071c82a8e0f58586987627054400cdf6",
+                "reference": "b5f95749071c82a8e0f58586987627054400cdf6",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.4.0"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "FastRoute\\": "src/"
+                },
+                "files": [
+                    "src/functions.php"
+                ]
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "BSD-3-Clause"
+            ],
+            "authors": [
+                {
+                    "name": "Nikita Popov",
+                    "email": "nikic@php.net"
+                }
+            ],
+            "description": "Fast request router for PHP",
+            "keywords": [
+                "router",
+                "routing"
+            ],
+            "time": "2017-01-19T11:35:12+00:00"
+        },
+        {
+            "name": "pimple/pimple",
+            "version": "v3.0.2",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/silexphp/Pimple.git",
+                "reference": "a30f7d6e57565a2e1a316e1baf2a483f788b258a"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/silexphp/Pimple/zipball/a30f7d6e57565a2e1a316e1baf2a483f788b258a",
+                "reference": "a30f7d6e57565a2e1a316e1baf2a483f788b258a",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "3.0.x-dev"
+                }
+            },
+            "autoload": {
+                "psr-0": {
+                    "Pimple": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Fabien Potencier",
+                    "email": "fabien@symfony.com"
+                }
+            ],
+            "description": "Pimple, a simple Dependency Injection Container",
+            "homepage": "http://pimple.sensiolabs.org",
+            "keywords": [
+                "container",
+                "dependency injection"
+            ],
+            "time": "2015-09-11T15:10:35+00:00"
+        },
+        {
+            "name": "psr/container",
+            "version": "1.0.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/php-fig/container.git",
+                "reference": "b7ce3b176482dbbc1245ebf52b181af44c2cf55f"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/php-fig/container/zipball/b7ce3b176482dbbc1245ebf52b181af44c2cf55f",
+                "reference": "b7ce3b176482dbbc1245ebf52b181af44c2cf55f",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "1.0.x-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Psr\\Container\\": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "PHP-FIG",
+                    "homepage": "http://www.php-fig.org/"
+                }
+            ],
+            "description": "Common Container Interface (PHP FIG PSR-11)",
+            "homepage": "https://github.com/php-fig/container",
+            "keywords": [
+                "PSR-11",
+                "container",
+                "container-interface",
+                "container-interop",
+                "psr"
+            ],
+            "time": "2017-02-14T16:28:37+00:00"
+        },
+        {
+            "name": "psr/http-message",
+            "version": "1.0.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/php-fig/http-message.git",
+                "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/php-fig/http-message/zipball/f6561bf28d520154e4b0ec72be95418abe6d9363",
+                "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363",
+                "shasum": ""
+            },
+            "require": {
+                "php": ">=5.3.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "1.0.x-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Psr\\Http\\Message\\": "src/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "PHP-FIG",
+                    "homepage": "http://www.php-fig.org/"
+                }
+            ],
+            "description": "Common interface for HTTP messages",
+            "homepage": "https://github.com/php-fig/http-message",
+            "keywords": [
+                "http",
+                "http-message",
+                "psr",
+                "psr-7",
+                "request",
+                "response"
+            ],
+            "time": "2016-08-06T14:39:51+00:00"
+        },
+        {
+            "name": "slim/slim",
+            "version": "3.8.1",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/slimphp/Slim.git",
+                "reference": "5385302707530b2bccee1769613ad769859b826d"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/slimphp/Slim/zipball/5385302707530b2bccee1769613ad769859b826d",
+                "reference": "5385302707530b2bccee1769613ad769859b826d",
+                "shasum": ""
+            },
+            "require": {
+                "container-interop/container-interop": "^1.2",
+                "nikic/fast-route": "^1.0",
+                "php": ">=5.5.0",
+                "pimple/pimple": "^3.0",
+                "psr/container": "^1.0",
+                "psr/http-message": "^1.0"
+            },
+            "provide": {
+                "psr/http-message-implementation": "1.0"
+            },
+            "require-dev": {
+                "phpunit/phpunit": "^4.0",
+                "squizlabs/php_codesniffer": "^2.5"
+            },
+            "type": "library",
+            "autoload": {
+                "psr-4": {
+                    "Slim\\": "Slim"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Rob Allen",
+                    "email": "rob@akrabat.com",
+                    "homepage": "http://akrabat.com"
+                },
+                {
+                    "name": "Josh Lockhart",
+                    "email": "hello@joshlockhart.com",
+                    "homepage": "https://joshlockhart.com"
+                },
+                {
+                    "name": "Gabriel Manricks",
+                    "email": "gmanricks@me.com",
+                    "homepage": "http://gabrielmanricks.com"
+                },
+                {
+                    "name": "Andrew Smith",
+                    "email": "a.smith@silentworks.co.uk",
+                    "homepage": "http://silentworks.co.uk"
+                }
+            ],
+            "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
+            "homepage": "https://slimframework.com",
+            "keywords": [
+                "api",
+                "framework",
+                "micro",
+                "router"
+            ],
+            "time": "2017-03-19T17:55:20+00:00"
+        }
+    ],
+    "packages-dev": [],
+    "aliases": [],
+    "minimum-stability": "stable",
+    "stability-flags": [],
+    "prefer-stable": false,
+    "prefer-lowest": false,
+    "platform": [],
+    "platform-dev": []
+}
diff --git a/composer.phar b/composer.phar
new file mode 100755
index 0000000..3577931
Binary files /dev/null and b/composer.phar differ
diff --git a/vendor/autoload.php b/vendor/autoload.php
new file mode 100644
index 0000000..0bd8c6b
--- /dev/null
+++ b/vendor/autoload.php
@@ -0,0 +1,7 @@
+<?php
+
+// autoload.php @generated by Composer
+
+require_once __DIR__ . '/composer/autoload_real.php';
+
+return ComposerAutoloaderInit679949ef461b333be25922e78be20b1d::getLoader();
diff --git a/vendor/composer/ClassLoader.php b/vendor/composer/ClassLoader.php
new file mode 100644
index 0000000..2c72175
--- /dev/null
+++ b/vendor/composer/ClassLoader.php
@@ -0,0 +1,445 @@
+<?php
+
+/*
+ * This file is part of Composer.
+ *
+ * (c) Nils Adermann <naderman@naderman.de>
+ *     Jordi Boggiano <j.boggiano@seld.be>
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+namespace Composer\Autoload;
+
+/**
+ * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
+ *
+ *     $loader = new \Composer\Autoload\ClassLoader();
+ *
+ *     // register classes with namespaces
+ *     $loader->add('Symfony\Component', __DIR__.'/component');
+ *     $loader->add('Symfony',           __DIR__.'/framework');
+ *
+ *     // activate the autoloader
+ *     $loader->register();
+ *
+ *     // to enable searching the include path (eg. for PEAR packages)
+ *     $loader->setUseIncludePath(true);
+ *
+ * In this example, if you try to use a class in the Symfony\Component
+ * namespace or one of its children (Symfony\Component\Console for instance),
+ * the autoloader will first look for the class under the component/
+ * directory, and it will then fallback to the framework/ directory if not
+ * found before giving up.
+ *
+ * This class is loosely based on the Symfony UniversalClassLoader.
+ *
+ * @author Fabien Potencier <fabien@symfony.com>
+ * @author Jordi Boggiano <j.boggiano@seld.be>
+ * @see    http://www.php-fig.org/psr/psr-0/
+ * @see    http://www.php-fig.org/psr/psr-4/
+ */
+class ClassLoader
+{
+    // PSR-4
+    private $prefixLengthsPsr4 = array();
+    private $prefixDirsPsr4 = array();
+    private $fallbackDirsPsr4 = array();
+
+    // PSR-0
+    private $prefixesPsr0 = array();
+    private $fallbackDirsPsr0 = array();
+
+    private $useIncludePath = false;
+    private $classMap = array();
+    private $classMapAuthoritative = false;
+    private $missingClasses = array();
+    private $apcuPrefix;
+
+    public function getPrefixes()
+    {
+        if (!empty($this->prefixesPsr0)) {
+            return call_user_func_array('array_merge', $this->prefixesPsr0);
+        }
+
+        return array();
+    }
+
+    public function getPrefixesPsr4()
+    {
+        return $this->prefixDirsPsr4;
+    }
+
+    public function getFallbackDirs()
+    {
+        return $this->fallbackDirsPsr0;
+    }
+
+    public function getFallbackDirsPsr4()
+    {
+        return $this->fallbackDirsPsr4;
+    }
+
+    public function getClassMap()
+    {
+        return $this->classMap;
+    }
+
+    /**
+     * @param array $classMap Class to filename map
+     */
+    public function addClassMap(array $classMap)
+    {
+        if ($this->classMap) {
+            $this->classMap = array_merge($this->classMap, $classMap);
+        } else {
+            $this->classMap = $classMap;
+        }
+    }
+
+    /**
+     * Registers a set of PSR-0 directories for a given prefix, either
+     * appending or prepending to the ones previously set for this prefix.
+     *
+     * @param string       $prefix  The prefix
+     * @param array|string $paths   The PSR-0 root directories
+     * @param bool         $prepend Whether to prepend the directories
+     */
+    public function add($prefix, $paths, $prepend = false)
+    {
+        if (!$prefix) {
+            if ($prepend) {
+                $this->fallbackDirsPsr0 = array_merge(
+                    (array) $paths,
+                    $this->fallbackDirsPsr0
+                );
+            } else {
+                $this->fallbackDirsPsr0 = array_merge(
+                    $this->fallbackDirsPsr0,
+                    (array) $paths
+                );
+            }
+
+            return;
+        }
+
+        $first = $prefix[0];
+        if (!isset($this->prefixesPsr0[$first][$prefix])) {
+            $this->prefixesPsr0[$first][$prefix] = (array) $paths;
+
+            return;
+        }
+        if ($prepend) {
+            $this->prefixesPsr0[$first][$prefix] = array_merge(
+                (array) $paths,
+                $this->prefixesPsr0[$first][$prefix]
+            );
+        } else {
+            $this->prefixesPsr0[$first][$prefix] = array_merge(
+                $this->prefixesPsr0[$first][$prefix],
+                (array) $paths
+            );
+        }
+    }
+
+    /**
+     * Registers a set of PSR-4 directories for a given namespace, either
+     * appending or prepending to the ones previously set for this namespace.
+     *
+     * @param string       $prefix  The prefix/namespace, with trailing '\\'
+     * @param array|string $paths   The PSR-4 base directories
+     * @param bool         $prepend Whether to prepend the directories
+     *
+     * @throws \InvalidArgumentException
+     */
+    public function addPsr4($prefix, $paths, $prepend = false)
+    {
+        if (!$prefix) {
+            // Register directories for the root namespace.
+            if ($prepend) {
+                $this->fallbackDirsPsr4 = array_merge(
+                    (array) $paths,
+                    $this->fallbackDirsPsr4
+                );
+            } else {
+                $this->fallbackDirsPsr4 = array_merge(
+                    $this->fallbackDirsPsr4,
+                    (array) $paths
+                );
+            }
+        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
+            // Register directories for a new namespace.
+            $length = strlen($prefix);
+            if ('\\' !== $prefix[$length - 1]) {
+                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
+            }
+            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
+            $this->prefixDirsPsr4[$prefix] = (array) $paths;
+        } elseif ($prepend) {
+            // Prepend directories for an already registered namespace.
+            $this->prefixDirsPsr4[$prefix] = array_merge(
+                (array) $paths,
+                $this->prefixDirsPsr4[$prefix]
+            );
+        } else {
+            // Append directories for an already registered namespace.
+            $this->prefixDirsPsr4[$prefix] = array_merge(
+                $this->prefixDirsPsr4[$prefix],
+                (array) $paths
+            );
+        }
+    }
+
+    /**
+     * Registers a set of PSR-0 directories for a given prefix,
+     * replacing any others previously set for this prefix.
+     *
+     * @param string       $prefix The prefix
+     * @param array|string $paths  The PSR-0 base directories
+     */
+    public function set($prefix, $paths)
+    {
+        if (!$prefix) {
+            $this->fallbackDirsPsr0 = (array) $paths;
+        } else {
+            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
+        }
+    }
+
+    /**
+     * Registers a set of PSR-4 directories for a given namespace,
+     * replacing any others previously set for this namespace.
+     *
+     * @param string       $prefix The prefix/namespace, with trailing '\\'
+     * @param array|string $paths  The PSR-4 base directories
+     *
+     * @throws \InvalidArgumentException
+     */
+    public function setPsr4($prefix, $paths)
+    {
+        if (!$prefix) {
+            $this->fallbackDirsPsr4 = (array) $paths;
+        } else {
+            $length = strlen($prefix);
+            if ('\\' !== $prefix[$length - 1]) {
+                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
+            }
+            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
+            $this->prefixDirsPsr4[$prefix] = (array) $paths;
+        }
+    }
+
+    /**
+     * Turns on searching the include path for class files.
+     *
+     * @param bool $useIncludePath
+     */
+    public function setUseIncludePath($useIncludePath)
+    {
+        $this->useIncludePath = $useIncludePath;
+    }
+
+    /**
+     * Can be used to check if the autoloader uses the include path to check
+     * for classes.
+     *
+     * @return bool
+     */
+    public function getUseIncludePath()
+    {
+        return $this->useIncludePath;
+    }
+
+    /**
+     * Turns off searching the prefix and fallback directories for classes
+     * that have not been registered with the class map.
+     *
+     * @param bool $classMapAuthoritative
+     */
+    public function setClassMapAuthoritative($classMapAuthoritative)
+    {
+        $this->classMapAuthoritative = $classMapAuthoritative;
+    }
+
+    /**
+     * Should class lookup fail if not found in the current class map?
+     *
+     * @return bool
+     */
+    public function isClassMapAuthoritative()
+    {
+        return $this->classMapAuthoritative;
+    }
+
+    /**
+     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
+     *
+     * @param string|null $apcuPrefix
+     */
+    public function setApcuPrefix($apcuPrefix)
+    {
+        $this->apcuPrefix = function_exists('apcu_fetch') && ini_get('apc.enabled') ? $apcuPrefix : null;
+    }
+
+    /**
+     * The APCu prefix in use, or null if APCu caching is not enabled.
+     *
+     * @return string|null
+     */
+    public function getApcuPrefix()
+    {
+        return $this->apcuPrefix;
+    }
+
+    /**
+     * Registers this instance as an autoloader.
+     *
+     * @param bool $prepend Whether to prepend the autoloader or not
+     */
+    public function register($prepend = false)
+    {
+        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
+    }
+
+    /**
+     * Unregisters this instance as an autoloader.
+     */
+    public function unregister()
+    {
+        spl_autoload_unregister(array($this, 'loadClass'));
+    }
+
+    /**
+     * Loads the given class or interface.
+     *
+     * @param  string    $class The name of the class
+     * @return bool|null True if loaded, null otherwise
+     */
+    public function loadClass($class)
+    {
+        if ($file = $this->findFile($class)) {
+            includeFile($file);
+
+            return true;
+        }
+    }
+
+    /**
+     * Finds the path to the file where the class is defined.
+     *
+     * @param string $class The name of the class
+     *
+     * @return string|false The path if found, false otherwise
+     */
+    public function findFile($class)
+    {
+        // class map lookup
+        if (isset($this->classMap[$class])) {
+            return $this->classMap[$class];
+        }
+        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
+            return false;
+        }
+        if (null !== $this->apcuPrefix) {
+            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
+            if ($hit) {
+                return $file;
+            }
+        }
+
+        $file = $this->findFileWithExtension($class, '.php');
+
+        // Search for Hack files if we are running on HHVM
+        if (false === $file && defined('HHVM_VERSION')) {
+            $file = $this->findFileWithExtension($class, '.hh');
+        }
+
+        if (null !== $this->apcuPrefix) {
+            apcu_add($this->apcuPrefix.$class, $file);
+        }
+
+        if (false === $file) {
+            // Remember that this class does not exist.
+            $this->missingClasses[$class] = true;
+        }
+
+        return $file;
+    }
+
+    private function findFileWithExtension($class, $ext)
+    {
+        // PSR-4 lookup
+        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
+
+        $first = $class[0];
+        if (isset($this->prefixLengthsPsr4[$first])) {
+            $subPath = $class;
+            while (false !== $lastPos = strrpos($subPath, '\\')) {
+                $subPath = substr($subPath, 0, $lastPos);
+                $search = $subPath.'\\';
+                if (isset($this->prefixDirsPsr4[$search])) {
+                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
+                        $length = $this->prefixLengthsPsr4[$first][$search];
+                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
+                            return $file;
+                        }
+                    }
+                }
+            }
+        }
+
+        // PSR-4 fallback dirs
+        foreach ($this->fallbackDirsPsr4 as $dir) {
+            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
+                return $file;
+            }
+        }
+
+        // PSR-0 lookup
+        if (false !== $pos = strrpos($class, '\\')) {
+            // namespaced class name
+            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
+                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
+        } else {
+            // PEAR-like class name
+            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
+        }
+
+        if (isset($this->prefixesPsr0[$first])) {
+            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
+                if (0 === strpos($class, $prefix)) {
+                    foreach ($dirs as $dir) {
+                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
+                            return $file;
+                        }
+                    }
+                }
+            }
+        }
+
+        // PSR-0 fallback dirs
+        foreach ($this->fallbackDirsPsr0 as $dir) {
+            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
+                return $file;
+            }
+        }
+
+        // PSR-0 include paths.
+        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
+            return $file;
+        }
+
+        return false;
+    }
+}
+
+/**
+ * Scope isolated include.
+ *
+ * Prevents access to $this/self from included files.
+ */
+function includeFile($file)
+{
+    include $file;
+}
diff --git a/vendor/composer/LICENSE b/vendor/composer/LICENSE
new file mode 100644
index 0000000..f27399a
--- /dev/null
+++ b/vendor/composer/LICENSE
@@ -0,0 +1,21 @@
+
+Copyright (c) Nils Adermann, Jordi Boggiano
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is furnished
+to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
diff --git a/vendor/composer/autoload_classmap.php b/vendor/composer/autoload_classmap.php
new file mode 100644
index 0000000..7a91153
--- /dev/null
+++ b/vendor/composer/autoload_classmap.php
@@ -0,0 +1,9 @@
+<?php
+
+// autoload_classmap.php @generated by Composer
+
+$vendorDir = dirname(dirname(__FILE__));
+$baseDir = dirname($vendorDir);
+
+return array(
+);
diff --git a/vendor/composer/autoload_files.php b/vendor/composer/autoload_files.php
new file mode 100644
index 0000000..4202030
--- /dev/null
+++ b/vendor/composer/autoload_files.php
@@ -0,0 +1,10 @@
+<?php
+
+// autoload_files.php @generated by Composer
+
+$vendorDir = dirname(dirname(__FILE__));
+$baseDir = dirname($vendorDir);
+
+return array(
+    '253c157292f75eb38082b5acb06f3f01' => $vendorDir . '/nikic/fast-route/src/functions.php',
+);
diff --git a/vendor/composer/autoload_namespaces.php b/vendor/composer/autoload_namespaces.php
new file mode 100644
index 0000000..c3cd022
--- /dev/null
+++ b/vendor/composer/autoload_namespaces.php
@@ -0,0 +1,10 @@
+<?php
+
+// autoload_namespaces.php @generated by Composer
+
+$vendorDir = dirname(dirname(__FILE__));
+$baseDir = dirname($vendorDir);
+
+return array(
+    'Pimple' => array($vendorDir . '/pimple/pimple/src'),
+);
diff --git a/vendor/composer/autoload_psr4.php b/vendor/composer/autoload_psr4.php
new file mode 100644
index 0000000..9c0b471
--- /dev/null
+++ b/vendor/composer/autoload_psr4.php
@@ -0,0 +1,14 @@
+<?php
+
+// autoload_psr4.php @generated by Composer
+
+$vendorDir = dirname(dirname(__FILE__));
+$baseDir = dirname($vendorDir);
+
+return array(
+    'Slim\\' => array($vendorDir . '/slim/slim/Slim'),
+    'Psr\\Http\\Message\\' => array($vendorDir . '/psr/http-message/src'),
+    'Psr\\Container\\' => array($vendorDir . '/psr/container/src'),
+    'Interop\\Container\\' => array($vendorDir . '/container-interop/container-interop/src/Interop/Container'),
+    'FastRoute\\' => array($vendorDir . '/nikic/fast-route/src'),
+);
diff --git a/vendor/composer/autoload_real.php b/vendor/composer/autoload_real.php
new file mode 100644
index 0000000..57457fa
--- /dev/null
+++ b/vendor/composer/autoload_real.php
@@ -0,0 +1,70 @@
+<?php
+
+// autoload_real.php @generated by Composer
+
+class ComposerAutoloaderInit679949ef461b333be25922e78be20b1d
+{
+    private static $loader;
+
+    public static function loadClassLoader($class)
+    {
+        if ('Composer\Autoload\ClassLoader' === $class) {
+            require __DIR__ . '/ClassLoader.php';
+        }
+    }
+
+    public static function getLoader()
+    {
+        if (null !== self::$loader) {
+            return self::$loader;
+        }
+
+        spl_autoload_register(array('ComposerAutoloaderInit679949ef461b333be25922e78be20b1d', 'loadClassLoader'), true, true);
+        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
+        spl_autoload_unregister(array('ComposerAutoloaderInit679949ef461b333be25922e78be20b1d', 'loadClassLoader'));
+
+        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
+        if ($useStaticLoader) {
+            require_once __DIR__ . '/autoload_static.php';
+
+            call_user_func(\Composer\Autoload\ComposerStaticInit679949ef461b333be25922e78be20b1d::getInitializer($loader));
+        } else {
+            $map = require __DIR__ . '/autoload_namespaces.php';
+            foreach ($map as $namespace => $path) {
+                $loader->set($namespace, $path);
+            }
+
+            $map = require __DIR__ . '/autoload_psr4.php';
+            foreach ($map as $namespace => $path) {
+                $loader->setPsr4($namespace, $path);
+            }
+
+            $classMap = require __DIR__ . '/autoload_classmap.php';
+            if ($classMap) {
+                $loader->addClassMap($classMap);
+            }
+        }
+
+        $loader->register(true);
+
+        if ($useStaticLoader) {
+            $includeFiles = Composer\Autoload\ComposerStaticInit679949ef461b333be25922e78be20b1d::$files;
+        } else {
+            $includeFiles = require __DIR__ . '/autoload_files.php';
+        }
+        foreach ($includeFiles as $fileIdentifier => $file) {
+            composerRequire679949ef461b333be25922e78be20b1d($fileIdentifier, $file);
+        }
+
+        return $loader;
+    }
+}
+
+function composerRequire679949ef461b333be25922e78be20b1d($fileIdentifier, $file)
+{
+    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
+        require $file;
+
+        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
+    }
+}
diff --git a/vendor/composer/autoload_static.php b/vendor/composer/autoload_static.php
new file mode 100644
index 0000000..ce44354
--- /dev/null
+++ b/vendor/composer/autoload_static.php
@@ -0,0 +1,75 @@
+<?php
+
+// autoload_static.php @generated by Composer
+
+namespace Composer\Autoload;
+
+class ComposerStaticInit679949ef461b333be25922e78be20b1d
+{
+    public static $files = array (
+        '253c157292f75eb38082b5acb06f3f01' => __DIR__ . '/..' . '/nikic/fast-route/src/functions.php',
+    );
+
+    public static $prefixLengthsPsr4 = array (
+        'S' => 
+        array (
+            'Slim\\' => 5,
+        ),
+        'P' => 
+        array (
+            'Psr\\Http\\Message\\' => 17,
+            'Psr\\Container\\' => 14,
+        ),
+        'I' => 
+        array (
+            'Interop\\Container\\' => 18,
+        ),
+        'F' => 
+        array (
+            'FastRoute\\' => 10,
+        ),
+    );
+
+    public static $prefixDirsPsr4 = array (
+        'Slim\\' => 
+        array (
+            0 => __DIR__ . '/..' . '/slim/slim/Slim',
+        ),
+        'Psr\\Http\\Message\\' => 
+        array (
+            0 => __DIR__ . '/..' . '/psr/http-message/src',
+        ),
+        'Psr\\Container\\' => 
+        array (
+            0 => __DIR__ . '/..' . '/psr/container/src',
+        ),
+        'Interop\\Container\\' => 
+        array (
+            0 => __DIR__ . '/..' . '/container-interop/container-interop/src/Interop/Container',
+        ),
+        'FastRoute\\' => 
+        array (
+            0 => __DIR__ . '/..' . '/nikic/fast-route/src',
+        ),
+    );
+
+    public static $prefixesPsr0 = array (
+        'P' => 
+        array (
+            'Pimple' => 
+            array (
+                0 => __DIR__ . '/..' . '/pimple/pimple/src',
+            ),
+        ),
+    );
+
+    public static function getInitializer(ClassLoader $loader)
+    {
+        return \Closure::bind(function () use ($loader) {
+            $loader->prefixLengthsPsr4 = ComposerStaticInit679949ef461b333be25922e78be20b1d::$prefixLengthsPsr4;
+            $loader->prefixDirsPsr4 = ComposerStaticInit679949ef461b333be25922e78be20b1d::$prefixDirsPsr4;
+            $loader->prefixesPsr0 = ComposerStaticInit679949ef461b333be25922e78be20b1d::$prefixesPsr0;
+
+        }, null, ClassLoader::class);
+    }
+}
diff --git a/vendor/composer/installed.json b/vendor/composer/installed.json
new file mode 100644
index 0000000..2cbbf08
--- /dev/null
+++ b/vendor/composer/installed.json
@@ -0,0 +1,304 @@
+[
+    {
+        "name": "psr/container",
+        "version": "1.0.0",
+        "version_normalized": "1.0.0.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/php-fig/container.git",
+            "reference": "b7ce3b176482dbbc1245ebf52b181af44c2cf55f"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/php-fig/container/zipball/b7ce3b176482dbbc1245ebf52b181af44c2cf55f",
+            "reference": "b7ce3b176482dbbc1245ebf52b181af44c2cf55f",
+            "shasum": ""
+        },
+        "require": {
+            "php": ">=5.3.0"
+        },
+        "time": "2017-02-14T16:28:37+00:00",
+        "type": "library",
+        "extra": {
+            "branch-alias": {
+                "dev-master": "1.0.x-dev"
+            }
+        },
+        "installation-source": "dist",
+        "autoload": {
+            "psr-4": {
+                "Psr\\Container\\": "src/"
+            }
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "MIT"
+        ],
+        "authors": [
+            {
+                "name": "PHP-FIG",
+                "homepage": "http://www.php-fig.org/"
+            }
+        ],
+        "description": "Common Container Interface (PHP FIG PSR-11)",
+        "homepage": "https://github.com/php-fig/container",
+        "keywords": [
+            "PSR-11",
+            "container",
+            "container-interface",
+            "container-interop",
+            "psr"
+        ]
+    },
+    {
+        "name": "container-interop/container-interop",
+        "version": "1.2.0",
+        "version_normalized": "1.2.0.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/container-interop/container-interop.git",
+            "reference": "79cbf1341c22ec75643d841642dd5d6acd83bdb8"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/container-interop/container-interop/zipball/79cbf1341c22ec75643d841642dd5d6acd83bdb8",
+            "reference": "79cbf1341c22ec75643d841642dd5d6acd83bdb8",
+            "shasum": ""
+        },
+        "require": {
+            "psr/container": "^1.0"
+        },
+        "time": "2017-02-14T19:40:03+00:00",
+        "type": "library",
+        "installation-source": "dist",
+        "autoload": {
+            "psr-4": {
+                "Interop\\Container\\": "src/Interop/Container/"
+            }
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "MIT"
+        ],
+        "description": "Promoting the interoperability of container objects (DIC, SL, etc.)",
+        "homepage": "https://github.com/container-interop/container-interop"
+    },
+    {
+        "name": "nikic/fast-route",
+        "version": "v1.2.0",
+        "version_normalized": "1.2.0.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/nikic/FastRoute.git",
+            "reference": "b5f95749071c82a8e0f58586987627054400cdf6"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/nikic/FastRoute/zipball/b5f95749071c82a8e0f58586987627054400cdf6",
+            "reference": "b5f95749071c82a8e0f58586987627054400cdf6",
+            "shasum": ""
+        },
+        "require": {
+            "php": ">=5.4.0"
+        },
+        "time": "2017-01-19T11:35:12+00:00",
+        "type": "library",
+        "installation-source": "dist",
+        "autoload": {
+            "psr-4": {
+                "FastRoute\\": "src/"
+            },
+            "files": [
+                "src/functions.php"
+            ]
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "BSD-3-Clause"
+        ],
+        "authors": [
+            {
+                "name": "Nikita Popov",
+                "email": "nikic@php.net"
+            }
+        ],
+        "description": "Fast request router for PHP",
+        "keywords": [
+            "router",
+            "routing"
+        ]
+    },
+    {
+        "name": "psr/http-message",
+        "version": "1.0.1",
+        "version_normalized": "1.0.1.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/php-fig/http-message.git",
+            "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/php-fig/http-message/zipball/f6561bf28d520154e4b0ec72be95418abe6d9363",
+            "reference": "f6561bf28d520154e4b0ec72be95418abe6d9363",
+            "shasum": ""
+        },
+        "require": {
+            "php": ">=5.3.0"
+        },
+        "time": "2016-08-06T14:39:51+00:00",
+        "type": "library",
+        "extra": {
+            "branch-alias": {
+                "dev-master": "1.0.x-dev"
+            }
+        },
+        "installation-source": "dist",
+        "autoload": {
+            "psr-4": {
+                "Psr\\Http\\Message\\": "src/"
+            }
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "MIT"
+        ],
+        "authors": [
+            {
+                "name": "PHP-FIG",
+                "homepage": "http://www.php-fig.org/"
+            }
+        ],
+        "description": "Common interface for HTTP messages",
+        "homepage": "https://github.com/php-fig/http-message",
+        "keywords": [
+            "http",
+            "http-message",
+            "psr",
+            "psr-7",
+            "request",
+            "response"
+        ]
+    },
+    {
+        "name": "pimple/pimple",
+        "version": "v3.0.2",
+        "version_normalized": "3.0.2.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/silexphp/Pimple.git",
+            "reference": "a30f7d6e57565a2e1a316e1baf2a483f788b258a"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/silexphp/Pimple/zipball/a30f7d6e57565a2e1a316e1baf2a483f788b258a",
+            "reference": "a30f7d6e57565a2e1a316e1baf2a483f788b258a",
+            "shasum": ""
+        },
+        "require": {
+            "php": ">=5.3.0"
+        },
+        "time": "2015-09-11T15:10:35+00:00",
+        "type": "library",
+        "extra": {
+            "branch-alias": {
+                "dev-master": "3.0.x-dev"
+            }
+        },
+        "installation-source": "dist",
+        "autoload": {
+            "psr-0": {
+                "Pimple": "src/"
+            }
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "MIT"
+        ],
+        "authors": [
+            {
+                "name": "Fabien Potencier",
+                "email": "fabien@symfony.com"
+            }
+        ],
+        "description": "Pimple, a simple Dependency Injection Container",
+        "homepage": "http://pimple.sensiolabs.org",
+        "keywords": [
+            "container",
+            "dependency injection"
+        ]
+    },
+    {
+        "name": "slim/slim",
+        "version": "3.8.1",
+        "version_normalized": "3.8.1.0",
+        "source": {
+            "type": "git",
+            "url": "https://github.com/slimphp/Slim.git",
+            "reference": "5385302707530b2bccee1769613ad769859b826d"
+        },
+        "dist": {
+            "type": "zip",
+            "url": "https://api.github.com/repos/slimphp/Slim/zipball/5385302707530b2bccee1769613ad769859b826d",
+            "reference": "5385302707530b2bccee1769613ad769859b826d",
+            "shasum": ""
+        },
+        "require": {
+            "container-interop/container-interop": "^1.2",
+            "nikic/fast-route": "^1.0",
+            "php": ">=5.5.0",
+            "pimple/pimple": "^3.0",
+            "psr/container": "^1.0",
+            "psr/http-message": "^1.0"
+        },
+        "provide": {
+            "psr/http-message-implementation": "1.0"
+        },
+        "require-dev": {
+            "phpunit/phpunit": "^4.0",
+            "squizlabs/php_codesniffer": "^2.5"
+        },
+        "time": "2017-03-19T17:55:20+00:00",
+        "type": "library",
+        "installation-source": "dist",
+        "autoload": {
+            "psr-4": {
+                "Slim\\": "Slim"
+            }
+        },
+        "notification-url": "https://packagist.org/downloads/",
+        "license": [
+            "MIT"
+        ],
+        "authors": [
+            {
+                "name": "Rob Allen",
+                "email": "rob@akrabat.com",
+                "homepage": "http://akrabat.com"
+            },
+            {
+                "name": "Josh Lockhart",
+                "email": "hello@joshlockhart.com",
+                "homepage": "https://joshlockhart.com"
+            },
+            {
+                "name": "Gabriel Manricks",
+                "email": "gmanricks@me.com",
+                "homepage": "http://gabrielmanricks.com"
+            },
+            {
+                "name": "Andrew Smith",
+                "email": "a.smith@silentworks.co.uk",
+                "homepage": "http://silentworks.co.uk"
+            }
+        ],
+        "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
+        "homepage": "https://slimframework.com",
+        "keywords": [
+            "api",
+            "framework",
+            "micro",
+            "router"
+        ]
+    }
+]
diff --git a/vendor/container-interop/container-interop/.gitignore b/vendor/container-interop/container-interop/.gitignore
new file mode 100644
index 0000000..b2395aa
--- /dev/null
+++ b/vendor/container-interop/container-interop/.gitignore
@@ -0,0 +1,3 @@
+composer.lock
+composer.phar
+/vendor/
diff --git a/vendor/container-interop/container-interop/LICENSE b/vendor/container-interop/container-interop/LICENSE
new file mode 100644
index 0000000..7671d90
--- /dev/null
+++ b/vendor/container-interop/container-interop/LICENSE
@@ -0,0 +1,20 @@
+The MIT License (MIT)
+
+Copyright (c) 2013 container-interop
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/container-interop/container-interop/README.md b/vendor/container-interop/container-interop/README.md
new file mode 100644
index 0000000..cdd7a44
--- /dev/null
+++ b/vendor/container-interop/container-interop/README.md
@@ -0,0 +1,148 @@
+# Container Interoperability
+
+[![Latest Stable Version](https://poser.pugx.org/container-interop/container-interop/v/stable.png)](https://packagist.org/packages/container-interop/container-interop)
+[![Total Downloads](https://poser.pugx.org/container-interop/container-interop/downloads.svg)](https://packagist.org/packages/container-interop/container-interop)
+
+## Deprecation warning!
+
+Starting Feb. 13th 2017, container-interop is officially deprecated in favor of [PSR-11](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md).
+Container-interop has been the test-bed of PSR-11. From v1.2, container-interop directly extends PSR-11 interfaces.
+Therefore, all containers implementing container-interop are now *de-facto* compatible with PSR-11.
+
+- Projects implementing container-interop interfaces are encouraged to directly implement PSR-11 interfaces instead.
+- Projects consuming container-interop interfaces are very strongly encouraged to directly type-hint on PSR-11 interfaces, in order to be compatible with PSR-11 containers that are not compatible with container-interop.
+
+Regarding the delegate lookup feature, that is present in container-interop and not in PSR-11, the feature is actually a design pattern. It is therefore not deprecated. Documentation regarding this design pattern will be migrated from this repository into a separate website in the future.
+
+## About
+
+*container-interop* tries to identify and standardize features in *container* objects (service locators,
+dependency injection containers, etc.) to achieve interoperability.
+
+Through discussions and trials, we try to create a standard, made of common interfaces but also recommendations.
+
+If PHP projects that provide container implementations begin to adopt these common standards, then PHP
+applications and projects that use containers can depend on the common interfaces instead of specific
+implementations. This facilitates a high-level of interoperability and flexibility that allows users to consume
+*any* container implementation that can be adapted to these interfaces.
+
+The work done in this project is not officially endorsed by the [PHP-FIG](http://www.php-fig.org/), but it is being
+worked on by members of PHP-FIG and other good developers. We adhere to the spirit and ideals of PHP-FIG, and hope
+this project will pave the way for one or more future PSRs.
+
+
+## Installation
+
+You can install this package through Composer:
+
+```json
+composer require container-interop/container-interop
+```
+
+The packages adheres to the [SemVer](http://semver.org/) specification, and there will be full backward compatibility
+between minor versions.
+
+## Standards
+
+### Available
+
+- [`ContainerInterface`](src/Interop/Container/ContainerInterface.php).
+[Description](docs/ContainerInterface.md) [Meta Document](docs/ContainerInterface-meta.md).
+Describes the interface of a container that exposes methods to read its entries.
+- [*Delegate lookup feature*](docs/Delegate-lookup.md).
+[Meta Document](docs/Delegate-lookup-meta.md).
+Describes the ability for a container to delegate the lookup of its dependencies to a third-party container. This
+feature lets several containers work together in a single application.
+
+### Proposed
+
+View open [request for comments](https://github.com/container-interop/container-interop/labels/RFC)
+
+## Compatible projects
+
+### Projects implementing `ContainerInterface`
+
+- [Acclimate](https://github.com/jeremeamia/acclimate-container): Adapters for
+  Aura.Di, Laravel, Nette DI, Pimple, Symfony DI, ZF2 Service manager, ZF2
+  Dependency injection and any container using `ArrayAccess`
+- [Aura.Di](https://github.com/auraphp/Aura.Di)
+- [auryn-container-interop](https://github.com/elazar/auryn-container-interop)
+- [Burlap](https://github.com/codeeverything/burlap)
+- [Chernozem](https://github.com/pyrsmk/Chernozem)
+- [Data Manager](https://github.com/chrismichaels84/data-manager)
+- [Disco](https://github.com/bitexpert/disco)
+- [InDI](https://github.com/idealogica/indi)
+- [League/Container](http://container.thephpleague.com/)
+- [Mouf](http://mouf-php.com)
+- [Njasm Container](https://github.com/njasm/container)
+- [PHP-DI](http://php-di.org)
+- [Picotainer](https://github.com/thecodingmachine/picotainer)
+- [PimpleInterop](https://github.com/moufmouf/pimple-interop)
+- [Pimple3-ContainerInterop](https://github.com/Sam-Burns/pimple3-containerinterop) (using Pimple v3)
+- [SitePoint Container](https://github.com/sitepoint/Container)
+- [Thruster Container](https://github.com/ThrusterIO/container) (PHP7 only)
+- [Ultra-Lite Container](https://github.com/ultra-lite/container)
+- [Unbox](https://github.com/mindplay-dk/unbox)
+- [XStatic](https://github.com/jeremeamia/xstatic)
+- [Zend\ServiceManager](https://github.com/zendframework/zend-servicemanager)
+- [Zit](https://github.com/inxilpro/Zit)
+
+### Projects implementing the *delegate lookup* feature
+
+- [Aura.Di](https://github.com/auraphp/Aura.Di)
+- [Burlap](https://github.com/codeeverything/burlap)
+- [Chernozem](https://github.com/pyrsmk/Chernozem)
+- [InDI](https://github.com/idealogica/indi)
+- [League/Container](http://container.thephpleague.com/)
+- [Mouf](http://mouf-php.com)
+- [Picotainer](https://github.com/thecodingmachine/picotainer)
+- [PHP-DI](http://php-di.org)
+- [PimpleInterop](https://github.com/moufmouf/pimple-interop)
+- [Ultra-Lite Container](https://github.com/ultra-lite/container)
+
+### Middlewares implementing `ContainerInterface`
+
+- [Alias-Container](https://github.com/thecodingmachine/alias-container): add
+  aliases support to any container
+- [Prefixer-Container](https://github.com/thecodingmachine/prefixer-container):
+  dynamically prefix identifiers
+- [Lazy-Container](https://github.com/snapshotpl/lazy-container): lazy services
+
+### Projects using `ContainerInterface`
+
+The list below contains only a sample of all the projects consuming `ContainerInterface`. For a more complete list have a look [here](http://packanalyst.com/class?q=Interop%5CContainer%5CContainerInterface).
+
+| | Downloads |
+| --- | --- |
+| [Adroit](https://github.com/bitexpert/adroit) | ![](https://img.shields.io/packagist/dt/bitexpert/adroit.svg) |
+| [Behat](https://github.com/Behat/Behat/pull/974) | ![](https://img.shields.io/packagist/dt/behat/behat.svg) |
+| [blast-facades](https://github.com/phpthinktank/blast-facades): Minimize complexity and represent dependencies as facades. | ![](https://img.shields.io/packagist/dt/blast/facades.svg) |
+| [interop.silex.di](https://github.com/thecodingmachine/interop.silex.di): an extension to [Silex](http://silex.sensiolabs.org/) that adds support for any *container-interop* compatible container | ![](https://img.shields.io/packagist/dt/mouf/interop.silex.di.svg) |
+| [mindplay/walkway](https://github.com/mindplay-dk/walkway): a modular request router | ![](https://img.shields.io/packagist/dt/mindplay/walkway.svg) |
+| [mindplay/middleman](https://github.com/mindplay-dk/middleman): minimalist PSR-7 middleware dispatcher | ![](https://img.shields.io/packagist/dt/mindplay/middleman.svg) |
+| [PHP-DI/Invoker](https://github.com/PHP-DI/Invoker): extensible and configurable invoker/dispatcher | ![](https://img.shields.io/packagist/dt/php-di/invoker.svg) |
+| [Prophiler](https://github.com/fabfuel/prophiler) | ![](https://img.shields.io/packagist/dt/fabfuel/prophiler.svg) |
+| [Silly](https://github.com/mnapoli/silly): CLI micro-framework | ![](https://img.shields.io/packagist/dt/mnapoli/silly.svg) |
+| [Slim v3](https://github.com/slimphp/Slim) | ![](https://img.shields.io/packagist/dt/slim/slim.svg) |
+| [Splash](http://mouf-php.com/packages/mouf/mvc.splash-common/version/8.0-dev/README.md) | ![](https://img.shields.io/packagist/dt/mouf/mvc.splash-common.svg) |
+| [Woohoo Labs. Harmony](https://github.com/woohoolabs/harmony): a flexible micro-framework | ![](https://img.shields.io/packagist/dt/woohoolabs/harmony.svg) |
+| [zend-expressive](https://github.com/zendframework/zend-expressive) | ![](https://img.shields.io/packagist/dt/zendframework/zend-expressive.svg) |
+
+
+## Workflow
+
+Everyone is welcome to join and contribute.
+
+The general workflow looks like this:
+
+1. Someone opens a discussion (GitHub issue) to suggest an interface
+1. Feedback is gathered
+1. The interface is added to a development branch
+1. We release alpha versions so that the interface can be experimented with
+1. Discussions and edits ensue until the interface is deemed stable by a general consensus
+1. A new minor version of the package is released
+
+We try to not break BC by creating new interfaces instead of editing existing ones.
+
+While we currently work on interfaces, we are open to anything that might help towards interoperability, may that
+be code, best practices, etc.
diff --git a/vendor/container-interop/container-interop/composer.json b/vendor/container-interop/container-interop/composer.json
new file mode 100644
index 0000000..855f766
--- /dev/null
+++ b/vendor/container-interop/container-interop/composer.json
@@ -0,0 +1,15 @@
+{
+    "name": "container-interop/container-interop",
+    "type": "library",
+    "description": "Promoting the interoperability of container objects (DIC, SL, etc.)",
+    "homepage": "https://github.com/container-interop/container-interop",
+    "license": "MIT",
+    "autoload": {
+        "psr-4": {
+            "Interop\\Container\\": "src/Interop/Container/"
+        }
+    },
+    "require": {
+        "psr/container": "^1.0"
+    }
+}
diff --git a/vendor/container-interop/container-interop/docs/ContainerInterface-meta.md b/vendor/container-interop/container-interop/docs/ContainerInterface-meta.md
new file mode 100644
index 0000000..59f3d55
--- /dev/null
+++ b/vendor/container-interop/container-interop/docs/ContainerInterface-meta.md
@@ -0,0 +1,114 @@
+# ContainerInterface Meta Document
+
+## Introduction
+
+This document describes the process and discussions that lead to the `ContainerInterface`.
+Its goal is to explain the reasons behind each decision.
+
+## Goal
+
+The goal set by `ContainerInterface` is to standardize how frameworks and libraries make use of a
+container to obtain objects and parameters.
+
+By standardizing such a behavior, frameworks and libraries using the `ContainerInterface`
+could work with any compatible container.
+That would allow end users to choose their own container based on their own preferences.
+
+It is important to distinguish the two usages of a container:
+
+- configuring entries
+- fetching entries
+
+Most of the time, those two sides are not used by the same party.
+While it is often end users who tend to configure entries, it is generally the framework that fetch
+entries to build the application.
+
+This is why this interface focuses only on how entries can be fetched from a container.
+
+## Interface name
+
+The interface name has been thoroughly discussed and was decided by a vote.
+
+The list of options considered with their respective votes are:
+
+- `ContainerInterface`: +8
+- `ProviderInterface`: +2
+- `LocatorInterface`: 0
+- `ReadableContainerInterface`: -5
+- `ServiceLocatorInterface`: -6
+- `ObjectFactory`: -6
+- `ObjectStore`: -8
+- `ConsumerInterface`: -9
+
+[Full results of the vote](https://github.com/container-interop/container-interop/wiki/%231-interface-name:-Vote)
+
+The complete discussion can be read in [the issue #1](https://github.com/container-interop/container-interop/issues/1).
+
+## Interface methods
+
+The choice of which methods the interface would contain was made after a statistical analysis of existing containers.
+The results of this analysis are available [in this document](https://gist.github.com/mnapoli/6159681).
+
+The summary of the analysis showed that:
+
+- all containers offer a method to get an entry by its id
+- a large majority name such method `get()`
+- for all containers, the `get()` method has 1 mandatory parameter of type string
+- some containers have an optional additional argument for `get()`, but it doesn't have the same purpose between containers
+- a large majority of the containers offer a method to test if it can return an entry by its id
+- a majority name such method `has()`
+- for all containers offering `has()`, the method has exactly 1 parameter of type string
+- a large majority of the containers throw an exception rather than returning null when an entry is not found in `get()`
+- a large majority of the containers don't implement `ArrayAccess`
+
+The question of whether to include methods to define entries has been discussed in
+[issue #1](https://github.com/container-interop/container-interop/issues/1).
+It has been judged that such methods do not belong in the interface described here because it is out of its scope
+(see the "Goal" section).
+
+As a result, the `ContainerInterface` contains two methods:
+
+- `get()`, returning anything, with one mandatory string parameter. Should throw an exception if the entry is not found.
+- `has()`, returning a boolean, with one mandatory string parameter.
+
+### Number of parameters in `get()` method
+
+While `ContainerInterface` only defines one mandatory parameter in `get()`, it is not incompatible with
+existing containers that have additional optional parameters. PHP allows an implementation to offer more parameters
+as long as they are optional, because the implementation *does* satisfy the interface.
+
+This issue has been discussed in [issue #6](https://github.com/container-interop/container-interop/issues/6).
+
+### Type of the `$id` parameter
+
+The type of the `$id` parameter in `get()` and `has()` has been discussed in
+[issue #6](https://github.com/container-interop/container-interop/issues/6).
+While `string` is used in all the containers that were analyzed, it was suggested that allowing
+anything (such as objects) could allow containers to offer a more advanced query API.
+
+An example given was to use the container as an object builder. The `$id` parameter would then be an
+object that would describe how to create an instance.
+
+The conclusion of the discussion was that this was beyond the scope of getting entries from a container without
+knowing how the container provided them, and it was more fit for a factory.
+
+## Contributors
+
+Are listed here all people that contributed in the discussions or votes, by alphabetical order:
+
+- [Amy Stephen](https://github.com/AmyStephen)
+- [David Négrier](https://github.com/moufmouf)
+- [Don Gilbert](https://github.com/dongilbert)
+- [Jason Judge](https://github.com/judgej)
+- [Jeremy Lindblom](https://github.com/jeremeamia)
+- [Marco Pivetta](https://github.com/Ocramius)
+- [Matthieu Napoli](https://github.com/mnapoli)
+- [Paul M. Jones](https://github.com/pmjones)
+- [Stephan Hochdörfer](https://github.com/shochdoerfer)
+- [Taylor Otwell](https://github.com/taylorotwell)
+
+## Relevant links
+
+- [`ContainerInterface.php`](https://github.com/container-interop/container-interop/blob/master/src/Interop/Container/ContainerInterface.php)
+- [List of all issues](https://github.com/container-interop/container-interop/issues?labels=ContainerInterface&milestone=&page=1&state=closed)
+- [Vote for the interface name](https://github.com/container-interop/container-interop/wiki/%231-interface-name:-Vote)
diff --git a/vendor/container-interop/container-interop/docs/ContainerInterface.md b/vendor/container-interop/container-interop/docs/ContainerInterface.md
new file mode 100644
index 0000000..bda973d
--- /dev/null
+++ b/vendor/container-interop/container-interop/docs/ContainerInterface.md
@@ -0,0 +1,158 @@
+Container interface
+===================
+
+This document describes a common interface for dependency injection containers.
+
+The goal set by `ContainerInterface` is to standardize how frameworks and libraries make use of a
+container to obtain objects and parameters (called *entries* in the rest of this document).
+
+The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
+"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
+interpreted as described in [RFC 2119][].
+
+The word `implementor` in this document is to be interpreted as someone
+implementing the `ContainerInterface` in a dependency injection-related library or framework.
+Users of dependency injections containers (DIC) are referred to as `user`.
+
+[RFC 2119]: http://tools.ietf.org/html/rfc2119
+
+1. Specification
+-----------------
+
+### 1.1 Basics
+
+- The `Interop\Container\ContainerInterface` exposes two methods : `get` and `has`.
+
+- `get` takes one mandatory parameter: an entry identifier. It MUST be a string.
+  A call to `get` can return anything (a *mixed* value), or throws an exception if the identifier
+  is not known to the container. Two successive calls to `get` with the same
+  identifier SHOULD return the same value. However, depending on the `implementor`
+  design and/or `user` configuration, different values might be returned, so
+  `user` SHOULD NOT rely on getting the same value on 2 successive calls.
+  While `ContainerInterface` only defines one mandatory parameter in `get()`, implementations
+  MAY accept additional optional parameters.
+
+- `has` takes one unique parameter: an entry identifier. It MUST return `true`
+  if an entry identifier is known to the container and `false` if it is not.
+  `has($id)` returning true does not mean that `get($id)` will not throw an exception.
+  It does however mean that `get($id)` will not throw a `NotFoundException`.
+
+### 1.2 Exceptions
+
+Exceptions directly thrown by the container MUST implement the
+[`Interop\Container\Exception\ContainerException`](../src/Interop/Container/Exception/ContainerException.php).
+
+A call to the `get` method with a non-existing id SHOULD throw a
+[`Interop\Container\Exception\NotFoundException`](../src/Interop/Container/Exception/NotFoundException.php).
+
+### 1.3 Additional features
+
+This section describes additional features that MAY be added to a container. Containers are not
+required to implement these features to respect the ContainerInterface.
+
+#### 1.3.1 Delegate lookup feature
+
+The goal of the *delegate lookup* feature is to allow several containers to share entries.
+Containers implementing this feature can perform dependency lookups in other containers.
+
+Containers implementing this feature will offer a greater lever of interoperability
+with other containers. Implementation of this feature is therefore RECOMMENDED.
+
+A container implementing this feature:
+
+- MUST implement the `ContainerInterface`
+- MUST provide a way to register a delegate container (using a constructor parameter, or a setter,
+  or any possible way). The delegate container MUST implement the `ContainerInterface`.
+
+When a container is configured to use a delegate container for dependencies:
+
+- Calls to the `get` method should only return an entry if the entry is part of the container.
+  If the entry is not part of the container, an exception should be thrown
+  (as requested by the `ContainerInterface`).
+- Calls to the `has` method should only return `true` if the entry is part of the container.
+  If the entry is not part of the container, `false` should be returned.
+- If the fetched entry has dependencies, **instead** of performing
+  the dependency lookup in the container, the lookup is performed on the *delegate container*.
+
+Important! By default, the lookup SHOULD be performed on the delegate container **only**, not on the container itself.
+
+It is however allowed for containers to provide exception cases for special entries, and a way to lookup
+into the same container (or another container) instead of the delegate container.
+
+2. Package
+----------
+
+The interfaces and classes described as well as relevant exception are provided as part of the
+[container-interop/container-interop](https://packagist.org/packages/container-interop/container-interop) package.
+
+3. `Interop\Container\ContainerInterface`
+-----------------------------------------
+
+```php
+<?php
+namespace Interop\Container;
+
+use Interop\Container\Exception\ContainerException;
+use Interop\Container\Exception\NotFoundException;
+
+/**
+ * Describes the interface of a container that exposes methods to read its entries.
+ */
+interface ContainerInterface
+{
+    /**
+     * Finds an entry of the container by its identifier and returns it.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @throws NotFoundException  No entry was found for this identifier.
+     * @throws ContainerException Error while retrieving the entry.
+     *
+     * @return mixed Entry.
+     */
+    public function get($id);
+
+    /**
+     * Returns true if the container can return an entry for the given identifier.
+     * Returns false otherwise.
+     *
+     * `has($id)` returning true does not mean that `get($id)` will not throw an exception.
+     * It does however mean that `get($id)` will not throw a `NotFoundException`.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @return boolean
+     */
+    public function has($id);
+}
+```
+
+4. `Interop\Container\Exception\ContainerException`
+---------------------------------------------------
+
+```php
+<?php
+namespace Interop\Container\Exception;
+
+/**
+ * Base interface representing a generic exception in a container.
+ */
+interface ContainerException
+{
+}
+```
+
+5. `Interop\Container\Exception\NotFoundException`
+---------------------------------------------------
+
+```php
+<?php
+namespace Interop\Container\Exception;
+
+/**
+ * No entry was found in the container.
+ */
+interface NotFoundException extends ContainerException
+{
+}
+```
diff --git a/vendor/container-interop/container-interop/docs/Delegate-lookup-meta.md b/vendor/container-interop/container-interop/docs/Delegate-lookup-meta.md
new file mode 100644
index 0000000..6048b73
--- /dev/null
+++ b/vendor/container-interop/container-interop/docs/Delegate-lookup-meta.md
@@ -0,0 +1,259 @@
+Delegate lookup feature Meta Document
+=====================================
+
+1. Summary
+----------
+
+This document describes the *delegate lookup feature*.
+Containers are not required to implement this feature to respect the `ContainerInterface`.
+However, containers implementing this feature will offer a greater lever of interoperability
+with other containers, allowing multiple containers to share entries in the same application.
+Implementation of this feature is therefore recommanded.
+
+2. Why Bother?
+--------------
+
+The [`ContainerInterface`](../src/Interop/Container/ContainerInterface.php) ([meta doc](ContainerInterface.md))
+standardizes how frameworks and libraries make use of a container to obtain objects and parameters.
+
+By standardizing such a behavior, frameworks and libraries relying on the `ContainerInterface`
+could work with any compatible container.
+That would allow end users to choose their own container based on their own preferences.
+
+The `ContainerInterface` is also enough if we want to have several containers side-by-side in the same
+application. For instance, this is what the [CompositeContainer](https://github.com/jeremeamia/acclimate-container/blob/master/src/CompositeContainer.php) 
+class of [Acclimate](https://github.com/jeremeamia/acclimate-container) is designed for:
+
+![Side by side containers](images/side_by_side_containers.png)
+
+However, an instance in container 1 cannot reference an instance in container 2.
+
+It would be better if an instance of container 1 could reference an instance in container 2,
+and the opposite should be true. 
+
+![Interoperating containers](images/interoperating_containers.png)
+
+In the sample above, entry 1 in container 1 is referencing entry 3 in container 2.
+
+3. Scope
+--------
+
+### 3.1 Goals
+
+The goal of the *delegate lookup* feature is to allow several containers to share entries.
+
+4. Approaches
+-------------
+
+### 4.1 Chosen Approach
+
+Containers implementing this feature can perform dependency lookups in other containers.
+
+A container implementing this feature:
+
+- must implement the `ContainerInterface`
+- must provide a way to register a *delegate container* (using a constructor parameter, or a setter, or any
+possible way). The *delegate container* must implement the `ContainerInterface`.
+
+When a *delegate container* is configured on a container:
+
+- Calls to the `get` method should only return an entry if the entry is part of the container.
+If the entry is not part of the container, an exception should be thrown (as required in the `ContainerInterface`).
+- Calls to the `has` method should only return *true* if the entry is part of the container.
+If the entry is not part of the container, *false* should be returned.
+ - Finally, the important part: if the entry we are fetching has dependencies,
+**instead** of perfoming the dependency lookup in the container, the lookup is performed on the *delegate container*.
+
+Important! By default, the lookup should be performed on the delegate container **only**, not on the container itself.
+
+It is however allowed for containers to provide exception cases for special entries, and a way to lookup into 
+the same container (or another container) instead of the delegate container.
+
+### 4.2 Typical usage
+
+The *delegate container* will usually be a composite container. A composite container is a container that
+contains several other containers. When performing a lookup on a composite container, the inner containers are 
+queried until one container returns an entry.
+An inner container implementing the *delegate lookup feature* will return entries it contains, but if these
+entries have dependencies, the dependencies lookup calls will be performed on the composite container, giving
+a chance to all containers to answer.
+
+Interestingly enough, the order in which containers are added in the composite container matters. Indeed,
+the first containers to be added in the composite container can "override" the entries of containers with
+lower priority.
+
+![Containers priority](images/priority.png)
+
+In the example above, "container 2" contains a controller "myController" and the controller is referencing an 
+"entityManager" entry. "Container 1" contains also an entry named "entityManager".
+Without the *delegate lookup* feature, when requesting the "myController" instance to container 2, it would take 
+in charge the instanciation of both entries.
+
+However, using the *delegate lookup* feature, here is what happens when we ask the composite container for the 
+"myController" instance:
+
+- The composite container asks container 1 if if contains the "myController" instance. The answer is no.
+- The composite container asks container 2 if if contains the "myController" instance. The answer is yes.
+- The composite container performs a `get` call on container 2 for the "myController" instance.
+- Container 2 sees that "myController" has a dependency on "entityManager".
+- Container 2 delegates the lookup of "entityManager" to the composite container.
+- The composite container asks container 1 if if contains the "entityManager" instance. The answer is yes.
+- The composite container performs a `get` call on container 1 for the "entityManager" instance.
+
+In the end, we get a controller instanciated by container 2 that references an entityManager instanciated
+by container 1.
+
+### 4.3 Alternative: the fallback strategy
+
+The first proposed approach we tried was to perform all the lookups in the "local" container,
+and if a lookup fails in the container, to use the delegate container. In this scenario, the
+delegate container is used in "fallback" mode.
+
+This strategy has been described in @moufmouf blog post: http://mouf-php.com/container-interop-whats-next (solution 1).
+It was also discussed [here](https://github.com/container-interop/container-interop/pull/8#issuecomment-33570697) and
+[here](https://github.com/container-interop/container-interop/pull/20#issuecomment-56599631).
+
+Problems with this strategy:
+
+- Heavy problem regarding infinite loops
+- Unable to overload a container entry with the delegate container entry
+
+### 4.4 Alternative: force implementing an interface
+
+The first proposed approach was to develop a `ParentAwareContainerInterface` interface.
+It was proposed here: https://github.com/container-interop/container-interop/pull/8
+
+The interface would have had the behaviour of the delegate lookup feature but would have forced the addition of
+a `setParentContainter` method:
+
+```php
+interface ParentAwareContainerInterface extends ReadableContainerInterface {
+    /**
+     * Sets the parent container associated to that container. This container will call
+     * the parent container to fetch dependencies.
+     *
+     * @param ContainerInterface $container
+     */
+    public function setParentContainer(ContainerInterface $container);
+}
+```
+
+The interface idea was first questioned by @Ocramius [here](https://github.com/container-interop/container-interop/pull/8#issuecomment-51721777).
+@Ocramius expressed the idea that an interface should not contain setters, otherwise, it is forcing implementation
+details on the class implementing the interface. 
+Then @mnapoli made a proposal for a "convention" [here](https://github.com/container-interop/container-interop/pull/8#issuecomment-51841079),
+this idea was further discussed until all participants in the discussion agreed to remove the interface idea
+and replace it with a "standard" feature.
+
+**Pros:**
+
+If we had had an interface, we could have delegated the registration of the delegate/composite container to the
+the delegate/composite container itself.
+For instance:
+
+```php
+$containerA = new ContainerA();
+$containerB = new ContainerB();
+
+$compositeContainer = new CompositeContainer([$containerA, $containerB]);
+
+// The call to 'setParentContainer' is delegated to the CompositeContainer
+// It is not the responsibility of the user anymore.
+class CompositeContainer {
+	...
+	
+	public function __construct($containers) {
+		foreach ($containers as $container) {
+			if ($container instanceof ParentAwareContainerInterface) {
+				$container->setParentContainer($this);
+			}
+		}
+		...
+	}
+}
+
+``` 
+
+**Cons:**
+
+Cons have been extensively discussed [here](https://github.com/container-interop/container-interop/pull/8#issuecomment-51721777).
+Basically, forcing a setter into an interface is a bad idea. Setters are similar to constructor arguments,
+and it's a bad idea to standardize a constructor: how the delegate container is configured into a container is an implementation detail. This outweights the benefits of the interface.
+
+### 4.4 Alternative: no exception case for delegate lookups
+
+Originally, the proposed wording for delegate lookup calls was:
+
+> Important! The lookup MUST be performed on the delegate container **only**, not on the container itself.
+
+This was later replaced by:
+
+> Important! By default, the lookup SHOULD be performed on the delegate container **only**, not on the container itself.
+>
+> It is however allowed for containers to provide exception cases for special entries, and a way to lookup 
+> into the same container (or another container) instead of the delegate container.
+
+Exception cases have been allowed to avoid breaking dependencies with some services that must be provided
+by the container (on @njasm proposal). This was proposed here: https://github.com/container-interop/container-interop/pull/20#issuecomment-56597235
+
+### 4.5 Alternative: having one of the containers act as the composite container
+
+In real-life scenarios, we usually have a big framework (Symfony 2, Zend Framework 2, etc...) and we want to
+add another DI container to this container. Most of the time, the "big" framework will be responsible for
+creating the controller's instances, using it's own DI container. Until *container-interop* is fully adopted,
+the "big" framework will not be aware of the existence of a composite container that it should use instead
+of its own container.
+
+For this real-life use cases, @mnapoli and @moufmouf proposed to extend the "big" framework's DI container
+to make it act as a composite container.
+
+This has been discussed [here](https://github.com/container-interop/container-interop/pull/8#issuecomment-40367194) 
+and [here](http://mouf-php.com/container-interop-whats-next#solution4).
+
+This was implemented in Symfony 2 using:
+
+- [interop.symfony.di](https://github.com/thecodingmachine/interop.symfony.di/tree/v0.1.0)
+- [framework interop](https://github.com/mnapoli/framework-interop/)
+
+This was implemented in Silex using:
+
+- [interop.silex.di](https://github.com/thecodingmachine/interop.silex.di)
+
+Having a container act as the composite container is not part of the delegate lookup standard because it is
+simply a temporary design pattern used to make existing frameworks that do not support yet ContainerInterop
+play nice with other DI containers.
+
+
+5. Implementations
+------------------
+
+The following projects already implement the delegate lookup feature:
+
+- [Mouf](http://mouf-php.com), through the [`setDelegateLookupContainer` method](https://github.com/thecodingmachine/mouf/blob/2.0/src/Mouf/MoufManager.php#L2120)
+- [PHP-DI](http://php-di.org/), through the [`$wrapperContainer` parameter of the constructor](https://github.com/mnapoli/PHP-DI/blob/master/src/DI/Container.php#L72)
+- [pimple-interop](https://github.com/moufmouf/pimple-interop), through the [`$container` parameter of the constructor](https://github.com/moufmouf/pimple-interop/blob/master/src/Interop/Container/Pimple/PimpleInterop.php#L62)
+
+6. People
+---------
+
+Are listed here all people that contributed in the discussions, by alphabetical order:
+
+- [Alexandru Pătrănescu](https://github.com/drealecs)
+- [Ben Peachey](https://github.com/potherca)
+- [David Négrier](https://github.com/moufmouf)
+- [Jeremy Lindblom](https://github.com/jeremeamia)
+- [Marco Pivetta](https://github.com/Ocramius)
+- [Matthieu Napoli](https://github.com/mnapoli)
+- [Nelson J Morais](https://github.com/njasm)
+- [Phil Sturgeon](https://github.com/philsturgeon)
+- [Stephan Hochdörfer](https://github.com/shochdoerfer)
+
+7. Relevant Links
+-----------------
+
+_**Note:** Order descending chronologically._
+
+- [Pull request on the delegate lookup feature](https://github.com/container-interop/container-interop/pull/20)
+- [Pull request on the interface idea](https://github.com/container-interop/container-interop/pull/8)
+- [Original article exposing the delegate lookup idea along many others](http://mouf-php.com/container-interop-whats-next)
+
diff --git a/vendor/container-interop/container-interop/docs/Delegate-lookup.md b/vendor/container-interop/container-interop/docs/Delegate-lookup.md
new file mode 100644
index 0000000..f64a8f7
--- /dev/null
+++ b/vendor/container-interop/container-interop/docs/Delegate-lookup.md
@@ -0,0 +1,60 @@
+Delegate lookup feature
+=======================
+
+This document describes a standard for dependency injection containers.
+
+The goal set by the *delegate lookup* feature is to allow several containers to share entries.
+Containers implementing this feature can perform dependency lookups in other containers.
+
+Containers implementing this feature will offer a greater lever of interoperability
+with other containers. Implementation of this feature is therefore RECOMMENDED.
+
+The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
+"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
+interpreted as described in [RFC 2119][].
+
+The word `implementor` in this document is to be interpreted as someone
+implementing the delegate lookup feature in a dependency injection-related library or framework.
+Users of dependency injections containers (DIC) are referred to as `user`.
+
+[RFC 2119]: http://tools.ietf.org/html/rfc2119
+
+1. Vocabulary
+-------------
+
+In a dependency injection container, the container is used to fetch entries.
+Entries can have dependencies on other entries. Usually, these other entries are fetched by the container.
+
+The *delegate lookup* feature is the ability for a container to fetch dependencies in
+another container. In the rest of the document, the word "container" will reference the container
+implemented by the implementor. The word "delegate container" will reference the container we are
+fetching the dependencies from.
+
+2. Specification
+----------------
+
+A container implementing the *delegate lookup* feature:
+
+- MUST implement the [`ContainerInterface`](ContainerInterface.md)
+- MUST provide a way to register a delegate container (using a constructor parameter, or a setter,
+  or any possible way). The delegate container MUST implement the [`ContainerInterface`](ContainerInterface.md).
+
+When a container is configured to use a delegate container for dependencies:
+
+- Calls to the `get` method should only return an entry if the entry is part of the container.
+  If the entry is not part of the container, an exception should be thrown
+  (as requested by the [`ContainerInterface`](ContainerInterface.md)).
+- Calls to the `has` method should only return `true` if the entry is part of the container.
+  If the entry is not part of the container, `false` should be returned.
+- If the fetched entry has dependencies, **instead** of performing
+  the dependency lookup in the container, the lookup is performed on the *delegate container*.
+
+Important: By default, the dependency lookups SHOULD be performed on the delegate container **only**, not on the container itself.
+
+It is however allowed for containers to provide exception cases for special entries, and a way to lookup
+into the same container (or another container) instead of the delegate container.
+
+3. Package / Interface
+----------------------
+
+This feature is not tied to any code, interface or package.
diff --git a/vendor/container-interop/container-interop/docs/images/interoperating_containers.png b/vendor/container-interop/container-interop/docs/images/interoperating_containers.png
new file mode 100644
index 0000000..1d3fdd0
Binary files /dev/null and b/vendor/container-interop/container-interop/docs/images/interoperating_containers.png differ
diff --git a/vendor/container-interop/container-interop/docs/images/priority.png b/vendor/container-interop/container-interop/docs/images/priority.png
new file mode 100644
index 0000000..d02cb7d
Binary files /dev/null and b/vendor/container-interop/container-interop/docs/images/priority.png differ
diff --git a/vendor/container-interop/container-interop/docs/images/side_by_side_containers.png b/vendor/container-interop/container-interop/docs/images/side_by_side_containers.png
new file mode 100644
index 0000000..87884bc
Binary files /dev/null and b/vendor/container-interop/container-interop/docs/images/side_by_side_containers.png differ
diff --git a/vendor/container-interop/container-interop/src/Interop/Container/ContainerInterface.php b/vendor/container-interop/container-interop/src/Interop/Container/ContainerInterface.php
new file mode 100644
index 0000000..a75468f
--- /dev/null
+++ b/vendor/container-interop/container-interop/src/Interop/Container/ContainerInterface.php
@@ -0,0 +1,15 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Interop\Container;
+
+use Psr\Container\ContainerInterface as PsrContainerInterface;
+
+/**
+ * Describes the interface of a container that exposes methods to read its entries.
+ */
+interface ContainerInterface extends PsrContainerInterface
+{
+}
diff --git a/vendor/container-interop/container-interop/src/Interop/Container/Exception/ContainerException.php b/vendor/container-interop/container-interop/src/Interop/Container/Exception/ContainerException.php
new file mode 100644
index 0000000..3964061
--- /dev/null
+++ b/vendor/container-interop/container-interop/src/Interop/Container/Exception/ContainerException.php
@@ -0,0 +1,15 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Interop\Container\Exception;
+
+use Psr\Container\ContainerExceptionInterface as PsrContainerException;
+
+/**
+ * Base interface representing a generic exception in a container.
+ */
+interface ContainerException extends PsrContainerException
+{
+}
diff --git a/vendor/container-interop/container-interop/src/Interop/Container/Exception/NotFoundException.php b/vendor/container-interop/container-interop/src/Interop/Container/Exception/NotFoundException.php
new file mode 100644
index 0000000..031b3ab
--- /dev/null
+++ b/vendor/container-interop/container-interop/src/Interop/Container/Exception/NotFoundException.php
@@ -0,0 +1,15 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Interop\Container\Exception;
+
+use Psr\Container\NotFoundExceptionInterface as PsrNotFoundException;
+
+/**
+ * No entry was found in the container.
+ */
+interface NotFoundException extends ContainerException, PsrNotFoundException
+{
+}
diff --git a/vendor/nikic/fast-route/.gitignore b/vendor/nikic/fast-route/.gitignore
new file mode 100644
index 0000000..e378a07
--- /dev/null
+++ b/vendor/nikic/fast-route/.gitignore
@@ -0,0 +1,5 @@
+/vendor/
+.idea/
+
+# ignore lock file since we have no extra dependencies
+composer.lock
diff --git a/vendor/nikic/fast-route/.hhconfig b/vendor/nikic/fast-route/.hhconfig
new file mode 100644
index 0000000..0c2153c
--- /dev/null
+++ b/vendor/nikic/fast-route/.hhconfig
@@ -0,0 +1 @@
+assume_php=false
diff --git a/vendor/nikic/fast-route/.travis.yml b/vendor/nikic/fast-route/.travis.yml
new file mode 100644
index 0000000..e16ed63
--- /dev/null
+++ b/vendor/nikic/fast-route/.travis.yml
@@ -0,0 +1,12 @@
+language: php
+
+php:
+  - 5.4
+  - 5.5
+  - 5.6
+  - 7.0
+  - hhvm
+
+matrix:
+  allow_failures:
+    - php: 7.0
diff --git a/vendor/nikic/fast-route/FastRoute.hhi b/vendor/nikic/fast-route/FastRoute.hhi
new file mode 100644
index 0000000..c34bb8e
--- /dev/null
+++ b/vendor/nikic/fast-route/FastRoute.hhi
@@ -0,0 +1,126 @@
+<?hh // decl
+
+namespace FastRoute {
+    class BadRouteException extends \LogicException {
+    }
+
+    interface RouteParser {
+        public function parse(string $route): array<array>;
+    }
+
+    class RouteCollector {
+        public function __construct(RouteParser $routeParser, DataGenerator $dataGenerator);
+        public function addRoute(mixed $httpMethod, string $route, mixed $handler): void;
+        public function getData(): array;
+    }
+
+    class Route {
+        public function __construct(string $httpMethod, mixed $handler, string $regex, array $variables);
+        public function matches(string $str): bool;
+    }
+
+    interface DataGenerator {
+        public function addRoute(string $httpMethod, array $routeData, mixed $handler);
+        public function getData(): array;
+    }
+
+    interface Dispatcher {
+        const int NOT_FOUND = 0;
+        const int FOUND = 1;
+        const int METHOD_NOT_ALLOWED = 2;
+        public function dispatch(string $httpMethod, string $uri): array;
+    }
+
+    function simpleDispatcher(
+        (function(RouteCollector): void) $routeDefinitionCallback,
+        shape(
+          'routeParser' => ?classname<RouteParser>,
+          'dataGenerator' => ?classname<DataGenerator>,
+          'dispatcher' => ?classname<Dispatcher>,
+          'routeCollector' => ?classname<RouteCollector>,
+        ) $options = shape()): Dispatcher;
+
+    function cachedDispatcher(
+        (function(RouteCollector): void) $routeDefinitionCallback,
+        shape(
+          'routeParser' => ?classname<RouteParser>,
+          'dataGenerator' => ?classname<DataGenerator>,
+          'dispatcher' => ?classname<Dispatcher>,
+          'routeCollector' => ?classname<RouteCollector>,
+          'cacheDisabled' => ?bool,
+          'cacheFile' => ?string,
+        ) $options = shape()): Dispatcher;
+}
+
+namespace FastRoute\DataGenerator {
+    abstract class RegexBasedAbstract implements \FastRoute\DataGenerator {
+        protected abstract function getApproxChunkSize();
+        protected abstract function processChunk($regexToRoutesMap);
+
+        public function addRoute(string $httpMethod, array $routeData, mixed $handler): void;
+        public function getData(): array;
+    }
+
+    class CharCountBased extends RegexBasedAbstract {
+        protected function getApproxChunkSize(): int;
+        protected function processChunk(array<string, string> $regexToRoutesMap): array<string, mixed>;
+    }
+
+    class GroupCountBased extends RegexBasedAbstract {
+        protected function getApproxChunkSize(): int;
+        protected function processChunk(array<string, string> $regexToRoutesMap): array<string, mixed>;
+    }
+
+    class GroupPosBased extends RegexBasedAbstract {
+        protected function getApproxChunkSize(): int;
+        protected function processChunk(array<string, string> $regexToRoutesMap): array<string, mixed>;
+    }
+
+    class MarkBased extends RegexBasedAbstract {
+        protected function getApproxChunkSize(): int;
+        protected function processChunk(array<string, string> $regexToRoutesMap): array<string, mixed>;
+    }
+}
+
+namespace FastRoute\Dispatcher {
+    abstract class RegexBasedAbstract implements \FastRoute\Dispatcher {
+        protected abstract function dispatchVariableRoute(array<array> $routeData, string $uri): array;
+
+        public function dispatch(string $httpMethod, string $uri): array;
+    }
+
+    class GroupPosBased extends RegexBasedAbstract {
+        public function __construct(array $data);
+        protected function dispatchVariableRoute(array<array> $routeData, string $uri): array;
+    }
+
+    class GroupCountBased extends RegexBasedAbstract {
+        public function __construct(array $data);
+        protected function dispatchVariableRoute(array<array> $routeData, string $uri): array;
+    }
+
+    class CharCountBased extends RegexBasedAbstract {
+        public function __construct(array $data);
+        protected function dispatchVariableRoute(array<array> $routeData, string $uri): array;
+    }
+
+    class MarkBased extends RegexBasedAbstract {
+        public function __construct(array $data);
+        protected function dispatchVariableRoute(array<array> $routeData, string $uri): array;
+    }
+}
+
+namespace FastRoute\RouteParser {
+    class Std implements \FastRoute\RouteParser {
+        const string VARIABLE_REGEX = <<<'REGEX'
+\{
+    \s* ([a-zA-Z][a-zA-Z0-9_]*) \s*
+    (?:
+        : \s* ([^{}]*(?:\{(?-1)\}[^{}]*)*)
+    )?
+\}
+REGEX;
+        const string DEFAULT_DISPATCH_REGEX = '[^/]+';
+        public function parse(string $route): array<array>;
+    }
+}
diff --git a/vendor/nikic/fast-route/LICENSE b/vendor/nikic/fast-route/LICENSE
new file mode 100644
index 0000000..478e764
--- /dev/null
+++ b/vendor/nikic/fast-route/LICENSE
@@ -0,0 +1,31 @@
+Copyright (c) 2013 by Nikita Popov.
+
+Some rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+
+    * The names of the contributors may not be used to endorse or
+      promote products derived from this software without specific
+      prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/vendor/nikic/fast-route/README.md b/vendor/nikic/fast-route/README.md
new file mode 100644
index 0000000..91bd466
--- /dev/null
+++ b/vendor/nikic/fast-route/README.md
@@ -0,0 +1,313 @@
+FastRoute - Fast request router for PHP
+=======================================
+
+This library provides a fast implementation of a regular expression based router. [Blog post explaining how the
+implementation works and why it is fast.][blog_post]
+
+Install
+-------
+
+To install with composer:
+
+```sh
+composer require nikic/fast-route
+```
+
+Requires PHP 5.4 or newer.
+
+Usage
+-----
+
+Here's a basic usage example:
+
+```php
+<?php
+
+require '/path/to/vendor/autoload.php';
+
+$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) {
+    $r->addRoute('GET', '/users', 'get_all_users_handler');
+    // {id} must be a number (\d+)
+    $r->addRoute('GET', '/user/{id:\d+}', 'get_user_handler');
+    // The /{title} suffix is optional
+    $r->addRoute('GET', '/articles/{id:\d+}[/{title}]', 'get_article_handler');
+});
+
+// Fetch method and URI from somewhere
+$httpMethod = $_SERVER['REQUEST_METHOD'];
+$uri = $_SERVER['REQUEST_URI'];
+
+// Strip query string (?foo=bar) and decode URI
+if (false !== $pos = strpos($uri, '?')) {
+    $uri = substr($uri, 0, $pos);
+}
+$uri = rawurldecode($uri);
+
+$routeInfo = $dispatcher->dispatch($httpMethod, $uri);
+switch ($routeInfo[0]) {
+    case FastRoute\Dispatcher::NOT_FOUND:
+        // ... 404 Not Found
+        break;
+    case FastRoute\Dispatcher::METHOD_NOT_ALLOWED:
+        $allowedMethods = $routeInfo[1];
+        // ... 405 Method Not Allowed
+        break;
+    case FastRoute\Dispatcher::FOUND:
+        $handler = $routeInfo[1];
+        $vars = $routeInfo[2];
+        // ... call $handler with $vars
+        break;
+}
+```
+
+### Defining routes
+
+The routes are defined by calling the `FastRoute\simpleDispatcher()` function, which accepts
+a callable taking a `FastRoute\RouteCollector` instance. The routes are added by calling
+`addRoute()` on the collector instance:
+
+```php
+$r->addRoute($method, $routePattern, $handler);
+```
+
+The `$method` is an uppercase HTTP method string for which a certain route should match. It
+is possible to specify multiple valid methods using an array:
+
+```php
+// These two calls
+$r->addRoute('GET', '/test', 'handler');
+$r->addRoute('POST', '/test', 'handler');
+// Are equivalent to this one call
+$r->addRoute(['GET', 'POST'], '/test', 'handler');
+```
+
+By default the `$routePattern` uses a syntax where `{foo}` specifies a placeholder with name `foo`
+and matching the regex `[^/]+`. To adjust the pattern the placeholder matches, you can specify
+a custom pattern by writing `{bar:[0-9]+}`. Some examples:
+
+```php
+// Matches /user/42, but not /user/xyz
+$r->addRoute('GET', '/user/{id:\d+}', 'handler');
+
+// Matches /user/foobar, but not /user/foo/bar
+$r->addRoute('GET', '/user/{name}', 'handler');
+
+// Matches /user/foo/bar as well
+$r->addRoute('GET', '/user/{name:.+}', 'handler');
+```
+
+Custom patterns for route placeholders cannot use capturing groups. For example `{lang:(en|de)}`
+is not a valid placeholder, because `()` is a capturing group. Instead you can use either
+`{lang:en|de}` or `{lang:(?:en|de)}`.
+
+Furthermore parts of the route enclosed in `[...]` are considered optional, so that `/foo[bar]`
+will match both `/foo` and `/foobar`. Optional parts are only supported in a trailing position,
+not in the middle of a route.
+
+```php
+// This route
+$r->addRoute('GET', '/user/{id:\d+}[/{name}]', 'handler');
+// Is equivalent to these two routes
+$r->addRoute('GET', '/user/{id:\d+}', 'handler');
+$r->addRoute('GET', '/user/{id:\d+}/{name}', 'handler');
+
+// Multiple nested optional parts are possible as well
+$r->addRoute('GET', '/user[/{id:\d+}[/{name}]]', 'handler');
+
+// This route is NOT valid, because optional parts can only occur at the end
+$r->addRoute('GET', '/user[/{id:\d+}]/{name}', 'handler');
+```
+
+The `$handler` parameter does not necessarily have to be a callback, it could also be a controller
+class name or any other kind of data you wish to associate with the route. FastRoute only tells you
+which handler corresponds to your URI, how you interpret it is up to you.
+
+#### Shorcut methods for common request methods
+
+For the `GET`, `POST`, `PUT`, `PATCH`, `DELETE` and `HEAD` request methods shortcut methods are available. For example:
+
+```php
+$r->get('/get-route', 'get_handler');
+$r->post('/post-route', 'post_handler');
+```
+
+Is equivalent to:
+
+```php
+$r->addRoute('GET', '/get-route', 'get_handler');
+$r->addRoute('POST', '/post-route', 'post_handler');
+```
+
+#### Route Groups
+
+Additionally, you can specify routes inside of a group. All routes defined inside a group will have a common prefix.
+
+For example, defining your routes as:
+
+```php
+$r->addGroup('/admin', function (RouteCollector $r) {
+    $r->addRoute('GET', '/do-something', 'handler');
+    $r->addRoute('GET', '/do-another-thing', 'handler');
+    $r->addRoute('GET', '/do-something-else', 'handler');
+});
+```
+
+Will have the same result as:
+
+ ```php
+$r->addRoute('GET', '/admin/do-something', 'handler');
+$r->addRoute('GET', '/admin/do-another-thing', 'handler');
+$r->addRoute('GET', '/admin/do-something-else', 'handler');
+ ```
+
+Nested groups are also supported, in which case the prefixes of all the nested groups are combined.
+
+### Caching
+
+The reason `simpleDispatcher` accepts a callback for defining the routes is to allow seamless
+caching. By using `cachedDispatcher` instead of `simpleDispatcher` you can cache the generated
+routing data and construct the dispatcher from the cached information:
+
+```php
+<?php
+
+$dispatcher = FastRoute\cachedDispatcher(function(FastRoute\RouteCollector $r) {
+    $r->addRoute('GET', '/user/{name}/{id:[0-9]+}', 'handler0');
+    $r->addRoute('GET', '/user/{id:[0-9]+}', 'handler1');
+    $r->addRoute('GET', '/user/{name}', 'handler2');
+}, [
+    'cacheFile' => __DIR__ . '/route.cache', /* required */
+    'cacheDisabled' => IS_DEBUG_ENABLED,     /* optional, enabled by default */
+]);
+```
+
+The second parameter to the function is an options array, which can be used to specify the cache
+file location, among other things.
+
+### Dispatching a URI
+
+A URI is dispatched by calling the `dispatch()` method of the created dispatcher. This method
+accepts the HTTP method and a URI. Getting those two bits of information (and normalizing them
+appropriately) is your job - this library is not bound to the PHP web SAPIs.
+
+The `dispatch()` method returns an array whose first element contains a status code. It is one
+of `Dispatcher::NOT_FOUND`, `Dispatcher::METHOD_NOT_ALLOWED` and `Dispatcher::FOUND`. For the
+method not allowed status the second array element contains a list of HTTP methods allowed for
+the supplied URI. For example:
+
+    [FastRoute\Dispatcher::METHOD_NOT_ALLOWED, ['GET', 'POST']]
+
+> **NOTE:** The HTTP specification requires that a `405 Method Not Allowed` response include the
+`Allow:` header to detail available methods for the requested resource. Applications using FastRoute
+should use the second array element to add this header when relaying a 405 response.
+
+For the found status the second array element is the handler that was associated with the route
+and the third array element is a dictionary of placeholder names to their values. For example:
+
+    /* Routing against GET /user/nikic/42 */
+
+    [FastRoute\Dispatcher::FOUND, 'handler0', ['name' => 'nikic', 'id' => '42']]
+
+### Overriding the route parser and dispatcher
+
+The routing process makes use of three components: A route parser, a data generator and a
+dispatcher. The three components adhere to the following interfaces:
+
+```php
+<?php
+
+namespace FastRoute;
+
+interface RouteParser {
+    public function parse($route);
+}
+
+interface DataGenerator {
+    public function addRoute($httpMethod, $routeData, $handler);
+    public function getData();
+}
+
+interface Dispatcher {
+    const NOT_FOUND = 0, FOUND = 1, METHOD_NOT_ALLOWED = 2;
+
+    public function dispatch($httpMethod, $uri);
+}
+```
+
+The route parser takes a route pattern string and converts it into an array of route infos, where
+each route info is again an array of it's parts. The structure is best understood using an example:
+
+    /* The route /user/{id:\d+}[/{name}] converts to the following array: */
+    [
+        [
+            '/user/',
+            ['id', '\d+'],
+        ],
+        [
+            '/user/',
+            ['id', '\d+'],
+            '/',
+            ['name', '[^/]+'],
+        ],
+    ]
+
+This array can then be passed to the `addRoute()` method of a data generator. After all routes have
+been added the `getData()` of the generator is invoked, which returns all the routing data required
+by the dispatcher. The format of this data is not further specified - it is tightly coupled to
+the corresponding dispatcher.
+
+The dispatcher accepts the routing data via a constructor and provides a `dispatch()` method, which
+you're already familiar with.
+
+The route parser can be overwritten individually (to make use of some different pattern syntax),
+however the data generator and dispatcher should always be changed as a pair, as the output from
+the former is tightly coupled to the input of the latter. The reason the generator and the
+dispatcher are separate is that only the latter is needed when using caching (as the output of
+the former is what is being cached.)
+
+When using the `simpleDispatcher` / `cachedDispatcher` functions from above the override happens
+through the options array:
+
+```php
+<?php
+
+$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) {
+    /* ... */
+}, [
+    'routeParser' => 'FastRoute\\RouteParser\\Std',
+    'dataGenerator' => 'FastRoute\\DataGenerator\\GroupCountBased',
+    'dispatcher' => 'FastRoute\\Dispatcher\\GroupCountBased',
+]);
+```
+
+The above options array corresponds to the defaults. By replacing `GroupCountBased` by
+`GroupPosBased` you could switch to a different dispatching strategy.
+
+### A Note on HEAD Requests
+
+The HTTP spec requires servers to [support both GET and HEAD methods][2616-511]:
+
+> The methods GET and HEAD MUST be supported by all general-purpose servers
+
+To avoid forcing users to manually register HEAD routes for each resource we fallback to matching an
+available GET route for a given resource. The PHP web SAPI transparently removes the entity body
+from HEAD responses so this behavior has no effect on the vast majority of users.
+
+However, implementers using FastRoute outside the web SAPI environment (e.g. a custom server) MUST
+NOT send entity bodies generated in response to HEAD requests. If you are a non-SAPI user this is
+*your responsibility*; FastRoute has no purview to prevent you from breaking HTTP in such cases.
+
+Finally, note that applications MAY always specify their own HEAD method route for a given
+resource to bypass this behavior entirely.
+
+### Credits
+
+This library is based on a router that [Levi Morrison][levi] implemented for the Aerys server.
+
+A large number of tests, as well as HTTP compliance considerations, were provided by [Daniel Lowrey][rdlowrey].
+
+
+[2616-511]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1 "RFC 2616 Section 5.1.1"
+[blog_post]: http://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html
+[levi]: https://github.com/morrisonlevi
+[rdlowrey]: https://github.com/rdlowrey
diff --git a/vendor/nikic/fast-route/composer.json b/vendor/nikic/fast-route/composer.json
new file mode 100644
index 0000000..62aad22
--- /dev/null
+++ b/vendor/nikic/fast-route/composer.json
@@ -0,0 +1,21 @@
+{
+  "name": "nikic/fast-route",
+  "description": "Fast request router for PHP",
+  "keywords": ["routing", "router"],
+  "license": "BSD-3-Clause",
+  "authors": [
+    {
+      "name": "Nikita Popov",
+      "email": "nikic@php.net"
+    }
+  ],
+  "require": {
+    "php": ">=5.4.0"
+  },
+  "autoload": {
+    "psr-4": {
+      "FastRoute\\": "src/"
+    },
+    "files": ["src/functions.php"]
+  }
+}
diff --git a/vendor/nikic/fast-route/phpunit.xml b/vendor/nikic/fast-route/phpunit.xml
new file mode 100644
index 0000000..3c807b6
--- /dev/null
+++ b/vendor/nikic/fast-route/phpunit.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<phpunit backupGlobals="false"
+         backupStaticAttributes="false"
+         colors="true"
+         convertErrorsToExceptions="true"
+         convertNoticesToExceptions="true"
+         convertWarningsToExceptions="true"
+         processIsolation="false"
+         syntaxCheck="false"
+         bootstrap="test/bootstrap.php"
+        >
+    <testsuites>
+        <testsuite name="FastRoute Tests">
+            <directory>./test/</directory>
+        </testsuite>
+    </testsuites>
+
+    <filter>
+        <whitelist>
+            <directory>./src/</directory>
+        </whitelist>
+    </filter>
+</phpunit>
diff --git a/vendor/nikic/fast-route/src/BadRouteException.php b/vendor/nikic/fast-route/src/BadRouteException.php
new file mode 100644
index 0000000..7e38479
--- /dev/null
+++ b/vendor/nikic/fast-route/src/BadRouteException.php
@@ -0,0 +1,6 @@
+<?php
+
+namespace FastRoute;
+
+class BadRouteException extends \LogicException {
+}
diff --git a/vendor/nikic/fast-route/src/DataGenerator.php b/vendor/nikic/fast-route/src/DataGenerator.php
new file mode 100644
index 0000000..16053db
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace FastRoute;
+
+interface DataGenerator {
+    /**
+     * Adds a route to the data generator. The route data uses the
+     * same format that is returned by RouterParser::parser().
+     *
+     * The handler doesn't necessarily need to be a callable, it
+     * can be arbitrary data that will be returned when the route
+     * matches.
+     *
+     * @param string $httpMethod
+     * @param array $routeData
+     * @param mixed $handler
+     */
+    public function addRoute($httpMethod, $routeData, $handler);
+
+    /**
+     * Returns dispatcher data in some unspecified format, which
+     * depends on the used method of dispatch.
+     */
+    public function getData();
+}
diff --git a/vendor/nikic/fast-route/src/DataGenerator/CharCountBased.php b/vendor/nikic/fast-route/src/DataGenerator/CharCountBased.php
new file mode 100644
index 0000000..5c38b89
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator/CharCountBased.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace FastRoute\DataGenerator;
+
+class CharCountBased extends RegexBasedAbstract {
+    protected function getApproxChunkSize() {
+        return 30;
+    }
+
+    protected function processChunk($regexToRoutesMap) {
+        $routeMap = [];
+        $regexes = [];
+
+        $suffixLen = 0;
+        $suffix = '';
+        $count = count($regexToRoutesMap);
+        foreach ($regexToRoutesMap as $regex => $route) {
+            $suffixLen++;
+            $suffix .= "\t";
+
+            $regexes[] = '(?:' . $regex . '/(\t{' . $suffixLen . '})\t{' . ($count - $suffixLen) . '})';
+            $routeMap[$suffix] = [$route->handler, $route->variables];
+        }
+
+        $regex = '~^(?|' . implode('|', $regexes) . ')$~';
+        return ['regex' => $regex, 'suffix' => '/' . $suffix, 'routeMap' => $routeMap];
+    }
+}
diff --git a/vendor/nikic/fast-route/src/DataGenerator/GroupCountBased.php b/vendor/nikic/fast-route/src/DataGenerator/GroupCountBased.php
new file mode 100644
index 0000000..d51807f
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator/GroupCountBased.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace FastRoute\DataGenerator;
+
+class GroupCountBased extends RegexBasedAbstract {
+    protected function getApproxChunkSize() {
+        return 10;
+    }
+
+    protected function processChunk($regexToRoutesMap) {
+        $routeMap = [];
+        $regexes = [];
+        $numGroups = 0;
+        foreach ($regexToRoutesMap as $regex => $route) {
+            $numVariables = count($route->variables);
+            $numGroups = max($numGroups, $numVariables);
+
+            $regexes[] = $regex . str_repeat('()', $numGroups - $numVariables);
+            $routeMap[$numGroups + 1] = [$route->handler, $route->variables];
+
+            ++$numGroups;
+        }
+
+        $regex = '~^(?|' . implode('|', $regexes) . ')$~';
+        return ['regex' => $regex, 'routeMap' => $routeMap];
+    }
+}
+
diff --git a/vendor/nikic/fast-route/src/DataGenerator/GroupPosBased.php b/vendor/nikic/fast-route/src/DataGenerator/GroupPosBased.php
new file mode 100644
index 0000000..4152f7a
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator/GroupPosBased.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace FastRoute\DataGenerator;
+
+class GroupPosBased extends RegexBasedAbstract {
+    protected function getApproxChunkSize() {
+        return 10;
+    }
+
+    protected function processChunk($regexToRoutesMap) {
+        $routeMap = [];
+        $regexes = [];
+        $offset = 1;
+        foreach ($regexToRoutesMap as $regex => $route) {
+            $regexes[] = $regex;
+            $routeMap[$offset] = [$route->handler, $route->variables];
+
+            $offset += count($route->variables);
+        }
+
+        $regex = '~^(?:' . implode('|', $regexes) . ')$~';
+        return ['regex' => $regex, 'routeMap' => $routeMap];
+    }
+}
+
diff --git a/vendor/nikic/fast-route/src/DataGenerator/MarkBased.php b/vendor/nikic/fast-route/src/DataGenerator/MarkBased.php
new file mode 100644
index 0000000..61359f5
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator/MarkBased.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace FastRoute\DataGenerator;
+
+class MarkBased extends RegexBasedAbstract {
+    protected function getApproxChunkSize() {
+        return 30;
+    }
+
+    protected function processChunk($regexToRoutesMap) {
+        $routeMap = [];
+        $regexes = [];
+        $markName = 'a';
+        foreach ($regexToRoutesMap as $regex => $route) {
+            $regexes[] = $regex . '(*MARK:' . $markName . ')';
+            $routeMap[$markName] = [$route->handler, $route->variables];
+
+            ++$markName;
+        }
+
+        $regex = '~^(?|' . implode('|', $regexes) . ')$~';
+        return ['regex' => $regex, 'routeMap' => $routeMap];
+    }
+}
+
diff --git a/vendor/nikic/fast-route/src/DataGenerator/RegexBasedAbstract.php b/vendor/nikic/fast-route/src/DataGenerator/RegexBasedAbstract.php
new file mode 100644
index 0000000..713d897
--- /dev/null
+++ b/vendor/nikic/fast-route/src/DataGenerator/RegexBasedAbstract.php
@@ -0,0 +1,144 @@
+<?php
+
+namespace FastRoute\DataGenerator;
+
+use FastRoute\DataGenerator;
+use FastRoute\BadRouteException;
+use FastRoute\Route;
+
+abstract class RegexBasedAbstract implements DataGenerator {
+    protected $staticRoutes = [];
+    protected $methodToRegexToRoutesMap = [];
+
+    protected abstract function getApproxChunkSize();
+    protected abstract function processChunk($regexToRoutesMap);
+
+    public function addRoute($httpMethod, $routeData, $handler) {
+        if ($this->isStaticRoute($routeData)) {
+            $this->addStaticRoute($httpMethod, $routeData, $handler);
+        } else {
+            $this->addVariableRoute($httpMethod, $routeData, $handler);
+        }
+    }
+
+    public function getData() {
+        if (empty($this->methodToRegexToRoutesMap)) {
+            return [$this->staticRoutes, []];
+        }
+
+        return [$this->staticRoutes, $this->generateVariableRouteData()];
+    }
+
+    private function generateVariableRouteData() {
+        $data = [];
+        foreach ($this->methodToRegexToRoutesMap as $method => $regexToRoutesMap) {
+            $chunkSize = $this->computeChunkSize(count($regexToRoutesMap));
+            $chunks = array_chunk($regexToRoutesMap, $chunkSize, true);
+            $data[$method] =  array_map([$this, 'processChunk'], $chunks);
+        }
+        return $data;
+    }
+
+    private function computeChunkSize($count) {
+        $numParts = max(1, round($count / $this->getApproxChunkSize()));
+        return ceil($count / $numParts);
+    }
+
+    private function isStaticRoute($routeData) {
+        return count($routeData) === 1 && is_string($routeData[0]);
+    }
+
+    private function addStaticRoute($httpMethod, $routeData, $handler) {
+        $routeStr = $routeData[0];
+
+        if (isset($this->staticRoutes[$httpMethod][$routeStr])) {
+            throw new BadRouteException(sprintf(
+                'Cannot register two routes matching "%s" for method "%s"',
+                $routeStr, $httpMethod
+            ));
+        }
+
+        if (isset($this->methodToRegexToRoutesMap[$httpMethod])) {
+            foreach ($this->methodToRegexToRoutesMap[$httpMethod] as $route) {
+                if ($route->matches($routeStr)) {
+                    throw new BadRouteException(sprintf(
+                        'Static route "%s" is shadowed by previously defined variable route "%s" for method "%s"',
+                        $routeStr, $route->regex, $httpMethod
+                    ));
+                }
+            }
+        }
+
+        $this->staticRoutes[$httpMethod][$routeStr] = $handler;
+    }
+
+    private function addVariableRoute($httpMethod, $routeData, $handler) {
+        list($regex, $variables) = $this->buildRegexForRoute($routeData);
+
+        if (isset($this->methodToRegexToRoutesMap[$httpMethod][$regex])) {
+            throw new BadRouteException(sprintf(
+                'Cannot register two routes matching "%s" for method "%s"',
+                $regex, $httpMethod
+            ));
+        }
+
+        $this->methodToRegexToRoutesMap[$httpMethod][$regex] = new Route(
+            $httpMethod, $handler, $regex, $variables
+        );
+    }
+
+    private function buildRegexForRoute($routeData) {
+        $regex = '';
+        $variables = [];
+        foreach ($routeData as $part) {
+            if (is_string($part)) {
+                $regex .= preg_quote($part, '~');
+                continue;
+            }
+
+            list($varName, $regexPart) = $part;
+
+            if (isset($variables[$varName])) {
+                throw new BadRouteException(sprintf(
+                    'Cannot use the same placeholder "%s" twice', $varName
+                ));
+            }
+
+            if ($this->regexHasCapturingGroups($regexPart)) {
+                throw new BadRouteException(sprintf(
+                    'Regex "%s" for parameter "%s" contains a capturing group',
+                    $regexPart, $varName
+                ));
+            }
+
+            $variables[$varName] = $varName;
+            $regex .= '(' . $regexPart . ')';
+        }
+
+        return [$regex, $variables];
+    }
+
+    private function regexHasCapturingGroups($regex) {
+        if (false === strpos($regex, '(')) {
+            // Needs to have at least a ( to contain a capturing group
+            return false;
+        }
+
+        // Semi-accurate detection for capturing groups
+        return preg_match(
+            '~
+                (?:
+                    \(\?\(
+                  | \[ [^\]\\\\]* (?: \\\\ . [^\]\\\\]* )* \]
+                  | \\\\ .
+                ) (*SKIP)(*FAIL) |
+                \(
+                (?!
+                    \? (?! <(?![!=]) | P< | \' )
+                  | \*
+                )
+            ~x',
+            $regex
+        );
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher.php b/vendor/nikic/fast-route/src/Dispatcher.php
new file mode 100644
index 0000000..ea98009
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace FastRoute;
+
+interface Dispatcher {
+    const NOT_FOUND = 0;
+    const FOUND = 1;
+    const METHOD_NOT_ALLOWED = 2;
+
+    /**
+     * Dispatches against the provided HTTP method verb and URI.
+     *
+     * Returns array with one of the following formats:
+     *
+     *     [self::NOT_FOUND]
+     *     [self::METHOD_NOT_ALLOWED, ['GET', 'OTHER_ALLOWED_METHODS']]
+     *     [self::FOUND, $handler, ['varName' => 'value', ...]]
+     *
+     * @param string $httpMethod
+     * @param string $uri
+     *
+     * @return array
+     */
+    public function dispatch($httpMethod, $uri);
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher/CharCountBased.php b/vendor/nikic/fast-route/src/Dispatcher/CharCountBased.php
new file mode 100644
index 0000000..22ba240
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher/CharCountBased.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class CharCountBased extends RegexBasedAbstract {
+    public function __construct($data) {
+        list($this->staticRouteMap, $this->variableRouteData) = $data;
+    }
+
+    protected function dispatchVariableRoute($routeData, $uri) {
+        foreach ($routeData as $data) {
+            if (!preg_match($data['regex'], $uri . $data['suffix'], $matches)) {
+                continue;
+            }
+
+            list($handler, $varNames) = $data['routeMap'][end($matches)];
+
+            $vars = [];
+            $i = 0;
+            foreach ($varNames as $varName) {
+                $vars[$varName] = $matches[++$i];
+            }
+            return [self::FOUND, $handler, $vars];
+        }
+
+        return [self::NOT_FOUND];
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher/GroupCountBased.php b/vendor/nikic/fast-route/src/Dispatcher/GroupCountBased.php
new file mode 100644
index 0000000..0abd322
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher/GroupCountBased.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class GroupCountBased extends RegexBasedAbstract {
+    public function __construct($data) {
+        list($this->staticRouteMap, $this->variableRouteData) = $data;
+    }
+
+    protected function dispatchVariableRoute($routeData, $uri) {
+        foreach ($routeData as $data) {
+            if (!preg_match($data['regex'], $uri, $matches)) {
+                continue;
+            }
+
+            list($handler, $varNames) = $data['routeMap'][count($matches)];
+
+            $vars = [];
+            $i = 0;
+            foreach ($varNames as $varName) {
+                $vars[$varName] = $matches[++$i];
+            }
+            return [self::FOUND, $handler, $vars];
+        }
+
+        return [self::NOT_FOUND];
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher/GroupPosBased.php b/vendor/nikic/fast-route/src/Dispatcher/GroupPosBased.php
new file mode 100644
index 0000000..32227d4
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher/GroupPosBased.php
@@ -0,0 +1,30 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class GroupPosBased extends RegexBasedAbstract {
+    public function __construct($data) {
+        list($this->staticRouteMap, $this->variableRouteData) = $data;
+    }
+
+    protected function dispatchVariableRoute($routeData, $uri) {
+        foreach ($routeData as $data) {
+            if (!preg_match($data['regex'], $uri, $matches)) {
+                continue;
+            }
+
+            // find first non-empty match
+            for ($i = 1; '' === $matches[$i]; ++$i);
+
+            list($handler, $varNames) = $data['routeMap'][$i];
+
+            $vars = [];
+            foreach ($varNames as $varName) {
+                $vars[$varName] = $matches[$i++];
+            }
+            return [self::FOUND, $handler, $vars];
+        }
+
+        return [self::NOT_FOUND];
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher/MarkBased.php b/vendor/nikic/fast-route/src/Dispatcher/MarkBased.php
new file mode 100644
index 0000000..fefa711
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher/MarkBased.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class MarkBased extends RegexBasedAbstract {
+    public function __construct($data) {
+        list($this->staticRouteMap, $this->variableRouteData) = $data;
+    }
+
+    protected function dispatchVariableRoute($routeData, $uri) {
+        foreach ($routeData as $data) {
+            if (!preg_match($data['regex'], $uri, $matches)) {
+                continue;
+            }
+
+            list($handler, $varNames) = $data['routeMap'][$matches['MARK']];
+
+            $vars = [];
+            $i = 0;
+            foreach ($varNames as $varName) {
+                $vars[$varName] = $matches[++$i];
+            }
+            return [self::FOUND, $handler, $vars];
+        }
+
+        return [self::NOT_FOUND];
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Dispatcher/RegexBasedAbstract.php b/vendor/nikic/fast-route/src/Dispatcher/RegexBasedAbstract.php
new file mode 100644
index 0000000..8823b9b
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Dispatcher/RegexBasedAbstract.php
@@ -0,0 +1,80 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+use FastRoute\Dispatcher;
+
+abstract class RegexBasedAbstract implements Dispatcher {
+    protected $staticRouteMap;
+    protected $variableRouteData;
+
+    protected abstract function dispatchVariableRoute($routeData, $uri);
+
+    public function dispatch($httpMethod, $uri) {
+        if (isset($this->staticRouteMap[$httpMethod][$uri])) {
+            $handler = $this->staticRouteMap[$httpMethod][$uri];
+            return [self::FOUND, $handler, []];
+        }
+
+        $varRouteData = $this->variableRouteData;
+        if (isset($varRouteData[$httpMethod])) {
+            $result = $this->dispatchVariableRoute($varRouteData[$httpMethod], $uri);
+            if ($result[0] === self::FOUND) {
+                return $result;
+            }
+        }
+
+        // For HEAD requests, attempt fallback to GET
+        if ($httpMethod === 'HEAD') {
+            if (isset($this->staticRouteMap['GET'][$uri])) {
+                $handler = $this->staticRouteMap['GET'][$uri];
+                return [self::FOUND, $handler, []];
+            }
+            if (isset($varRouteData['GET'])) {
+                $result = $this->dispatchVariableRoute($varRouteData['GET'], $uri);
+                if ($result[0] === self::FOUND) {
+                    return $result;
+                }
+            }
+        }
+
+        // If nothing else matches, try fallback routes
+        if (isset($this->staticRouteMap['*'][$uri])) {
+            $handler = $this->staticRouteMap['*'][$uri];
+            return [self::FOUND, $handler, []];
+        }
+        if (isset($varRouteData['*'])) {
+            $result = $this->dispatchVariableRoute($varRouteData['*'], $uri);
+            if ($result[0] === self::FOUND) {
+                return $result;
+            }
+        }
+
+        // Find allowed methods for this URI by matching against all other HTTP methods as well
+        $allowedMethods = [];
+
+        foreach ($this->staticRouteMap as $method => $uriMap) {
+            if ($method !== $httpMethod && isset($uriMap[$uri])) {
+                $allowedMethods[] = $method;
+            }
+        }
+
+        foreach ($varRouteData as $method => $routeData) {
+            if ($method === $httpMethod) {
+                continue;
+            }
+
+            $result = $this->dispatchVariableRoute($routeData, $uri);
+            if ($result[0] === self::FOUND) {
+                $allowedMethods[] = $method;
+            }
+        }
+
+        // If there are no allowed methods the route simply does not exist
+        if ($allowedMethods) {
+            return [self::METHOD_NOT_ALLOWED, $allowedMethods];
+        } else {
+            return [self::NOT_FOUND];
+        }
+    }
+}
diff --git a/vendor/nikic/fast-route/src/Route.php b/vendor/nikic/fast-route/src/Route.php
new file mode 100644
index 0000000..d71ded1
--- /dev/null
+++ b/vendor/nikic/fast-route/src/Route.php
@@ -0,0 +1,38 @@
+<?php
+
+namespace FastRoute;
+
+class Route {
+    public $httpMethod;
+    public $regex;
+    public $variables;
+    public $handler;
+
+    /**
+     * Constructs a route (value object).
+     *
+     * @param string $httpMethod
+     * @param mixed  $handler
+     * @param string $regex
+     * @param array  $variables
+     */
+    public function __construct($httpMethod, $handler, $regex, $variables) {
+        $this->httpMethod = $httpMethod;
+        $this->handler = $handler;
+        $this->regex = $regex;
+        $this->variables = $variables;
+    }
+
+    /**
+     * Tests whether this route matches the given string.
+     *
+     * @param string $str
+     *
+     * @return bool
+     */
+    public function matches($str) {
+        $regex = '~^' . $this->regex . '$~';
+        return (bool) preg_match($regex, $str);
+    }
+}
+
diff --git a/vendor/nikic/fast-route/src/RouteCollector.php b/vendor/nikic/fast-route/src/RouteCollector.php
new file mode 100644
index 0000000..7d7667b
--- /dev/null
+++ b/vendor/nikic/fast-route/src/RouteCollector.php
@@ -0,0 +1,136 @@
+<?php
+
+namespace FastRoute;
+
+class RouteCollector {
+    protected $routeParser;
+    protected $dataGenerator;
+    protected $currentGroupPrefix;
+
+    /**
+     * Constructs a route collector.
+     *
+     * @param RouteParser   $routeParser
+     * @param DataGenerator $dataGenerator
+     */
+    public function __construct(RouteParser $routeParser, DataGenerator $dataGenerator) {
+        $this->routeParser = $routeParser;
+        $this->dataGenerator = $dataGenerator;
+        $this->currentGroupPrefix = '';
+    }
+
+    /**
+     * Adds a route to the collection.
+     *
+     * The syntax used in the $route string depends on the used route parser.
+     *
+     * @param string|string[] $httpMethod
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function addRoute($httpMethod, $route, $handler) {
+        $route = $this->currentGroupPrefix . $route;
+        $routeDatas = $this->routeParser->parse($route);
+        foreach ((array) $httpMethod as $method) {
+            foreach ($routeDatas as $routeData) {
+                $this->dataGenerator->addRoute($method, $routeData, $handler);
+            }
+        }
+    }
+
+    /**
+     * Create a route group with a common prefix.
+     *
+     * All routes created in the passed callback will have the given group prefix prepended.
+     *
+     * @param string $prefix
+     * @param callable $callback
+     */
+    public function addGroup($prefix, callable $callback) {
+        $previousGroupPrefix = $this->currentGroupPrefix;
+        $this->currentGroupPrefix = $previousGroupPrefix . $prefix;
+        $callback($this);
+        $this->currentGroupPrefix = $previousGroupPrefix;
+    }
+    
+    /**
+     * Adds a GET route to the collection
+     * 
+     * This is simply an alias of $this->addRoute('GET', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function get($route, $handler) {
+        $this->addRoute('GET', $route, $handler);
+    }
+    
+    /**
+     * Adds a POST route to the collection
+     * 
+     * This is simply an alias of $this->addRoute('POST', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function post($route, $handler) {
+        $this->addRoute('POST', $route, $handler);
+    }
+    
+    /**
+     * Adds a PUT route to the collection
+     * 
+     * This is simply an alias of $this->addRoute('PUT', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function put($route, $handler) {
+        $this->addRoute('PUT', $route, $handler);
+    }
+    
+    /**
+     * Adds a DELETE route to the collection
+     * 
+     * This is simply an alias of $this->addRoute('DELETE', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function delete($route, $handler) {
+        $this->addRoute('DELETE', $route, $handler);
+    }
+    
+    /**
+     * Adds a PATCH route to the collection
+     * 
+     * This is simply an alias of $this->addRoute('PATCH', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function patch($route, $handler) {
+        $this->addRoute('PATCH', $route, $handler);
+    }
+
+    /**
+     * Adds a HEAD route to the collection
+     *
+     * This is simply an alias of $this->addRoute('HEAD', $route, $handler)
+     *
+     * @param string $route
+     * @param mixed  $handler
+     */
+    public function head($route, $handler) {
+        $this->addRoute('HEAD', $route, $handler);
+    }
+
+    /**
+     * Returns the collected route data, as provided by the data generator.
+     *
+     * @return array
+     */
+    public function getData() {
+        return $this->dataGenerator->getData();
+    }
+}
diff --git a/vendor/nikic/fast-route/src/RouteParser.php b/vendor/nikic/fast-route/src/RouteParser.php
new file mode 100644
index 0000000..c089c31
--- /dev/null
+++ b/vendor/nikic/fast-route/src/RouteParser.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace FastRoute;
+
+interface RouteParser {
+    /**
+     * Parses a route string into multiple route data arrays.
+     *
+     * The expected output is defined using an example:
+     *
+     * For the route string "/fixedRoutePart/{varName}[/moreFixed/{varName2:\d+}]", if {varName} is interpreted as
+     * a placeholder and [...] is interpreted as an optional route part, the expected result is:
+     *
+     * [
+     *     // first route: without optional part
+     *     [
+     *         "/fixedRoutePart/",
+     *         ["varName", "[^/]+"],
+     *     ],
+     *     // second route: with optional part
+     *     [
+     *         "/fixedRoutePart/",
+     *         ["varName", "[^/]+"],
+     *         "/moreFixed/",
+     *         ["varName2", [0-9]+"],
+     *     ],
+     * ]
+     *
+     * Here one route string was converted into two route data arrays.
+     *
+     * @param string $route Route string to parse
+     * 
+     * @return mixed[][] Array of route data arrays
+     */
+    public function parse($route);
+}
diff --git a/vendor/nikic/fast-route/src/RouteParser/Std.php b/vendor/nikic/fast-route/src/RouteParser/Std.php
new file mode 100644
index 0000000..a6c21bd
--- /dev/null
+++ b/vendor/nikic/fast-route/src/RouteParser/Std.php
@@ -0,0 +1,81 @@
+<?php
+
+namespace FastRoute\RouteParser;
+
+use FastRoute\BadRouteException;
+use FastRoute\RouteParser;
+
+/**
+ * Parses route strings of the following form:
+ *
+ * "/user/{name}[/{id:[0-9]+}]"
+ */
+class Std implements RouteParser {
+    const VARIABLE_REGEX = <<<'REGEX'
+\{
+    \s* ([a-zA-Z_][a-zA-Z0-9_-]*) \s*
+    (?:
+        : \s* ([^{}]*(?:\{(?-1)\}[^{}]*)*)
+    )?
+\}
+REGEX;
+    const DEFAULT_DISPATCH_REGEX = '[^/]+';
+
+    public function parse($route) {
+        $routeWithoutClosingOptionals = rtrim($route, ']');
+        $numOptionals = strlen($route) - strlen($routeWithoutClosingOptionals);
+
+        // Split on [ while skipping placeholders
+        $segments = preg_split('~' . self::VARIABLE_REGEX . '(*SKIP)(*F) | \[~x', $routeWithoutClosingOptionals);
+        if ($numOptionals !== count($segments) - 1) {
+            // If there are any ] in the middle of the route, throw a more specific error message
+            if (preg_match('~' . self::VARIABLE_REGEX . '(*SKIP)(*F) | \]~x', $routeWithoutClosingOptionals)) {
+                throw new BadRouteException("Optional segments can only occur at the end of a route");
+            }
+            throw new BadRouteException("Number of opening '[' and closing ']' does not match");
+        }
+
+        $currentRoute = '';
+        $routeDatas = [];
+        foreach ($segments as $n => $segment) {
+            if ($segment === '' && $n !== 0) {
+                throw new BadRouteException("Empty optional part");
+            }
+
+            $currentRoute .= $segment;
+            $routeDatas[] = $this->parsePlaceholders($currentRoute);
+        }
+        return $routeDatas;
+    }
+
+    /**
+     * Parses a route string that does not contain optional segments.
+     */
+    private function parsePlaceholders($route) {
+        if (!preg_match_all(
+            '~' . self::VARIABLE_REGEX . '~x', $route, $matches,
+            PREG_OFFSET_CAPTURE | PREG_SET_ORDER
+        )) {
+            return [$route];
+        }
+
+        $offset = 0;
+        $routeData = [];
+        foreach ($matches as $set) {
+            if ($set[0][1] > $offset) {
+                $routeData[] = substr($route, $offset, $set[0][1] - $offset);
+            }
+            $routeData[] = [
+                $set[1][0],
+                isset($set[2]) ? trim($set[2][0]) : self::DEFAULT_DISPATCH_REGEX
+            ];
+            $offset = $set[0][1] + strlen($set[0][0]);
+        }
+
+        if ($offset != strlen($route)) {
+            $routeData[] = substr($route, $offset);
+        }
+
+        return $routeData;
+    }
+}
diff --git a/vendor/nikic/fast-route/src/bootstrap.php b/vendor/nikic/fast-route/src/bootstrap.php
new file mode 100644
index 0000000..add216c
--- /dev/null
+++ b/vendor/nikic/fast-route/src/bootstrap.php
@@ -0,0 +1,12 @@
+<?php
+
+namespace FastRoute;
+
+require __DIR__ . '/functions.php';
+
+spl_autoload_register(function($class) {
+    if (strpos($class, 'FastRoute\\') === 0) {
+        $name = substr($class, strlen('FastRoute'));
+        require __DIR__ . strtr($name, '\\', DIRECTORY_SEPARATOR) . '.php';
+    }
+});
diff --git a/vendor/nikic/fast-route/src/functions.php b/vendor/nikic/fast-route/src/functions.php
new file mode 100644
index 0000000..46bc805
--- /dev/null
+++ b/vendor/nikic/fast-route/src/functions.php
@@ -0,0 +1,72 @@
+<?php
+
+namespace FastRoute;
+
+if (!function_exists('FastRoute\simpleDispatcher')) {
+    /**
+     * @param callable $routeDefinitionCallback
+     * @param array $options
+     *
+     * @return Dispatcher
+     */
+    function simpleDispatcher(callable $routeDefinitionCallback, array $options = []) {
+        $options += [
+            'routeParser' => 'FastRoute\\RouteParser\\Std',
+            'dataGenerator' => 'FastRoute\\DataGenerator\\GroupCountBased',
+            'dispatcher' => 'FastRoute\\Dispatcher\\GroupCountBased',
+            'routeCollector' => 'FastRoute\\RouteCollector',
+        ];
+
+        /** @var RouteCollector $routeCollector */
+        $routeCollector = new $options['routeCollector'](
+            new $options['routeParser'], new $options['dataGenerator']
+        );
+        $routeDefinitionCallback($routeCollector);
+
+        return new $options['dispatcher']($routeCollector->getData());
+    }
+
+    /**
+     * @param callable $routeDefinitionCallback
+     * @param array $options
+     *
+     * @return Dispatcher
+     */
+    function cachedDispatcher(callable $routeDefinitionCallback, array $options = []) {
+        $options += [
+            'routeParser' => 'FastRoute\\RouteParser\\Std',
+            'dataGenerator' => 'FastRoute\\DataGenerator\\GroupCountBased',
+            'dispatcher' => 'FastRoute\\Dispatcher\\GroupCountBased',
+            'routeCollector' => 'FastRoute\\RouteCollector',
+            'cacheDisabled' => false,
+        ];
+
+        if (!isset($options['cacheFile'])) {
+            throw new \LogicException('Must specify "cacheFile" option');
+        }
+
+        if (!$options['cacheDisabled'] && file_exists($options['cacheFile'])) {
+            $dispatchData = require $options['cacheFile'];
+            if (!is_array($dispatchData)) {
+                throw new \RuntimeException('Invalid cache file "' . $options['cacheFile'] . '"');
+            }
+            return new $options['dispatcher']($dispatchData);
+        }
+
+        $routeCollector = new $options['routeCollector'](
+            new $options['routeParser'], new $options['dataGenerator']
+        );
+        $routeDefinitionCallback($routeCollector);
+
+        /** @var RouteCollector $routeCollector */
+        $dispatchData = $routeCollector->getData();
+        if (!$options['cacheDisabled']) {
+            file_put_contents(
+                $options['cacheFile'],
+                '<?php return ' . var_export($dispatchData, true) . ';'
+            );
+        }
+
+        return new $options['dispatcher']($dispatchData);
+    }
+}
diff --git a/vendor/nikic/fast-route/test/Dispatcher/CharCountBasedTest.php b/vendor/nikic/fast-route/test/Dispatcher/CharCountBasedTest.php
new file mode 100644
index 0000000..8168498
--- /dev/null
+++ b/vendor/nikic/fast-route/test/Dispatcher/CharCountBasedTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class CharCountBasedTest extends DispatcherTest {
+    protected function getDispatcherClass() {
+        return 'FastRoute\\Dispatcher\\CharCountBased';
+    }
+
+    protected function getDataGeneratorClass() {
+        return 'FastRoute\\DataGenerator\\CharCountBased';
+    }
+}
diff --git a/vendor/nikic/fast-route/test/Dispatcher/DispatcherTest.php b/vendor/nikic/fast-route/test/Dispatcher/DispatcherTest.php
new file mode 100644
index 0000000..a6d6205
--- /dev/null
+++ b/vendor/nikic/fast-route/test/Dispatcher/DispatcherTest.php
@@ -0,0 +1,561 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+use FastRoute\RouteCollector;
+
+abstract class DispatcherTest extends \PHPUnit_Framework_TestCase {
+
+    /**
+     * Delegate dispatcher selection to child test classes
+     */
+    abstract protected function getDispatcherClass();
+
+    /**
+     * Delegate dataGenerator selection to child test classes
+     */
+    abstract protected function getDataGeneratorClass();
+
+    /**
+     * Set appropriate options for the specific Dispatcher class we're testing
+     */
+    private function generateDispatcherOptions() {
+        return [
+            'dataGenerator' => $this->getDataGeneratorClass(),
+            'dispatcher' => $this->getDispatcherClass()
+        ];
+    }
+
+    /**
+     * @dataProvider provideFoundDispatchCases
+     */
+    public function testFoundDispatches($method, $uri, $callback, $handler, $argDict) {
+        $dispatcher = \FastRoute\simpleDispatcher($callback, $this->generateDispatcherOptions());
+        $info = $dispatcher->dispatch($method, $uri);
+        $this->assertSame($dispatcher::FOUND, $info[0]);
+        $this->assertSame($handler, $info[1]);
+        $this->assertSame($argDict, $info[2]);
+    }
+
+    /**
+     * @dataProvider provideNotFoundDispatchCases
+     */
+    public function testNotFoundDispatches($method, $uri, $callback) {
+        $dispatcher = \FastRoute\simpleDispatcher($callback, $this->generateDispatcherOptions());
+        $routeInfo = $dispatcher->dispatch($method, $uri);
+        $this->assertFalse(isset($routeInfo[1]),
+            "NOT_FOUND result must only contain a single element in the returned info array"
+        );
+        $this->assertSame($dispatcher::NOT_FOUND, $routeInfo[0]);
+    }
+
+    /**
+     * @dataProvider provideMethodNotAllowedDispatchCases
+     */
+    public function testMethodNotAllowedDispatches($method, $uri, $callback, $availableMethods) {
+        $dispatcher = \FastRoute\simpleDispatcher($callback, $this->generateDispatcherOptions());
+        $routeInfo = $dispatcher->dispatch($method, $uri);
+        $this->assertTrue(isset($routeInfo[1]),
+            "METHOD_NOT_ALLOWED result must return an array of allowed methods at index 1"
+        );
+
+        list($routedStatus, $methodArray) = $dispatcher->dispatch($method, $uri);
+        $this->assertSame($dispatcher::METHOD_NOT_ALLOWED, $routedStatus);
+        $this->assertSame($availableMethods, $methodArray);
+    }
+
+    /**
+     * @expectedException \FastRoute\BadRouteException
+     * @expectedExceptionMessage Cannot use the same placeholder "test" twice
+     */
+    public function testDuplicateVariableNameError() {
+        \FastRoute\simpleDispatcher(function(RouteCollector $r) {
+            $r->addRoute('GET', '/foo/{test}/{test:\d+}', 'handler0');
+        }, $this->generateDispatcherOptions());
+    }
+
+    /**
+     * @expectedException \FastRoute\BadRouteException
+     * @expectedExceptionMessage Cannot register two routes matching "/user/([^/]+)" for method "GET"
+     */
+    public function testDuplicateVariableRoute() {
+        \FastRoute\simpleDispatcher(function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{id}', 'handler0'); // oops, forgot \d+ restriction ;)
+            $r->addRoute('GET', '/user/{name}', 'handler1');
+        }, $this->generateDispatcherOptions());
+    }
+
+    /**
+     * @expectedException \FastRoute\BadRouteException
+     * @expectedExceptionMessage Cannot register two routes matching "/user" for method "GET"
+     */
+    public function testDuplicateStaticRoute() {
+        \FastRoute\simpleDispatcher(function(RouteCollector $r) {
+            $r->addRoute('GET', '/user', 'handler0');
+            $r->addRoute('GET', '/user', 'handler1');
+        }, $this->generateDispatcherOptions());
+    }
+
+    /**
+     * @expectedException \FastRoute\BadRouteException
+     * @expectedExceptionMessage Static route "/user/nikic" is shadowed by previously defined variable route "/user/([^/]+)" for method "GET"
+     */
+    public function testShadowedStaticRoute() {
+        \FastRoute\simpleDispatcher(function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}', 'handler0');
+            $r->addRoute('GET', '/user/nikic', 'handler1');
+        }, $this->generateDispatcherOptions());
+    }
+
+    /**
+     * @expectedException \FastRoute\BadRouteException
+     * @expectedExceptionMessage Regex "(en|de)" for parameter "lang" contains a capturing group
+     */
+    public function testCapturing() {
+        \FastRoute\simpleDispatcher(function(RouteCollector $r) {
+            $r->addRoute('GET', '/{lang:(en|de)}', 'handler0');
+        }, $this->generateDispatcherOptions());
+    }
+
+    public function provideFoundDispatchCases() {
+        $cases = [];
+
+        // 0 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/resource/123/456', 'handler0');
+        };
+
+        $method = 'GET';
+        $uri = '/resource/123/456';
+        $handler = 'handler0';
+        $argDict = [];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 1 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/handler0', 'handler0');
+            $r->addRoute('GET', '/handler1', 'handler1');
+            $r->addRoute('GET', '/handler2', 'handler2');
+        };
+
+        $method = 'GET';
+        $uri = '/handler2';
+        $handler = 'handler2';
+        $argDict = [];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 2 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}/{id:[0-9]+}', 'handler0');
+            $r->addRoute('GET', '/user/{id:[0-9]+}', 'handler1');
+            $r->addRoute('GET', '/user/{name}', 'handler2');
+        };
+
+        $method = 'GET';
+        $uri = '/user/rdlowrey';
+        $handler = 'handler2';
+        $argDict = ['name' => 'rdlowrey'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 3 -------------------------------------------------------------------------------------->
+
+        // reuse $callback from #2
+
+        $method = 'GET';
+        $uri = '/user/12345';
+        $handler = 'handler1';
+        $argDict = ['id' => '12345'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 4 -------------------------------------------------------------------------------------->
+
+        // reuse $callback from #3
+
+        $method = 'GET';
+        $uri = '/user/NaN';
+        $handler = 'handler2';
+        $argDict = ['name' => 'NaN'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 5 -------------------------------------------------------------------------------------->
+
+        // reuse $callback from #4
+
+        $method = 'GET';
+        $uri = '/user/rdlowrey/12345';
+        $handler = 'handler0';
+        $argDict = ['name' => 'rdlowrey', 'id' => '12345'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 6 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{id:[0-9]+}', 'handler0');
+            $r->addRoute('GET', '/user/12345/extension', 'handler1');
+            $r->addRoute('GET', '/user/{id:[0-9]+}.{extension}', 'handler2');
+
+        };
+
+        $method = 'GET';
+        $uri = '/user/12345.svg';
+        $handler = 'handler2';
+        $argDict = ['id' => '12345', 'extension' => 'svg'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 7 ----- Test GET method fallback on HEAD route miss ------------------------------------>
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}', 'handler0');
+            $r->addRoute('GET', '/user/{name}/{id:[0-9]+}', 'handler1');
+            $r->addRoute('GET', '/static0', 'handler2');
+            $r->addRoute('GET', '/static1', 'handler3');
+            $r->addRoute('HEAD', '/static1', 'handler4');
+        };
+
+        $method = 'HEAD';
+        $uri = '/user/rdlowrey';
+        $handler = 'handler0';
+        $argDict = ['name' => 'rdlowrey'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 8 ----- Test GET method fallback on HEAD route miss ------------------------------------>
+
+        // reuse $callback from #7
+
+        $method = 'HEAD';
+        $uri = '/user/rdlowrey/1234';
+        $handler = 'handler1';
+        $argDict = ['name' => 'rdlowrey', 'id' => '1234'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 9 ----- Test GET method fallback on HEAD route miss ------------------------------------>
+
+        // reuse $callback from #8
+
+        $method = 'HEAD';
+        $uri = '/static0';
+        $handler = 'handler2';
+        $argDict = [];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 10 ---- Test existing HEAD route used if available (no fallback) ----------------------->
+
+        // reuse $callback from #9
+
+        $method = 'HEAD';
+        $uri = '/static1';
+        $handler = 'handler4';
+        $argDict = [];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 11 ---- More specified routes are not shadowed by less specific of another method ------>
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}', 'handler0');
+            $r->addRoute('POST', '/user/{name:[a-z]+}', 'handler1');
+        };
+
+        $method = 'POST';
+        $uri = '/user/rdlowrey';
+        $handler = 'handler1';
+        $argDict = ['name' => 'rdlowrey'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 12 ---- Handler of more specific routes is used, if it occurs first -------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}', 'handler0');
+            $r->addRoute('POST', '/user/{name:[a-z]+}', 'handler1');
+            $r->addRoute('POST', '/user/{name}', 'handler2');
+        };
+
+        $method = 'POST';
+        $uri = '/user/rdlowrey';
+        $handler = 'handler1';
+        $argDict = ['name' => 'rdlowrey'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 13 ---- Route with constant suffix ----------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}', 'handler0');
+            $r->addRoute('GET', '/user/{name}/edit', 'handler1');
+        };
+
+        $method = 'GET';
+        $uri = '/user/rdlowrey/edit';
+        $handler = 'handler1';
+        $argDict = ['name' => 'rdlowrey'];
+
+        $cases[] = [$method, $uri, $callback, $handler, $argDict];
+
+        // 14 ---- Handle multiple methods with the same handler ---------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute(['GET', 'POST'], '/user', 'handlerGetPost');
+            $r->addRoute(['DELETE'], '/user', 'handlerDelete');
+            $r->addRoute([], '/user', 'handlerNone');
+        };
+
+        $argDict = [];
+        $cases[] = ['GET', '/user', $callback, 'handlerGetPost', $argDict];
+        $cases[] = ['POST', '/user', $callback, 'handlerGetPost', $argDict];
+        $cases[] = ['DELETE', '/user', $callback, 'handlerDelete', $argDict];
+
+        // 15 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('POST', '/user.json', 'handler0');
+            $r->addRoute('GET', '/{entity}.json', 'handler1');
+        };
+
+        $cases[] = ['GET', '/user.json', $callback, 'handler1', ['entity' => 'user']];
+
+        // 16 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '', 'handler0');
+        };
+
+        $cases[] = ['GET', '', $callback, 'handler0', []];
+
+        // 17 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('HEAD', '/a/{foo}', 'handler0');
+            $r->addRoute('GET', '/b/{foo}', 'handler1');
+        };
+
+        $cases[] = ['HEAD', '/b/bar', $callback, 'handler1', ['foo' => 'bar']];
+
+        // 18 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('HEAD', '/a', 'handler0');
+            $r->addRoute('GET', '/b', 'handler1');
+        };
+
+        $cases[] = ['HEAD', '/b', $callback, 'handler1', []];
+
+        // 19 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/foo', 'handler0');
+            $r->addRoute('HEAD', '/{bar}', 'handler1');
+        };
+
+        $cases[] = ['HEAD', '/foo', $callback, 'handler1', ['bar' => 'foo']];
+
+        // 20 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('*', '/user', 'handler0');
+            $r->addRoute('*', '/{user}', 'handler1');
+            $r->addRoute('GET', '/user', 'handler2');
+        };
+
+        $cases[] = ['GET', '/user', $callback, 'handler2', []];
+
+        // 21 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('*', '/user', 'handler0');
+            $r->addRoute('GET', '/user', 'handler1');
+        };
+
+        $cases[] = ['POST', '/user', $callback, 'handler0', []];
+
+        // 22 ----
+
+        $cases[] = ['HEAD', '/user', $callback, 'handler1', []];
+
+        // 23 ----
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/{bar}', 'handler0');
+            $r->addRoute('*', '/foo', 'handler1');
+        };
+
+        $cases[] = ['GET', '/foo', $callback, 'handler0', ['bar' => 'foo']];
+
+        // x -------------------------------------------------------------------------------------->
+
+        return $cases;
+    }
+
+    public function provideNotFoundDispatchCases() {
+        $cases = [];
+
+        // 0 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/resource/123/456', 'handler0');
+        };
+
+        $method = 'GET';
+        $uri = '/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 1 -------------------------------------------------------------------------------------->
+
+        // reuse callback from #0
+        $method = 'POST';
+        $uri = '/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 2 -------------------------------------------------------------------------------------->
+
+        // reuse callback from #1
+        $method = 'PUT';
+        $uri = '/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 3 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/handler0', 'handler0');
+            $r->addRoute('GET', '/handler1', 'handler1');
+            $r->addRoute('GET', '/handler2', 'handler2');
+        };
+
+        $method = 'GET';
+        $uri = '/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 4 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}/{id:[0-9]+}', 'handler0');
+            $r->addRoute('GET', '/user/{id:[0-9]+}', 'handler1');
+            $r->addRoute('GET', '/user/{name}', 'handler2');
+        };
+
+        $method = 'GET';
+        $uri = '/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 5 -------------------------------------------------------------------------------------->
+
+        // reuse callback from #4
+        $method = 'GET';
+        $uri = '/user/rdlowrey/12345/not-found';
+
+        $cases[] = [$method, $uri, $callback];
+
+        // 6 -------------------------------------------------------------------------------------->
+
+        // reuse callback from #5
+        $method = 'HEAD';
+
+        $cases[] = array($method, $uri, $callback);
+
+        // x -------------------------------------------------------------------------------------->
+
+        return $cases;
+    }
+
+    public function provideMethodNotAllowedDispatchCases() {
+        $cases = [];
+
+        // 0 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/resource/123/456', 'handler0');
+        };
+
+        $method = 'POST';
+        $uri = '/resource/123/456';
+        $allowedMethods = ['GET'];
+
+        $cases[] = [$method, $uri, $callback, $allowedMethods];
+
+        // 1 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/resource/123/456', 'handler0');
+            $r->addRoute('POST', '/resource/123/456', 'handler1');
+            $r->addRoute('PUT', '/resource/123/456', 'handler2');
+            $r->addRoute('*', '/', 'handler3');
+        };
+
+        $method = 'DELETE';
+        $uri = '/resource/123/456';
+        $allowedMethods = ['GET', 'POST', 'PUT'];
+
+        $cases[] = [$method, $uri, $callback, $allowedMethods];
+
+        // 2 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('GET', '/user/{name}/{id:[0-9]+}', 'handler0');
+            $r->addRoute('POST', '/user/{name}/{id:[0-9]+}', 'handler1');
+            $r->addRoute('PUT', '/user/{name}/{id:[0-9]+}', 'handler2');
+            $r->addRoute('PATCH', '/user/{name}/{id:[0-9]+}', 'handler3');
+        };
+
+        $method = 'DELETE';
+        $uri = '/user/rdlowrey/42';
+        $allowedMethods = ['GET', 'POST', 'PUT', 'PATCH'];
+
+        $cases[] = [$method, $uri, $callback, $allowedMethods];
+
+        // 3 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('POST', '/user/{name}', 'handler1');
+            $r->addRoute('PUT', '/user/{name:[a-z]+}', 'handler2');
+            $r->addRoute('PATCH', '/user/{name:[a-z]+}', 'handler3');
+        };
+
+        $method = 'GET';
+        $uri = '/user/rdlowrey';
+        $allowedMethods = ['POST', 'PUT', 'PATCH'];
+
+        $cases[] = [$method, $uri, $callback, $allowedMethods];
+
+        // 4 -------------------------------------------------------------------------------------->
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute(['GET', 'POST'], '/user', 'handlerGetPost');
+            $r->addRoute(['DELETE'], '/user', 'handlerDelete');
+            $r->addRoute([], '/user', 'handlerNone');
+        };
+
+        $cases[] = ['PUT', '/user', $callback, ['GET', 'POST', 'DELETE']];
+
+        // 5
+
+        $callback = function(RouteCollector $r) {
+            $r->addRoute('POST', '/user.json', 'handler0');
+            $r->addRoute('GET', '/{entity}.json', 'handler1');
+        };
+
+        $cases[] = ['PUT', '/user.json', $callback, ['POST', 'GET']];
+
+        // x -------------------------------------------------------------------------------------->
+
+        return $cases;
+    }
+
+}
diff --git a/vendor/nikic/fast-route/test/Dispatcher/GroupCountBasedTest.php b/vendor/nikic/fast-route/test/Dispatcher/GroupCountBasedTest.php
new file mode 100644
index 0000000..74820fc
--- /dev/null
+++ b/vendor/nikic/fast-route/test/Dispatcher/GroupCountBasedTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class GroupCountBasedTest extends DispatcherTest {
+    protected function getDispatcherClass() {
+        return 'FastRoute\\Dispatcher\\GroupCountBased';
+    }
+
+    protected function getDataGeneratorClass() {
+        return 'FastRoute\\DataGenerator\\GroupCountBased';
+    }
+}
diff --git a/vendor/nikic/fast-route/test/Dispatcher/GroupPosBasedTest.php b/vendor/nikic/fast-route/test/Dispatcher/GroupPosBasedTest.php
new file mode 100644
index 0000000..c3d4f8d
--- /dev/null
+++ b/vendor/nikic/fast-route/test/Dispatcher/GroupPosBasedTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class GroupPosBasedTest extends DispatcherTest {
+    protected function getDispatcherClass() {
+        return 'FastRoute\\Dispatcher\\GroupPosBased';
+    }
+
+    protected function getDataGeneratorClass() {
+        return 'FastRoute\\DataGenerator\\GroupPosBased';
+    }
+}
diff --git a/vendor/nikic/fast-route/test/Dispatcher/MarkBasedTest.php b/vendor/nikic/fast-route/test/Dispatcher/MarkBasedTest.php
new file mode 100644
index 0000000..04b0af9
--- /dev/null
+++ b/vendor/nikic/fast-route/test/Dispatcher/MarkBasedTest.php
@@ -0,0 +1,20 @@
+<?php
+
+namespace FastRoute\Dispatcher;
+
+class MarkBasedTest extends DispatcherTest {
+    public function setUp() {
+        preg_match('/(*MARK:A)a/', 'a', $matches);
+        if (!isset($matches['MARK'])) {
+            $this->markTestSkipped('PHP 5.6 required for MARK support');
+        }
+    }
+
+    protected function getDispatcherClass() {
+        return 'FastRoute\\Dispatcher\\MarkBased';
+    }
+
+    protected function getDataGeneratorClass() {
+        return 'FastRoute\\DataGenerator\\MarkBased';
+    }
+}
diff --git a/vendor/nikic/fast-route/test/HackTypechecker/HackTypecheckerTest.php b/vendor/nikic/fast-route/test/HackTypechecker/HackTypecheckerTest.php
new file mode 100644
index 0000000..7bc6ebb
--- /dev/null
+++ b/vendor/nikic/fast-route/test/HackTypechecker/HackTypecheckerTest.php
@@ -0,0 +1,39 @@
+<?php
+
+namespace FastRoute;
+
+class HackTypecheckerTest extends \PhpUnit_Framework_TestCase {
+    const SERVER_ALREADY_RUNNING_CODE = 77;
+    public function testTypechecks($recurse = true) {
+        if (!defined('HHVM_VERSION')) {
+            $this->markTestSkipped("HHVM only");
+        }
+        if (!version_compare(HHVM_VERSION, '3.9.0', '>=')) {
+          $this->markTestSkipped('classname<T> requires HHVM 3.9+');
+        }
+
+        // The typechecker recurses the whole tree, so it makes sure
+        // that everything in fixtures/ is valid when this runs.
+
+        $output = array();
+        $exit_code = null;
+        exec(
+            'hh_server --check '.escapeshellarg(__DIR__.'/../../').' 2>&1',
+            $output,
+            $exit_code
+        );
+        if ($exit_code === self::SERVER_ALREADY_RUNNING_CODE) {
+            $this->assertTrue(
+              $recurse,
+              "Typechecker still running after running hh_client stop"
+            );
+            // Server already running - 3.10 => 3.11 regression:
+            // https://github.com/facebook/hhvm/issues/6646
+            exec('hh_client stop 2>/dev/null');
+            $this->testTypechecks(/* recurse = */ false);
+            return;
+
+        }
+        $this->assertSame(0, $exit_code, implode("\n", $output));
+    }
+}
diff --git a/vendor/nikic/fast-route/test/HackTypechecker/fixtures/all_options.php b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/all_options.php
new file mode 100644
index 0000000..05a9af2
--- /dev/null
+++ b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/all_options.php
@@ -0,0 +1,29 @@
+<?hh
+
+namespace FastRoute\TestFixtures;
+
+function all_options_simple(): \FastRoute\Dispatcher {
+    return \FastRoute\simpleDispatcher(
+      $collector ==> {},
+      shape(
+        'routeParser' => \FastRoute\RouteParser\Std::class,
+        'dataGenerator' => \FastRoute\DataGenerator\GroupCountBased::class,
+        'dispatcher' => \FastRoute\Dispatcher\GroupCountBased::class,
+        'routeCollector' => \FastRoute\RouteCollector::class,
+      ),
+    );
+}
+
+function all_options_cached(): \FastRoute\Dispatcher {
+    return \FastRoute\cachedDispatcher(
+      $collector ==> {},
+      shape(
+        'routeParser' => \FastRoute\RouteParser\Std::class,
+        'dataGenerator' => \FastRoute\DataGenerator\GroupCountBased::class,
+        'dispatcher' => \FastRoute\Dispatcher\GroupCountBased::class,
+        'routeCollector' => \FastRoute\RouteCollector::class,
+        'cacheFile' => '/dev/null',
+        'cacheDisabled' => false,
+      ),
+    );
+}
diff --git a/vendor/nikic/fast-route/test/HackTypechecker/fixtures/empty_options.php b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/empty_options.php
new file mode 100644
index 0000000..61eb541
--- /dev/null
+++ b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/empty_options.php
@@ -0,0 +1,11 @@
+<?hh
+
+namespace FastRoute\TestFixtures;
+
+function empty_options_simple(): \FastRoute\Dispatcher {
+    return \FastRoute\simpleDispatcher($collector ==> {}, shape());
+}
+
+function empty_options_cached(): \FastRoute\Dispatcher {
+    return \FastRoute\cachedDispatcher($collector ==> {}, shape());
+}
diff --git a/vendor/nikic/fast-route/test/HackTypechecker/fixtures/no_options.php b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/no_options.php
new file mode 100644
index 0000000..44b5422
--- /dev/null
+++ b/vendor/nikic/fast-route/test/HackTypechecker/fixtures/no_options.php
@@ -0,0 +1,11 @@
+<?hh
+
+namespace FastRoute\TestFixtures;
+
+function no_options_simple(): \FastRoute\Dispatcher {
+    return \FastRoute\simpleDispatcher($collector ==> {});
+}
+
+function no_options_cached(): \FastRoute\Dispatcher {
+    return \FastRoute\cachedDispatcher($collector ==> {});
+}
diff --git a/vendor/nikic/fast-route/test/RouteCollectorTest.php b/vendor/nikic/fast-route/test/RouteCollectorTest.php
new file mode 100644
index 0000000..11bcf1c
--- /dev/null
+++ b/vendor/nikic/fast-route/test/RouteCollectorTest.php
@@ -0,0 +1,97 @@
+<?php
+
+namespace FastRoute;
+
+class RouteCollectorTest extends \PHPUnit_Framework_TestCase {
+    public function testShortcuts() {
+        $r = new DummyRouteCollector();
+
+        $r->delete('/delete', 'delete');
+        $r->get('/get', 'get');
+        $r->head('/head', 'head');
+        $r->patch('/patch', 'patch');
+        $r->post('/post', 'post');
+        $r->put('/put', 'put');
+
+        $expected = [
+            ['DELETE', '/delete', 'delete'],
+            ['GET', '/get', 'get'],
+            ['HEAD', '/head', 'head'],
+            ['PATCH', '/patch', 'patch'],
+            ['POST', '/post', 'post'],
+            ['PUT', '/put', 'put'],
+        ];
+
+        $this->assertSame($expected, $r->routes);
+    }
+
+    public function testGroups() {
+        $r = new DummyRouteCollector();
+
+        $r->delete('/delete', 'delete');
+        $r->get('/get', 'get');
+        $r->head('/head', 'head');
+        $r->patch('/patch', 'patch');
+        $r->post('/post', 'post');
+        $r->put('/put', 'put');
+
+        $r->addGroup('/group-one', function (DummyRouteCollector $r) {
+            $r->delete('/delete', 'delete');
+            $r->get('/get', 'get');
+            $r->head('/head', 'head');
+            $r->patch('/patch', 'patch');
+            $r->post('/post', 'post');
+            $r->put('/put', 'put');
+
+            $r->addGroup('/group-two', function (DummyRouteCollector $r) {
+                $r->delete('/delete', 'delete');
+                $r->get('/get', 'get');
+                $r->head('/head', 'head');
+                $r->patch('/patch', 'patch');
+                $r->post('/post', 'post');
+                $r->put('/put', 'put');
+            });
+        });
+
+        $r->addGroup('/admin', function (DummyRouteCollector $r) {
+            $r->get('-some-info', 'admin-some-info');
+        });
+        $r->addGroup('/admin-', function (DummyRouteCollector $r) {
+            $r->get('more-info', 'admin-more-info');
+        });
+
+        $expected = [
+            ['DELETE', '/delete', 'delete'],
+            ['GET', '/get', 'get'],
+            ['HEAD', '/head', 'head'],
+            ['PATCH', '/patch', 'patch'],
+            ['POST', '/post', 'post'],
+            ['PUT', '/put', 'put'],
+            ['DELETE', '/group-one/delete', 'delete'],
+            ['GET', '/group-one/get', 'get'],
+            ['HEAD', '/group-one/head', 'head'],
+            ['PATCH', '/group-one/patch', 'patch'],
+            ['POST', '/group-one/post', 'post'],
+            ['PUT', '/group-one/put', 'put'],
+            ['DELETE', '/group-one/group-two/delete', 'delete'],
+            ['GET', '/group-one/group-two/get', 'get'],
+            ['HEAD', '/group-one/group-two/head', 'head'],
+            ['PATCH', '/group-one/group-two/patch', 'patch'],
+            ['POST', '/group-one/group-two/post', 'post'],
+            ['PUT', '/group-one/group-two/put', 'put'],
+            ['GET', '/admin-some-info', 'admin-some-info'],
+            ['GET', '/admin-more-info', 'admin-more-info'],
+        ];
+
+        $this->assertSame($expected, $r->routes);
+    }
+}
+
+class DummyRouteCollector extends RouteCollector {
+    public $routes = [];
+    public function __construct() {}
+    public function addRoute($method, $route, $handler) {
+        $route = $this->currentGroupPrefix . $route;
+        $this->routes[] = [$method, $route, $handler];
+    }
+}
\ No newline at end of file
diff --git a/vendor/nikic/fast-route/test/RouteParser/StdTest.php b/vendor/nikic/fast-route/test/RouteParser/StdTest.php
new file mode 100644
index 0000000..41f194b
--- /dev/null
+++ b/vendor/nikic/fast-route/test/RouteParser/StdTest.php
@@ -0,0 +1,147 @@
+<?php
+
+namespace FastRoute\RouteParser;
+
+class StdTest extends \PhpUnit_Framework_TestCase {
+    /** @dataProvider provideTestParse */
+    public function testParse($routeString, $expectedRouteDatas) {
+        $parser = new Std();
+        $routeDatas = $parser->parse($routeString);
+        $this->assertSame($expectedRouteDatas, $routeDatas);
+    }
+
+    /** @dataProvider provideTestParseError */
+    public function testParseError($routeString, $expectedExceptionMessage) {
+        $parser = new Std();
+        $this->setExpectedException('FastRoute\\BadRouteException', $expectedExceptionMessage);
+        $parser->parse($routeString);
+    }
+
+    public function provideTestParse() {
+        return [
+            [
+                '/test',
+                [
+                    ['/test'],
+                ]
+            ],
+            [
+                '/test/{param}',
+                [
+                    ['/test/', ['param', '[^/]+']],
+                ]
+            ],
+            [
+                '/te{ param }st',
+                [
+                    ['/te', ['param', '[^/]+'], 'st']
+                ]
+            ],
+            [
+                '/test/{param1}/test2/{param2}',
+                [
+                    ['/test/', ['param1', '[^/]+'], '/test2/', ['param2', '[^/]+']]
+                ]
+            ],
+            [
+                '/test/{param:\d+}',
+                [
+                    ['/test/', ['param', '\d+']]
+                ]
+            ],
+            [
+                '/test/{ param : \d{1,9} }',
+                [
+                    ['/test/', ['param', '\d{1,9}']]
+                ]
+            ],
+            [
+                '/test[opt]',
+                [
+                    ['/test'],
+                    ['/testopt'],
+                ]
+            ],
+            [
+                '/test[/{param}]',
+                [
+                    ['/test'],
+                    ['/test/', ['param', '[^/]+']],
+                ]
+            ],
+            [
+                '/{param}[opt]',
+                [
+                    ['/', ['param', '[^/]+']],
+                    ['/', ['param', '[^/]+'], 'opt']
+                ]
+            ],
+            [
+                '/test[/{name}[/{id:[0-9]+}]]',
+                [
+                    ['/test'],
+                    ['/test/', ['name', '[^/]+']],
+                    ['/test/', ['name', '[^/]+'], '/', ['id', '[0-9]+']],
+                ]
+            ],
+            [
+                '',
+                [
+                    [''],
+                ]
+            ],
+            [
+                '[test]',
+                [
+                    [''],
+                    ['test'],
+                ]
+            ],
+            [
+                '/{foo-bar}',
+                [
+                    ['/', ['foo-bar', '[^/]+']]
+                ]
+            ],
+            [
+                '/{_foo:.*}',
+                [
+                    ['/', ['_foo', '.*']]
+                ]
+            ],
+        ];
+    }
+
+    public function provideTestParseError() {
+        return [
+            [
+                '/test[opt',
+                "Number of opening '[' and closing ']' does not match"
+            ],
+            [
+                '/test[opt[opt2]',
+                "Number of opening '[' and closing ']' does not match"
+            ],
+            [
+                '/testopt]',
+                "Number of opening '[' and closing ']' does not match"
+            ],
+            [
+                '/test[]',
+                "Empty optional part"
+            ],
+            [
+                '/test[[opt]]',
+                "Empty optional part"
+            ],
+            [
+                '[[test]]',
+                "Empty optional part"
+            ],
+            [
+                '/test[/opt]/required',
+                "Optional segments can only occur at the end of a route"
+            ],
+        ];
+    }
+}
diff --git a/vendor/nikic/fast-route/test/bootstrap.php b/vendor/nikic/fast-route/test/bootstrap.php
new file mode 100644
index 0000000..27e6d4c
--- /dev/null
+++ b/vendor/nikic/fast-route/test/bootstrap.php
@@ -0,0 +1,11 @@
+<?php
+
+require_once __DIR__ . '/../src/functions.php';
+
+spl_autoload_register(function($class) {
+    if (strpos($class, 'FastRoute\\') === 0) {
+        $dir = strcasecmp(substr($class, -4), 'Test') ? 'src/' : 'test/';
+        $name = substr($class, strlen('FastRoute'));
+        require __DIR__ . '/../' . $dir . strtr($name, '\\', DIRECTORY_SEPARATOR) . '.php';
+    }
+});
diff --git a/vendor/pimple/pimple/.gitignore b/vendor/pimple/pimple/.gitignore
new file mode 100644
index 0000000..c089b09
--- /dev/null
+++ b/vendor/pimple/pimple/.gitignore
@@ -0,0 +1,3 @@
+phpunit.xml
+composer.lock
+/vendor/
diff --git a/vendor/pimple/pimple/.travis.yml b/vendor/pimple/pimple/.travis.yml
new file mode 100644
index 0000000..5f8bb7c
--- /dev/null
+++ b/vendor/pimple/pimple/.travis.yml
@@ -0,0 +1,32 @@
+language: php
+
+env:
+  matrix:
+    - PIMPLE_EXT=no
+    - PIMPLE_EXT=yes
+  global:
+    - REPORT_EXIT_STATUS=1
+
+php:
+  - 5.3
+  - 5.4
+  - 5.5
+  - 5.6
+  - hhvm
+
+before_script:
+  - composer self-update
+  - COMPOSER_ROOT_VERSION=dev-master composer dump-autoload
+  - if [ "$PIMPLE_EXT" == "yes" ]; then sh -c "cd ext/pimple && phpize && ./configure && make && sudo make install"; fi
+  - if [ "$PIMPLE_EXT" == "yes" ]; then echo "extension=pimple.so" >> `php --ini | grep "Loaded Configuration" | sed -e "s|.*:\s*||"`; fi
+
+script:
+  - cd ext/pimple
+  - if [ "$PIMPLE_EXT" == "yes" ]; then yes n | make test | tee output ; grep -E 'Tests failed +. +0' output; fi
+  - cd ../..
+  - phpunit
+
+matrix:
+  exclude:
+    - php: hhvm
+      env: PIMPLE_EXT=yes
diff --git a/vendor/pimple/pimple/CHANGELOG b/vendor/pimple/pimple/CHANGELOG
new file mode 100644
index 0000000..cc67997
--- /dev/null
+++ b/vendor/pimple/pimple/CHANGELOG
@@ -0,0 +1,35 @@
+* 3.0.2 (2015-09-11)
+
+ * refactored the C extension
+ * minor non-significant changes
+
+* 3.0.1 (2015-07-30)
+
+ * simplified some code
+ * fixed a segfault in the C extension
+
+* 3.0.0 (2014-07-24)
+
+ * removed the Pimple class alias (use Pimple\Container instead)
+
+* 2.1.1 (2014-07-24)
+
+ * fixed compiler warnings for the C extension
+ * fixed code when dealing with circular references
+
+* 2.1.0 (2014-06-24)
+
+ * moved the Pimple to Pimple\Container (with a BC layer -- Pimple is now a
+   deprecated alias which will be removed in Pimple 3.0)
+ * added Pimple\ServiceProviderInterface (and Pimple::register())
+
+* 2.0.0 (2014-02-10)
+
+ * changed extend to automatically re-assign the extended service and keep it as shared or factory
+   (to keep BC, extend still returns the extended service)
+ * changed services to be shared by default (use factory() for factory
+   services)
+
+* 1.0.0
+
+ * initial version
diff --git a/vendor/pimple/pimple/LICENSE b/vendor/pimple/pimple/LICENSE
new file mode 100644
index 0000000..d7949e2
--- /dev/null
+++ b/vendor/pimple/pimple/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2009-2015 Fabien Potencier
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is furnished
+to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/vendor/pimple/pimple/README.rst b/vendor/pimple/pimple/README.rst
new file mode 100644
index 0000000..93fb35a
--- /dev/null
+++ b/vendor/pimple/pimple/README.rst
@@ -0,0 +1,201 @@
+Pimple
+======
+
+.. caution::
+
+    This is the documentation for Pimple 3.x. If you are using Pimple 1.x, read
+    the `Pimple 1.x documentation`_. Reading the Pimple 1.x code is also a good
+    way to learn more about how to create a simple Dependency Injection
+    Container (recent versions of Pimple are more focused on performance).
+
+Pimple is a small Dependency Injection Container for PHP.
+
+Installation
+------------
+
+Before using Pimple in your project, add it to your ``composer.json`` file:
+
+.. code-block:: bash
+
+    $ ./composer.phar require pimple/pimple ~3.0
+
+Alternatively, Pimple is also available as a PHP C extension:
+
+.. code-block:: bash
+
+    $ git clone https://github.com/silexphp/Pimple
+    $ cd Pimple/ext/pimple
+    $ phpize
+    $ ./configure
+    $ make
+    $ make install
+
+Usage
+-----
+
+Creating a container is a matter of creating a ``Container`` instance:
+
+.. code-block:: php
+
+    use Pimple\Container;
+
+    $container = new Container();
+
+As many other dependency injection containers, Pimple manages two different
+kind of data: **services** and **parameters**.
+
+Defining Services
+~~~~~~~~~~~~~~~~~
+
+A service is an object that does something as part of a larger system. Examples
+of services: a database connection, a templating engine, or a mailer. Almost
+any **global** object can be a service.
+
+Services are defined by **anonymous functions** that return an instance of an
+object:
+
+.. code-block:: php
+
+    // define some services
+    $container['session_storage'] = function ($c) {
+        return new SessionStorage('SESSION_ID');
+    };
+
+    $container['session'] = function ($c) {
+        return new Session($c['session_storage']);
+    };
+
+Notice that the anonymous function has access to the current container
+instance, allowing references to other services or parameters.
+
+As objects are only created when you get them, the order of the definitions
+does not matter.
+
+Using the defined services is also very easy:
+
+.. code-block:: php
+
+    // get the session object
+    $session = $container['session'];
+
+    // the above call is roughly equivalent to the following code:
+    // $storage = new SessionStorage('SESSION_ID');
+    // $session = new Session($storage);
+
+Defining Factory Services
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+By default, each time you get a service, Pimple returns the **same instance**
+of it. If you want a different instance to be returned for all calls, wrap your
+anonymous function with the ``factory()`` method
+
+.. code-block:: php
+
+    $container['session'] = $container->factory(function ($c) {
+        return new Session($c['session_storage']);
+    });
+
+Now, each call to ``$container['session']`` returns a new instance of the
+session.
+
+Defining Parameters
+~~~~~~~~~~~~~~~~~~~
+
+Defining a parameter allows to ease the configuration of your container from
+the outside and to store global values:
+
+.. code-block:: php
+
+    // define some parameters
+    $container['cookie_name'] = 'SESSION_ID';
+    $container['session_storage_class'] = 'SessionStorage';
+
+If you change the ``session_storage`` service definition like below:
+
+.. code-block:: php
+
+    $container['session_storage'] = function ($c) {
+        return new $c['session_storage_class']($c['cookie_name']);
+    };
+
+You can now easily change the cookie name by overriding the
+``session_storage_class`` parameter instead of redefining the service
+definition.
+
+Protecting Parameters
+~~~~~~~~~~~~~~~~~~~~~
+
+Because Pimple sees anonymous functions as service definitions, you need to
+wrap anonymous functions with the ``protect()`` method to store them as
+parameters:
+
+.. code-block:: php
+
+    $container['random_func'] = $container->protect(function () {
+        return rand();
+    });
+
+Modifying Services after Definition
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+In some cases you may want to modify a service definition after it has been
+defined. You can use the ``extend()`` method to define additional code to be
+run on your service just after it is created:
+
+.. code-block:: php
+
+    $container['session_storage'] = function ($c) {
+        return new $c['session_storage_class']($c['cookie_name']);
+    };
+
+    $container->extend('session_storage', function ($storage, $c) {
+        $storage->...();
+
+        return $storage;
+    });
+
+The first argument is the name of the service to extend, the second a function
+that gets access to the object instance and the container.
+
+Extending a Container
+~~~~~~~~~~~~~~~~~~~~~
+
+If you use the same libraries over and over, you might want to reuse some
+services from one project to the next one; package your services into a
+**provider** by implementing ``Pimple\ServiceProviderInterface``:
+
+.. code-block:: php
+
+    use Pimple\Container;
+
+    class FooProvider implements Pimple\ServiceProviderInterface
+    {
+        public function register(Container $pimple)
+        {
+            // register some services and parameters
+            // on $pimple
+        }
+    }
+
+Then, register the provider on a Container:
+
+.. code-block:: php
+
+    $pimple->register(new FooProvider());
+
+Fetching the Service Creation Function
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+When you access an object, Pimple automatically calls the anonymous function
+that you defined, which creates the service object for you. If you want to get
+raw access to this function, you can use the ``raw()`` method:
+
+.. code-block:: php
+
+    $container['session'] = function ($c) {
+        return new Session($c['session_storage']);
+    };
+
+    $sessionFunction = $container->raw('session');
+
+.. _Pimple 1.x documentation: https://github.com/silexphp/Pimple/tree/1.1
diff --git a/vendor/pimple/pimple/composer.json b/vendor/pimple/pimple/composer.json
new file mode 100644
index 0000000..a5268f1
--- /dev/null
+++ b/vendor/pimple/pimple/composer.json
@@ -0,0 +1,25 @@
+{
+    "name": "pimple/pimple",
+    "type": "library",
+    "description": "Pimple, a simple Dependency Injection Container",
+    "keywords": ["dependency injection", "container"],
+    "homepage": "http://pimple.sensiolabs.org",
+    "license": "MIT",
+    "authors": [
+        {
+            "name": "Fabien Potencier",
+            "email": "fabien@symfony.com"
+        }
+    ],
+    "require": {
+        "php": ">=5.3.0"
+    },
+    "autoload": {
+        "psr-0": { "Pimple": "src/" }
+    },
+    "extra": {
+        "branch-alias": {
+            "dev-master": "3.0.x-dev"
+        }
+    }
+}
diff --git a/vendor/pimple/pimple/ext/pimple/.gitignore b/vendor/pimple/pimple/ext/pimple/.gitignore
new file mode 100644
index 0000000..1861088
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/.gitignore
@@ -0,0 +1,30 @@
+*.sw*
+.deps
+Makefile
+Makefile.fragments
+Makefile.global
+Makefile.objects
+acinclude.m4
+aclocal.m4
+build/
+config.cache
+config.guess
+config.h
+config.h.in
+config.log
+config.nice
+config.status
+config.sub
+configure
+configure.in
+install-sh
+libtool
+ltmain.sh
+missing
+mkinstalldirs
+run-tests.php
+*.loT
+.libs/
+modules/
+*.la
+*.lo
diff --git a/vendor/pimple/pimple/ext/pimple/README.md b/vendor/pimple/pimple/ext/pimple/README.md
new file mode 100644
index 0000000..7b39eb2
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/README.md
@@ -0,0 +1,12 @@
+This is Pimple 2 implemented in C
+
+* PHP >= 5.3
+* Not tested under Windows, might work
+
+Install
+=======
+
+    > phpize
+    > ./configure
+    > make
+    > make install
diff --git a/vendor/pimple/pimple/ext/pimple/config.m4 b/vendor/pimple/pimple/ext/pimple/config.m4
new file mode 100644
index 0000000..c9ba17d
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/config.m4
@@ -0,0 +1,63 @@
+dnl $Id$
+dnl config.m4 for extension pimple
+
+dnl Comments in this file start with the string 'dnl'.
+dnl Remove where necessary. This file will not work
+dnl without editing.
+
+dnl If your extension references something external, use with:
+
+dnl PHP_ARG_WITH(pimple, for pimple support,
+dnl Make sure that the comment is aligned:
+dnl [  --with-pimple             Include pimple support])
+
+dnl Otherwise use enable:
+
+PHP_ARG_ENABLE(pimple, whether to enable pimple support,
+dnl Make sure that the comment is aligned:
+[  --enable-pimple           Enable pimple support])
+
+if test "$PHP_PIMPLE" != "no"; then
+  dnl Write more examples of tests here...
+
+  dnl # --with-pimple -> check with-path
+  dnl SEARCH_PATH="/usr/local /usr"     # you might want to change this
+  dnl SEARCH_FOR="/include/pimple.h"  # you most likely want to change this
+  dnl if test -r $PHP_PIMPLE/$SEARCH_FOR; then # path given as parameter
+  dnl   PIMPLE_DIR=$PHP_PIMPLE
+  dnl else # search default path list
+  dnl   AC_MSG_CHECKING([for pimple files in default path])
+  dnl   for i in $SEARCH_PATH ; do
+  dnl     if test -r $i/$SEARCH_FOR; then
+  dnl       PIMPLE_DIR=$i
+  dnl       AC_MSG_RESULT(found in $i)
+  dnl     fi
+  dnl   done
+  dnl fi
+  dnl
+  dnl if test -z "$PIMPLE_DIR"; then
+  dnl   AC_MSG_RESULT([not found])
+  dnl   AC_MSG_ERROR([Please reinstall the pimple distribution])
+  dnl fi
+
+  dnl # --with-pimple -> add include path
+  dnl PHP_ADD_INCLUDE($PIMPLE_DIR/include)
+
+  dnl # --with-pimple -> check for lib and symbol presence
+  dnl LIBNAME=pimple # you may want to change this
+  dnl LIBSYMBOL=pimple # you most likely want to change this 
+
+  dnl PHP_CHECK_LIBRARY($LIBNAME,$LIBSYMBOL,
+  dnl [
+  dnl   PHP_ADD_LIBRARY_WITH_PATH($LIBNAME, $PIMPLE_DIR/lib, PIMPLE_SHARED_LIBADD)
+  dnl   AC_DEFINE(HAVE_PIMPLELIB,1,[ ])
+  dnl ],[
+  dnl   AC_MSG_ERROR([wrong pimple lib version or lib not found])
+  dnl ],[
+  dnl   -L$PIMPLE_DIR/lib -lm
+  dnl ])
+  dnl
+  dnl PHP_SUBST(PIMPLE_SHARED_LIBADD)
+
+  PHP_NEW_EXTENSION(pimple, pimple.c, $ext_shared)
+fi
diff --git a/vendor/pimple/pimple/ext/pimple/config.w32 b/vendor/pimple/pimple/ext/pimple/config.w32
new file mode 100644
index 0000000..39857b3
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/config.w32
@@ -0,0 +1,13 @@
+// $Id$
+// vim:ft=javascript
+
+// If your extension references something external, use ARG_WITH
+// ARG_WITH("pimple", "for pimple support", "no");
+
+// Otherwise, use ARG_ENABLE
+// ARG_ENABLE("pimple", "enable pimple support", "no");
+
+if (PHP_PIMPLE != "no") {
+	EXTENSION("pimple", "pimple.c");
+}
+
diff --git a/vendor/pimple/pimple/ext/pimple/php_pimple.h b/vendor/pimple/pimple/ext/pimple/php_pimple.h
new file mode 100644
index 0000000..49431f0
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/php_pimple.h
@@ -0,0 +1,121 @@
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2014 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef PHP_PIMPLE_H
+#define PHP_PIMPLE_H
+
+extern zend_module_entry pimple_module_entry;
+#define phpext_pimple_ptr &pimple_module_entry
+
+#ifdef PHP_WIN32
+#	define PHP_PIMPLE_API __declspec(dllexport)
+#elif defined(__GNUC__) && __GNUC__ >= 4
+#	define PHP_PIMPLE_API __attribute__ ((visibility("default")))
+#else
+#	define PHP_PIMPLE_API
+#endif
+
+#ifdef ZTS
+#include "TSRM.h"
+#endif
+
+#define PIMPLE_VERSION "3.0.2"
+#define PIMPLE_NS "Pimple"
+
+#define PIMPLE_DEFAULT_ZVAL_CACHE_NUM   5
+#define PIMPLE_DEFAULT_ZVAL_VALUES_NUM 10
+
+zend_module_entry *get_module(void);
+
+PHP_MINIT_FUNCTION(pimple);
+PHP_MINFO_FUNCTION(pimple);
+
+PHP_METHOD(Pimple, __construct);
+PHP_METHOD(Pimple, factory);
+PHP_METHOD(Pimple, protect);
+PHP_METHOD(Pimple, raw);
+PHP_METHOD(Pimple, extend);
+PHP_METHOD(Pimple, keys);
+PHP_METHOD(Pimple, register);
+PHP_METHOD(Pimple, offsetSet);
+PHP_METHOD(Pimple, offsetUnset);
+PHP_METHOD(Pimple, offsetGet);
+PHP_METHOD(Pimple, offsetExists);
+
+PHP_METHOD(PimpleClosure, invoker);
+
+typedef struct _pimple_bucket_value {
+	zval *value; /* Must be the first element */
+	zval *raw;
+	zend_object_handle handle_num;
+	enum {
+		PIMPLE_IS_PARAM   = 0,
+		PIMPLE_IS_SERVICE = 2
+	} type;
+	zend_bool initialized;
+	zend_fcall_info_cache fcc;
+} pimple_bucket_value;
+
+typedef struct _pimple_object {
+	zend_object zobj;
+	HashTable values;
+	HashTable factories;
+	HashTable protected;
+} pimple_object;
+
+typedef struct _pimple_closure_object {
+	zend_object zobj;
+	zval *callable;
+	zval *factory;
+} pimple_closure_object;
+
+static const char sensiolabs_logo[] = "<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAUCAMAAABvRTlyAAAAz1BMVEUAAAAAAAAAAAAsThWB5j4AAACD6T8AAACC6D+C6D6C6D+C6D4AAAAAAACC6D4AAAAAAACC6D8AAAAAAAAAAAAAAAAAAAAAAACC6D4AAAAAAAAAAACC6D4AAAAAAAAAAAAAAAAAAAAAAACC6D8AAACC6D4AAAAAAAAAAAAAAAAAAACC6D8AAACC6D6C6D+B6D+C6D+C6D+C6D8AAACC6D6C6D4AAACC6D/K/2KC6D+B6D6C6D6C6D+C6D8sTxUyWRhEeiEAAACC6D+C5z6B6D7drnEVAAAAQXRSTlMAE3oCNSUuDHFHzxaF9UFsu+irX+zlKzYimaJXktyOSFD6BolxqT7QGMMdarMIpuO28r9EolXKgR16OphfXYd4V14GtB4AAAMpSURBVEjHvVSJctowEF1jjME2RziMwUCoMfd9heZqG4n//6buLpJjkmYm03byZmxJa2nf6u2uQcG2bfhqRN4LoTKBzyGDm68M7mAwcOEdjo4zhA/Rf9Go/CVtTgiRhXfIC3EDH8F/eUX1/9KexRo+QgOdtHDsEe/sM7QT32/+K61Z1LFXcXJxN4pTbu1aTQUzuy2PIA0rDo0/0Aa5XFaJvKaVTrubywXvaa1Wq4Vu/Snr3Y7Aojh4VccwykW2N2oQ8wmjyut6+Q1t5ywIG5Npj1sh5E0B7YOzFDjfuRfaOh3O+MbbVNfTWS9COZk3Obd2su5d0a6IU9KLREbw8gEehWSr1r2sPWciXLG38r5NdW0xu9eioU87omjC9yNaMi5GNf6WppVSOqXCFkmCvMB3p9SROLoYQn5pDgQOujA1xjYvqH+plUdkwnmII8VxR/PKYkrfLLomhVlE3b/LhNbNr7hp0H2JaOc4v8dFB58HSsFTSafaqtY1sT3GO8wsy5rhokYPlRJdjPMajyYqTt1EHF/2uqSWQWmAjCUSmQ1MS3g8Btf1XOsy7YIC0CB1b5Xw1Vhba0zbxiCAQLH9TNPmHJXQUtJAN0KcDsoqLxsNvJrJExa7mKIdp2lRE2WexiS4pqWk/0jROlw6K6bV9YOBDGAuqMJ0bnuUKGB0L27bxgRhGEbzihbhxxXaQC88Vkwq8ldCi86RApWUb0Q+4VDosBCc+1s81lUdnBavH4Zp2mm3O44USwOfvSo9oBiwpFg71lMS1VKJLKljS3j9p+fOTvXXlsSNuEv6YPaZda9uRope0VJfKdo7fPiYfSmvFjXQbkhY0d9hCbBWIktRgEDieDhf1N3wbbkmNNgRy8hyl620yGQat/grV3HMpc2HDKTVmOPFz6ylPCKt/nXcAyV260jaAowwIW0YuBzrOgb/KrddZS9OmJaLgpWK4JX2DDuklcLZSDGcn8Vmx9YDNvT6UsjyBApRyFQVX7Vxm9TGxE16nmfRd8/zQoDmggQOTRh5Hv8pMt9Q/L2JmSwkMCE7dA4BuDjHJwfu0Om4QAhOjrN5XkIatglfiN/bUPdCQFjTYgAAAABJRU5ErkJggg==\">";
+
+static int pimple_zval_to_pimpleval(zval *_zval, pimple_bucket_value *_pimple_bucket_value TSRMLS_DC);
+static int pimple_zval_is_valid_callback(zval *_zval, pimple_bucket_value *_pimple_bucket_value TSRMLS_DC);
+
+static void pimple_bucket_dtor(pimple_bucket_value *bucket);
+static void pimple_free_bucket(pimple_bucket_value *bucket);
+
+static zval *pimple_object_read_dimension(zval *object, zval *offset, int type TSRMLS_DC);
+static void pimple_object_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC);
+static int pimple_object_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC);
+static void pimple_object_unset_dimension(zval *object, zval *offset TSRMLS_DC);
+static zend_object_value pimple_object_create(zend_class_entry *ce TSRMLS_DC);
+static void pimple_free_object_storage(pimple_object *obj TSRMLS_DC);
+
+static void pimple_closure_free_object_storage(pimple_closure_object *obj TSRMLS_DC);
+static zend_object_value pimple_closure_object_create(zend_class_entry *ce TSRMLS_DC);
+static zend_function *pimple_closure_get_constructor(zval * TSRMLS_DC);
+static int pimple_closure_get_closure(zval *obj, zend_class_entry **ce_ptr, union _zend_function **fptr_ptr, zval **zobj_ptr TSRMLS_DC);
+
+#ifdef ZTS
+#define PIMPLE_G(v) TSRMG(pimple_globals_id, zend_pimple_globals *, v)
+#else
+#define PIMPLE_G(v) (pimple_globals.v)
+#endif
+
+#endif	/* PHP_PIMPLE_H */
+
diff --git a/vendor/pimple/pimple/ext/pimple/pimple.c b/vendor/pimple/pimple/ext/pimple/pimple.c
new file mode 100644
index 0000000..239c01d
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/pimple.c
@@ -0,0 +1,922 @@
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2014 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "php.h"
+#include "php_ini.h"
+#include "ext/standard/info.h"
+#include "php_pimple.h"
+#include "pimple_compat.h"
+#include "zend_interfaces.h"
+#include "zend.h"
+#include "Zend/zend_closures.h"
+#include "ext/spl/spl_exceptions.h"
+#include "Zend/zend_exceptions.h"
+#include "main/php_output.h"
+#include "SAPI.h"
+
+static zend_class_entry *pimple_ce;
+static zend_object_handlers pimple_object_handlers;
+static zend_class_entry *pimple_closure_ce;
+static zend_class_entry *pimple_serviceprovider_ce;
+static zend_object_handlers pimple_closure_object_handlers;
+static zend_internal_function pimple_closure_invoker_function;
+
+#define FETCH_DIM_HANDLERS_VARS 	pimple_object *pimple_obj = NULL; \
+									ulong index; \
+									pimple_obj = (pimple_object *)zend_object_store_get_object(object TSRMLS_CC); \
+
+#define PIMPLE_OBJECT_HANDLE_INHERITANCE_OBJECT_HANDLERS	do { \
+	if (ce != pimple_ce) { \
+		zend_hash_find(&ce->function_table, ZEND_STRS("offsetget"), (void **)&function); \
+		if (function->common.scope != ce) { /* if the function is not defined in this actual class */ \
+			pimple_object_handlers.read_dimension = pimple_object_read_dimension; /* then overwrite the handler to use custom one */ \
+		} \
+		zend_hash_find(&ce->function_table, ZEND_STRS("offsetset"), (void **)&function); \
+		if (function->common.scope != ce) { \
+			pimple_object_handlers.write_dimension = pimple_object_write_dimension; \
+		} \
+		zend_hash_find(&ce->function_table, ZEND_STRS("offsetexists"), (void **)&function); \
+		if (function->common.scope != ce) { \
+			pimple_object_handlers.has_dimension = pimple_object_has_dimension; \
+		} \
+		zend_hash_find(&ce->function_table, ZEND_STRS("offsetunset"), (void **)&function); \
+		if (function->common.scope != ce) { \
+			pimple_object_handlers.unset_dimension = pimple_object_unset_dimension; \
+		} \
+	} else { \
+		pimple_object_handlers.read_dimension = pimple_object_read_dimension; \
+		pimple_object_handlers.write_dimension = pimple_object_write_dimension; \
+		pimple_object_handlers.has_dimension = pimple_object_has_dimension; \
+		pimple_object_handlers.unset_dimension = pimple_object_unset_dimension; \
+	}\
+											} while(0);
+
+#define PIMPLE_CALL_CB	do { \
+			zend_fcall_info_argn(&fci TSRMLS_CC, 1, &object); \
+			fci.size           = sizeof(fci); \
+			fci.object_ptr     = retval->fcc.object_ptr; \
+			fci.function_name  = retval->value; \
+			fci.no_separation  = 1; \
+			fci.retval_ptr_ptr = &retval_ptr_ptr; \
+\
+			zend_call_function(&fci, &retval->fcc TSRMLS_CC); \
+			efree(fci.params); \
+			if (EG(exception)) { \
+				return EG(uninitialized_zval_ptr); \
+			} \
+						} while(0);
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo___construct, 0, 0, 0)
+ZEND_ARG_ARRAY_INFO(0, value, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_offsetset, 0, 0, 2)
+ZEND_ARG_INFO(0, offset)
+ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_offsetget, 0, 0, 1)
+ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_offsetexists, 0, 0, 1)
+ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_offsetunset, 0, 0, 1)
+ZEND_ARG_INFO(0, offset)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_factory, 0, 0, 1)
+ZEND_ARG_INFO(0, callable)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_protect, 0, 0, 1)
+ZEND_ARG_INFO(0, callable)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_raw, 0, 0, 1)
+ZEND_ARG_INFO(0, id)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_extend, 0, 0, 2)
+ZEND_ARG_INFO(0, id)
+ZEND_ARG_INFO(0, callable)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_keys, 0, 0, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_register, 0, 0, 1)
+ZEND_ARG_OBJ_INFO(0, provider, Pimple\\ServiceProviderInterface, 0)
+ZEND_ARG_ARRAY_INFO(0, values, 1)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_serviceprovider_register, 0, 0, 1)
+ZEND_ARG_OBJ_INFO(0, pimple, Pimple\\Container, 0)
+ZEND_END_ARG_INFO()
+
+static const zend_function_entry pimple_ce_functions[] = {
+	PHP_ME(Pimple, __construct,	arginfo___construct, ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, factory,         arginfo_factory,         ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, protect,         arginfo_protect,         ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, raw,             arginfo_raw,             ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, extend,          arginfo_extend,          ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, keys,            arginfo_keys,            ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, register,		arginfo_register,		 ZEND_ACC_PUBLIC)
+
+	PHP_ME(Pimple, offsetSet,       arginfo_offsetset,       ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, offsetGet,       arginfo_offsetget,       ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, offsetExists,    arginfo_offsetexists,    ZEND_ACC_PUBLIC)
+	PHP_ME(Pimple, offsetUnset,     arginfo_offsetunset,     ZEND_ACC_PUBLIC)
+	PHP_FE_END
+};
+
+static const zend_function_entry pimple_serviceprovider_iface_ce_functions[] = {
+	PHP_ABSTRACT_ME(ServiceProviderInterface, register, arginfo_serviceprovider_register)
+	PHP_FE_END
+};
+
+static void pimple_closure_free_object_storage(pimple_closure_object *obj TSRMLS_DC)
+{
+	zend_object_std_dtor(&obj->zobj TSRMLS_CC);
+	if (obj->factory) {
+		zval_ptr_dtor(&obj->factory);
+	}
+	if (obj->callable) {
+		zval_ptr_dtor(&obj->callable);
+	}
+	efree(obj);
+}
+
+static void pimple_free_object_storage(pimple_object *obj TSRMLS_DC)
+{
+	zend_hash_destroy(&obj->factories);
+	zend_hash_destroy(&obj->protected);
+	zend_hash_destroy(&obj->values);
+	zend_object_std_dtor(&obj->zobj TSRMLS_CC);
+	efree(obj);
+}
+
+static void pimple_free_bucket(pimple_bucket_value *bucket)
+{
+	if (bucket->raw) {
+		zval_ptr_dtor(&bucket->raw);
+	}
+}
+
+static zend_object_value pimple_closure_object_create(zend_class_entry *ce TSRMLS_DC)
+{
+	zend_object_value retval;
+	pimple_closure_object *pimple_closure_obj = NULL;
+
+	pimple_closure_obj = ecalloc(1, sizeof(pimple_closure_object));
+	ZEND_OBJ_INIT(&pimple_closure_obj->zobj, ce);
+
+	pimple_closure_object_handlers.get_constructor = pimple_closure_get_constructor;
+	retval.handlers = &pimple_closure_object_handlers;
+	retval.handle   = zend_objects_store_put(pimple_closure_obj, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) pimple_closure_free_object_storage, NULL TSRMLS_CC);
+
+	return retval;
+}
+
+static zend_function *pimple_closure_get_constructor(zval *obj TSRMLS_DC)
+{
+	zend_error(E_ERROR, "Pimple\\ContainerClosure is an internal class and cannot be instantiated");
+
+	return NULL;
+}
+
+static int pimple_closure_get_closure(zval *obj, zend_class_entry **ce_ptr, union _zend_function **fptr_ptr, zval **zobj_ptr TSRMLS_DC)
+{
+	*zobj_ptr = obj;
+	*ce_ptr   = Z_OBJCE_P(obj);
+	*fptr_ptr = (zend_function *)&pimple_closure_invoker_function;
+
+	return SUCCESS;
+}
+
+static zend_object_value pimple_object_create(zend_class_entry *ce TSRMLS_DC)
+{
+	zend_object_value retval;
+	pimple_object *pimple_obj  = NULL;
+	zend_function *function    = NULL;
+
+	pimple_obj = emalloc(sizeof(pimple_object));
+	ZEND_OBJ_INIT(&pimple_obj->zobj, ce);
+
+	PIMPLE_OBJECT_HANDLE_INHERITANCE_OBJECT_HANDLERS
+
+	retval.handlers = &pimple_object_handlers;
+	retval.handle   = zend_objects_store_put(pimple_obj, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) pimple_free_object_storage, NULL TSRMLS_CC);
+
+	zend_hash_init(&pimple_obj->factories, PIMPLE_DEFAULT_ZVAL_CACHE_NUM, NULL, (dtor_func_t)pimple_bucket_dtor, 0);
+	zend_hash_init(&pimple_obj->protected, PIMPLE_DEFAULT_ZVAL_CACHE_NUM, NULL, (dtor_func_t)pimple_bucket_dtor, 0);
+	zend_hash_init(&pimple_obj->values, PIMPLE_DEFAULT_ZVAL_VALUES_NUM, NULL, (dtor_func_t)pimple_bucket_dtor, 0);
+
+	return retval;
+}
+
+static void pimple_object_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
+{
+	FETCH_DIM_HANDLERS_VARS
+
+	pimple_bucket_value pimple_value = {0}, *found_value = NULL;
+	ulong hash;
+
+	pimple_zval_to_pimpleval(value, &pimple_value TSRMLS_CC);
+
+	if (!offset) {/* $p[] = 'foo' when not overloaded */
+		zend_hash_next_index_insert(&pimple_obj->values, (void *)&pimple_value, sizeof(pimple_bucket_value), NULL);
+		Z_ADDREF_P(value);
+		return;
+	}
+
+	switch (Z_TYPE_P(offset)) {
+	case IS_STRING:
+		hash = zend_hash_func(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
+		zend_hash_quick_find(&pimple_obj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hash, (void **)&found_value);
+		if (found_value && found_value->type == PIMPLE_IS_SERVICE && found_value->initialized == 1) {
+			pimple_free_bucket(&pimple_value);
+			zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, "Cannot override frozen service \"%s\".", Z_STRVAL_P(offset));
+			return;
+		}
+		if (zend_hash_quick_update(&pimple_obj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hash, (void *)&pimple_value, sizeof(pimple_bucket_value), NULL) == FAILURE) {
+			pimple_free_bucket(&pimple_value);
+			return;
+		}
+		Z_ADDREF_P(value);
+	break;
+	case IS_DOUBLE:
+	case IS_BOOL:
+	case IS_LONG:
+		if (Z_TYPE_P(offset) == IS_DOUBLE) {
+			index = (ulong)Z_DVAL_P(offset);
+		} else {
+			index = Z_LVAL_P(offset);
+		}
+		zend_hash_index_find(&pimple_obj->values, index, (void **)&found_value);
+		if (found_value && found_value->type == PIMPLE_IS_SERVICE && found_value->initialized == 1) {
+			pimple_free_bucket(&pimple_value);
+			zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, "Cannot override frozen service \"%ld\".", index);
+			return;
+		}
+		if (zend_hash_index_update(&pimple_obj->values, index, (void *)&pimple_value, sizeof(pimple_bucket_value), NULL) == FAILURE) {
+			pimple_free_bucket(&pimple_value);
+			return;
+		}
+		Z_ADDREF_P(value);
+	break;
+	case IS_NULL: /* $p[] = 'foo' when overloaded */
+		zend_hash_next_index_insert(&pimple_obj->values, (void *)&pimple_value, sizeof(pimple_bucket_value), NULL);
+		Z_ADDREF_P(value);
+	break;
+	default:
+		pimple_free_bucket(&pimple_value);
+		zend_error(E_WARNING, "Unsupported offset type");
+	}
+}
+
+static void pimple_object_unset_dimension(zval *object, zval *offset TSRMLS_DC)
+{
+	FETCH_DIM_HANDLERS_VARS
+
+	switch (Z_TYPE_P(offset)) {
+	case IS_STRING:
+		zend_symtable_del(&pimple_obj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
+		zend_symtable_del(&pimple_obj->factories, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
+		zend_symtable_del(&pimple_obj->protected, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
+	break;
+	case IS_DOUBLE:
+	case IS_BOOL:
+	case IS_LONG:
+		if (Z_TYPE_P(offset) == IS_DOUBLE) {
+			index = (ulong)Z_DVAL_P(offset);
+		} else {
+			index = Z_LVAL_P(offset);
+		}
+		zend_hash_index_del(&pimple_obj->values, index);
+		zend_hash_index_del(&pimple_obj->factories, index);
+		zend_hash_index_del(&pimple_obj->protected, index);
+	break;
+	default:
+		zend_error(E_WARNING, "Unsupported offset type");
+	}
+}
+
+static int pimple_object_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
+{
+	FETCH_DIM_HANDLERS_VARS
+
+	pimple_bucket_value *retval = NULL;
+
+	switch (Z_TYPE_P(offset)) {
+	case IS_STRING:
+		if (zend_symtable_find(&pimple_obj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **)&retval) == SUCCESS) {
+			switch (check_empty) {
+			case 0: /* isset */
+				return 1; /* Differs from PHP behavior (Z_TYPE_P(retval->value) != IS_NULL;) */
+			case 1: /* empty */
+			default:
+				return zend_is_true(retval->value);
+			}
+		}
+		return 0;
+	break;
+	case IS_DOUBLE:
+	case IS_BOOL:
+	case IS_LONG:
+		if (Z_TYPE_P(offset) == IS_DOUBLE) {
+			index = (ulong)Z_DVAL_P(offset);
+		} else {
+			index = Z_LVAL_P(offset);
+		}
+		if (zend_hash_index_find(&pimple_obj->values, index, (void **)&retval) == SUCCESS) {
+			switch (check_empty) {
+				case 0: /* isset */
+					return 1; /* Differs from PHP behavior (Z_TYPE_P(retval->value) != IS_NULL;)*/
+				case 1: /* empty */
+				default:
+					return zend_is_true(retval->value);
+			}
+		}
+		return 0;
+	break;
+	default:
+		zend_error(E_WARNING, "Unsupported offset type");
+		return 0;
+	}
+}
+
+static zval *pimple_object_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
+{
+	FETCH_DIM_HANDLERS_VARS
+
+	pimple_bucket_value *retval = NULL;
+	zend_fcall_info fci         = {0};
+	zval *retval_ptr_ptr        = NULL;
+
+	switch (Z_TYPE_P(offset)) {
+	case IS_STRING:
+		if (zend_symtable_find(&pimple_obj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **)&retval) == FAILURE) {
+			zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%s\" is not defined.", Z_STRVAL_P(offset));
+			return EG(uninitialized_zval_ptr);
+		}
+	break;
+	case IS_DOUBLE:
+	case IS_BOOL:
+	case IS_LONG:
+		if (Z_TYPE_P(offset) == IS_DOUBLE) {
+			index = (ulong)Z_DVAL_P(offset);
+		} else {
+			index = Z_LVAL_P(offset);
+		}
+		if (zend_hash_index_find(&pimple_obj->values, index, (void **)&retval) == FAILURE) {
+			return EG(uninitialized_zval_ptr);
+		}
+	break;
+	case IS_NULL: /* $p[][3] = 'foo' first dim access */
+		return EG(uninitialized_zval_ptr);
+	break;
+	default:
+		zend_error(E_WARNING, "Unsupported offset type");
+		return EG(uninitialized_zval_ptr);
+	}
+
+	if(retval->type == PIMPLE_IS_PARAM) {
+		return retval->value;
+	}
+
+	if (zend_hash_index_exists(&pimple_obj->protected, retval->handle_num)) {
+		/* Service is protected, return the value every time */
+		return retval->value;
+	}
+
+	if (zend_hash_index_exists(&pimple_obj->factories, retval->handle_num)) {
+		/* Service is a factory, call it everytime and never cache its result */
+		PIMPLE_CALL_CB
+		Z_DELREF_P(retval_ptr_ptr); /* fetch dim addr will increment refcount */
+		return retval_ptr_ptr;
+	}
+
+	if (retval->initialized == 1) {
+		/* Service has already been called, return its cached value */
+		return retval->value;
+	}
+
+	ALLOC_INIT_ZVAL(retval->raw);
+	MAKE_COPY_ZVAL(&retval->value, retval->raw);
+
+	PIMPLE_CALL_CB
+
+	retval->initialized = 1;
+	zval_ptr_dtor(&retval->value);
+	retval->value = retval_ptr_ptr;
+
+	return retval->value;
+}
+
+static int pimple_zval_is_valid_callback(zval *_zval, pimple_bucket_value *_pimple_bucket_value TSRMLS_DC)
+{
+	if (Z_TYPE_P(_zval) != IS_OBJECT) {
+		return FAILURE;
+	}
+
+	if (_pimple_bucket_value->fcc.called_scope) {
+		return SUCCESS;
+	}
+
+	if (Z_OBJ_HANDLER_P(_zval, get_closure) && Z_OBJ_HANDLER_P(_zval, get_closure)(_zval, &_pimple_bucket_value->fcc.calling_scope, &_pimple_bucket_value->fcc.function_handler, &_pimple_bucket_value->fcc.object_ptr TSRMLS_CC) == SUCCESS) {
+		_pimple_bucket_value->fcc.called_scope = _pimple_bucket_value->fcc.calling_scope;
+		return SUCCESS;
+	} else {
+		return FAILURE;
+	}
+}
+
+static int pimple_zval_to_pimpleval(zval *_zval, pimple_bucket_value *_pimple_bucket_value TSRMLS_DC)
+{
+	_pimple_bucket_value->value = _zval;
+
+	if (Z_TYPE_P(_zval) != IS_OBJECT) {
+		return PIMPLE_IS_PARAM;
+	}
+
+	if (pimple_zval_is_valid_callback(_zval, _pimple_bucket_value TSRMLS_CC) == SUCCESS) {
+		_pimple_bucket_value->type       = PIMPLE_IS_SERVICE;
+		_pimple_bucket_value->handle_num = Z_OBJ_HANDLE_P(_zval);
+	}
+
+	return PIMPLE_IS_SERVICE;
+}
+
+static void pimple_bucket_dtor(pimple_bucket_value *bucket)
+{
+	zval_ptr_dtor(&bucket->value);
+	pimple_free_bucket(bucket);
+}
+
+PHP_METHOD(Pimple, protect)
+{
+	zval *protected     = NULL;
+	pimple_object *pobj = NULL;
+	pimple_bucket_value bucket = {0};
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &protected) == FAILURE) {
+		return;
+	}
+
+	if (pimple_zval_is_valid_callback(protected, &bucket TSRMLS_CC) == FAILURE) {
+		pimple_free_bucket(&bucket);
+		zend_throw_exception(spl_ce_InvalidArgumentException, "Callable is not a Closure or invokable object.", 0 TSRMLS_CC);
+		return;
+	}
+
+	pimple_zval_to_pimpleval(protected, &bucket TSRMLS_CC);
+	pobj = (pimple_object *)zend_object_store_get_object(getThis() TSRMLS_CC);
+
+	if (zend_hash_index_update(&pobj->protected, bucket.handle_num, (void *)&bucket, sizeof(pimple_bucket_value), NULL) == SUCCESS) {
+		Z_ADDREF_P(protected);
+		RETURN_ZVAL(protected, 1 , 0);
+	} else {
+		pimple_free_bucket(&bucket);
+	}
+	RETURN_FALSE;
+}
+
+PHP_METHOD(Pimple, raw)
+{
+	zval *offset = NULL;
+	pimple_object *pobj        = NULL;
+	pimple_bucket_value *value = NULL;
+	ulong index;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
+		return;
+	}
+
+	pobj = zend_object_store_get_object(getThis() TSRMLS_CC);
+
+	switch (Z_TYPE_P(offset)) {
+		case IS_STRING:
+			if (zend_symtable_find(&pobj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void *)&value) == FAILURE) {
+				zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%s\" is not defined.", Z_STRVAL_P(offset));
+				RETURN_NULL();
+			}
+		break;
+		case IS_DOUBLE:
+		case IS_BOOL:
+		case IS_LONG:
+			if (Z_TYPE_P(offset) == IS_DOUBLE) {
+				index = (ulong)Z_DVAL_P(offset);
+			} else {
+				index = Z_LVAL_P(offset);
+			}
+			if (zend_hash_index_find(&pobj->values, index, (void *)&value) == FAILURE) {
+				RETURN_NULL();
+			}
+		break;
+		case IS_NULL:
+		default:
+			zend_error(E_WARNING, "Unsupported offset type");
+	}
+
+	if (value->raw) {
+		RETVAL_ZVAL(value->raw, 1, 0);
+	} else {
+		RETVAL_ZVAL(value->value, 1, 0);
+	}
+}
+
+PHP_METHOD(Pimple, extend)
+{
+	zval *offset = NULL, *callable = NULL, *pimple_closure_obj = NULL;
+	pimple_bucket_value bucket = {0}, *value = NULL;
+	pimple_object *pobj          = NULL;
+	pimple_closure_object *pcobj = NULL;
+	ulong index;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &offset, &callable) == FAILURE) {
+		return;
+	}
+
+	pobj = zend_object_store_get_object(getThis() TSRMLS_CC);
+
+	switch (Z_TYPE_P(offset)) {
+		case IS_STRING:
+			if (zend_symtable_find(&pobj->values, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void *)&value) == FAILURE) {
+				zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%s\" is not defined.", Z_STRVAL_P(offset));
+				RETURN_NULL();
+			}
+			if (value->type != PIMPLE_IS_SERVICE) {
+				zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%s\" does not contain an object definition.", Z_STRVAL_P(offset));
+				RETURN_NULL();
+			}
+		break;
+		case IS_DOUBLE:
+		case IS_BOOL:
+		case IS_LONG:
+			if (Z_TYPE_P(offset) == IS_DOUBLE) {
+				index = (ulong)Z_DVAL_P(offset);
+			} else {
+				index = Z_LVAL_P(offset);
+			}
+			if (zend_hash_index_find(&pobj->values, index, (void *)&value) == FAILURE) {
+				zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%ld\" is not defined.", index);
+				RETURN_NULL();
+			}
+			if (value->type != PIMPLE_IS_SERVICE) {
+				zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, "Identifier \"%ld\" does not contain an object definition.", index);
+				RETURN_NULL();
+			}
+		break;
+		case IS_NULL:
+		default:
+			zend_error(E_WARNING, "Unsupported offset type");
+	}
+
+	if (pimple_zval_is_valid_callback(callable, &bucket TSRMLS_CC) == FAILURE) {
+		pimple_free_bucket(&bucket);
+		zend_throw_exception(spl_ce_InvalidArgumentException, "Extension service definition is not a Closure or invokable object.", 0 TSRMLS_CC);
+		RETURN_NULL();
+	}
+	pimple_free_bucket(&bucket);
+
+	ALLOC_INIT_ZVAL(pimple_closure_obj);
+	object_init_ex(pimple_closure_obj, pimple_closure_ce);
+
+	pcobj = zend_object_store_get_object(pimple_closure_obj TSRMLS_CC);
+	pcobj->callable = callable;
+	pcobj->factory  = value->value;
+	Z_ADDREF_P(callable);
+	Z_ADDREF_P(value->value);
+
+	if (zend_hash_index_exists(&pobj->factories, value->handle_num)) {
+		pimple_zval_to_pimpleval(pimple_closure_obj, &bucket TSRMLS_CC);
+		zend_hash_index_del(&pobj->factories, value->handle_num);
+		zend_hash_index_update(&pobj->factories, bucket.handle_num, (void *)&bucket, sizeof(pimple_bucket_value), NULL);
+		Z_ADDREF_P(pimple_closure_obj);
+	}
+
+	pimple_object_write_dimension(getThis(), offset, pimple_closure_obj TSRMLS_CC);
+
+	RETVAL_ZVAL(pimple_closure_obj, 1, 1);
+}
+
+PHP_METHOD(Pimple, keys)
+{
+	HashPosition pos;
+	pimple_object *pobj = NULL;
+	zval **value        = NULL;
+	zval *endval        = NULL;
+	char *str_index     = NULL;
+	int str_len;
+	ulong num_index;
+
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+
+	pobj = zend_object_store_get_object(getThis() TSRMLS_CC);
+	array_init_size(return_value, zend_hash_num_elements(&pobj->values));
+
+	zend_hash_internal_pointer_reset_ex(&pobj->values, &pos);
+
+	while(zend_hash_get_current_data_ex(&pobj->values, (void **)&value, &pos) == SUCCESS) {
+		MAKE_STD_ZVAL(endval);
+		switch (zend_hash_get_current_key_ex(&pobj->values, &str_index, (uint *)&str_len, &num_index, 0, &pos)) {
+			case HASH_KEY_IS_STRING:
+				ZVAL_STRINGL(endval, str_index, str_len - 1, 1);
+				zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &endval, sizeof(zval *), NULL);
+			break;
+			case HASH_KEY_IS_LONG:
+				ZVAL_LONG(endval, num_index);
+				zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &endval, sizeof(zval *), NULL);
+			break;
+		}
+	zend_hash_move_forward_ex(&pobj->values, &pos);
+	}
+}
+
+PHP_METHOD(Pimple, factory)
+{
+	zval *factory       = NULL;
+	pimple_object *pobj = NULL;
+	pimple_bucket_value bucket = {0};
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &factory) == FAILURE) {
+		return;
+	}
+
+	if (pimple_zval_is_valid_callback(factory, &bucket TSRMLS_CC) == FAILURE) {
+		pimple_free_bucket(&bucket);
+		zend_throw_exception(spl_ce_InvalidArgumentException, "Service definition is not a Closure or invokable object.", 0 TSRMLS_CC);
+		return;
+	}
+
+	pimple_zval_to_pimpleval(factory, &bucket TSRMLS_CC);
+	pobj = (pimple_object *)zend_object_store_get_object(getThis() TSRMLS_CC);
+
+	if (zend_hash_index_update(&pobj->factories, bucket.handle_num, (void *)&bucket, sizeof(pimple_bucket_value), NULL) == SUCCESS) {
+		Z_ADDREF_P(factory);
+		RETURN_ZVAL(factory, 1 , 0);
+	} else {
+		pimple_free_bucket(&bucket);
+	}
+
+	RETURN_FALSE;
+}
+
+PHP_METHOD(Pimple, offsetSet)
+{
+	zval *offset = NULL, *value = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &offset, &value) == FAILURE) {
+		return;
+	}
+
+	pimple_object_write_dimension(getThis(), offset, value TSRMLS_CC);
+}
+
+PHP_METHOD(Pimple, offsetGet)
+{
+	zval *offset = NULL, *retval = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
+		return;
+	}
+
+	retval = pimple_object_read_dimension(getThis(), offset, 0 TSRMLS_CC);
+
+	RETVAL_ZVAL(retval, 1, 0);
+}
+
+PHP_METHOD(Pimple, offsetUnset)
+{
+	zval *offset = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
+		return;
+	}
+
+	pimple_object_unset_dimension(getThis(), offset TSRMLS_CC);
+}
+
+PHP_METHOD(Pimple, offsetExists)
+{
+	zval *offset = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
+		return;
+	}
+
+	RETVAL_BOOL(pimple_object_has_dimension(getThis(), offset, 1 TSRMLS_CC));
+}
+
+PHP_METHOD(Pimple, register)
+{
+	zval *provider;
+	zval **data;
+	zval *retval = NULL;
+	zval key;
+
+	HashTable *array = NULL;
+	HashPosition pos;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "O|h", &provider, pimple_serviceprovider_ce, &array) == FAILURE) {
+		return;
+	}
+
+	RETVAL_ZVAL(getThis(), 1, 0);
+
+	zend_call_method_with_1_params(&provider, Z_OBJCE_P(provider), NULL, "register", &retval, getThis());
+
+	if (retval) {
+		zval_ptr_dtor(&retval);
+	}
+
+	if (!array) {
+		return;
+	}
+
+	zend_hash_internal_pointer_reset_ex(array, &pos);
+
+	while(zend_hash_get_current_data_ex(array, (void **)&data, &pos) == SUCCESS) {
+		zend_hash_get_current_key_zval_ex(array, &key, &pos);
+		pimple_object_write_dimension(getThis(), &key, *data TSRMLS_CC);
+		zend_hash_move_forward_ex(array, &pos);
+	}
+}
+
+PHP_METHOD(Pimple, __construct)
+{
+	zval *values = NULL, **pData = NULL, offset;
+	HashPosition pos;
+	char *str_index = NULL;
+	zend_uint str_length;
+	ulong num_index;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|a!", &values) == FAILURE || !values) {
+		return;
+	}
+
+	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(values), &pos);
+	while (zend_hash_has_more_elements_ex(Z_ARRVAL_P(values), &pos) == SUCCESS) {
+			zend_hash_get_current_data_ex(Z_ARRVAL_P(values), (void **)&pData, &pos);
+			zend_hash_get_current_key_ex(Z_ARRVAL_P(values), &str_index, &str_length, &num_index, 0, &pos);
+			INIT_ZVAL(offset);
+			if (zend_hash_get_current_key_type_ex(Z_ARRVAL_P(values), &pos) == HASH_KEY_IS_LONG) {
+				ZVAL_LONG(&offset, num_index);
+			} else {
+				ZVAL_STRINGL(&offset, str_index, (str_length - 1), 0);
+			}
+		pimple_object_write_dimension(getThis(), &offset, *pData TSRMLS_CC);
+		zend_hash_move_forward_ex(Z_ARRVAL_P(values), &pos);
+	}
+}
+
+/*
+ * This is PHP code snippet handling extend()s calls :
+
+  $extended = function ($c) use ($callable, $factory) {
+      return $callable($factory($c), $c);
+  };
+
+ */
+PHP_METHOD(PimpleClosure, invoker)
+{
+	pimple_closure_object *pcobj = NULL;
+	zval *arg = NULL, *retval = NULL, *newretval = NULL;
+	zend_fcall_info fci        = {0};
+	zval **args[2];
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &arg) == FAILURE) {
+		return;
+	}
+
+	pcobj = zend_object_store_get_object(getThis() TSRMLS_CC);
+
+	fci.function_name = pcobj->factory;
+	args[0] = &arg;
+	zend_fcall_info_argp(&fci TSRMLS_CC, 1, args);
+	fci.retval_ptr_ptr = &retval;
+	fci.size = sizeof(fci);
+
+	if (zend_call_function(&fci, NULL TSRMLS_CC) == FAILURE || EG(exception)) {
+		efree(fci.params);
+		return; /* Should here return default zval */
+	}
+
+	efree(fci.params);
+	memset(&fci, 0, sizeof(fci));
+	fci.size = sizeof(fci);
+
+	fci.function_name = pcobj->callable;
+	args[0] = &retval;
+	args[1] = &arg;
+	zend_fcall_info_argp(&fci TSRMLS_CC, 2, args);
+	fci.retval_ptr_ptr = &newretval;
+
+	if (zend_call_function(&fci, NULL TSRMLS_CC) == FAILURE || EG(exception)) {
+		efree(fci.params);
+		zval_ptr_dtor(&retval);
+		return;
+	}
+
+	efree(fci.params);
+	zval_ptr_dtor(&retval);
+
+	RETVAL_ZVAL(newretval, 1 ,1);
+}
+
+PHP_MINIT_FUNCTION(pimple)
+{
+	zend_class_entry tmp_pimple_ce, tmp_pimple_closure_ce, tmp_pimple_serviceprovider_iface_ce;
+	INIT_NS_CLASS_ENTRY(tmp_pimple_ce, PIMPLE_NS, "Container", pimple_ce_functions);
+	INIT_NS_CLASS_ENTRY(tmp_pimple_closure_ce, PIMPLE_NS, "ContainerClosure", NULL);
+	INIT_NS_CLASS_ENTRY(tmp_pimple_serviceprovider_iface_ce, PIMPLE_NS, "ServiceProviderInterface", pimple_serviceprovider_iface_ce_functions);
+
+	tmp_pimple_ce.create_object         = pimple_object_create;
+	tmp_pimple_closure_ce.create_object = pimple_closure_object_create;
+
+	pimple_ce = zend_register_internal_class(&tmp_pimple_ce TSRMLS_CC);
+	zend_class_implements(pimple_ce TSRMLS_CC, 1, zend_ce_arrayaccess);
+
+	pimple_closure_ce = zend_register_internal_class(&tmp_pimple_closure_ce TSRMLS_CC);
+	pimple_closure_ce->ce_flags |= ZEND_ACC_FINAL_CLASS;
+
+	pimple_serviceprovider_ce = zend_register_internal_interface(&tmp_pimple_serviceprovider_iface_ce TSRMLS_CC);
+
+	memcpy(&pimple_closure_object_handlers, zend_get_std_object_handlers(), sizeof(*zend_get_std_object_handlers()));
+	pimple_object_handlers                     = std_object_handlers;
+	pimple_closure_object_handlers.get_closure = pimple_closure_get_closure;
+
+	pimple_closure_invoker_function.function_name     = "Pimple closure internal invoker";
+	pimple_closure_invoker_function.fn_flags         |= ZEND_ACC_CLOSURE;
+	pimple_closure_invoker_function.handler           = ZEND_MN(PimpleClosure_invoker);
+	pimple_closure_invoker_function.num_args          = 1;
+	pimple_closure_invoker_function.required_num_args = 1;
+	pimple_closure_invoker_function.scope             = pimple_closure_ce;
+	pimple_closure_invoker_function.type              = ZEND_INTERNAL_FUNCTION;
+	pimple_closure_invoker_function.module            = &pimple_module_entry;
+
+	return SUCCESS;
+}
+
+PHP_MINFO_FUNCTION(pimple)
+{
+	php_info_print_table_start();
+	php_info_print_table_header(2, "SensioLabs Pimple C support", "enabled");
+	php_info_print_table_row(2, "Pimple supported version", PIMPLE_VERSION);
+	php_info_print_table_end();
+
+	php_info_print_box_start(0);
+	php_write((void *)ZEND_STRL("SensioLabs Pimple C support developed by Julien Pauli") TSRMLS_CC);
+	if (!sapi_module.phpinfo_as_text) {
+		php_write((void *)ZEND_STRL(sensiolabs_logo) TSRMLS_CC);
+	}
+	php_info_print_box_end();
+}
+
+zend_module_entry pimple_module_entry = {
+	STANDARD_MODULE_HEADER,
+	"pimple",
+	NULL,
+	PHP_MINIT(pimple),
+	NULL,
+	NULL,
+	NULL,
+	PHP_MINFO(pimple),
+	PIMPLE_VERSION,
+	STANDARD_MODULE_PROPERTIES
+};
+
+#ifdef COMPILE_DL_PIMPLE
+ZEND_GET_MODULE(pimple)
+#endif
diff --git a/vendor/pimple/pimple/ext/pimple/pimple_compat.h b/vendor/pimple/pimple/ext/pimple/pimple_compat.h
new file mode 100644
index 0000000..d234e17
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/pimple_compat.h
@@ -0,0 +1,81 @@
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2014 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef PIMPLE_COMPAT_H_
+#define PIMPLE_COMPAT_H_
+
+#include "Zend/zend_extensions.h" /* for ZEND_EXTENSION_API_NO */
+
+#define PHP_5_0_X_API_NO		220040412
+#define PHP_5_1_X_API_NO		220051025
+#define PHP_5_2_X_API_NO		220060519
+#define PHP_5_3_X_API_NO		220090626
+#define PHP_5_4_X_API_NO		220100525
+#define PHP_5_5_X_API_NO		220121212
+#define PHP_5_6_X_API_NO		220131226
+
+#define IS_PHP_56 ZEND_EXTENSION_API_NO == PHP_5_6_X_API_NO
+#define IS_AT_LEAST_PHP_56 ZEND_EXTENSION_API_NO >= PHP_5_6_X_API_NO
+
+#define IS_PHP_55 ZEND_EXTENSION_API_NO == PHP_5_5_X_API_NO
+#define IS_AT_LEAST_PHP_55 ZEND_EXTENSION_API_NO >= PHP_5_5_X_API_NO
+
+#define IS_PHP_54 ZEND_EXTENSION_API_NO == PHP_5_4_X_API_NO
+#define IS_AT_LEAST_PHP_54 ZEND_EXTENSION_API_NO >= PHP_5_4_X_API_NO
+
+#define IS_PHP_53 ZEND_EXTENSION_API_NO == PHP_5_3_X_API_NO
+#define IS_AT_LEAST_PHP_53 ZEND_EXTENSION_API_NO >= PHP_5_3_X_API_NO
+
+#if IS_PHP_53
+#define object_properties_init(obj, ce) do { \
+		 zend_hash_copy(obj->properties, &ce->default_properties, zval_copy_property_ctor(ce), NULL, sizeof(zval *)); \
+		} while (0);
+#endif
+
+#define ZEND_OBJ_INIT(obj, ce) do { \
+		zend_object_std_init(obj, ce TSRMLS_CC); \
+		object_properties_init((obj), (ce)); \
+	} while(0);
+
+#if IS_PHP_53 || IS_PHP_54
+static void zend_hash_get_current_key_zval_ex(const HashTable *ht, zval *key, HashPosition *pos) {
+    Bucket *p;
+
+    p = pos ? (*pos) : ht->pInternalPointer;
+
+    if (!p) {
+        Z_TYPE_P(key) = IS_NULL;
+    } else if (p->nKeyLength) {
+        Z_TYPE_P(key) = IS_STRING;
+        Z_STRVAL_P(key) = estrndup(p->arKey, p->nKeyLength - 1);
+        Z_STRLEN_P(key) = p->nKeyLength - 1;
+    } else {
+        Z_TYPE_P(key) = IS_LONG;
+        Z_LVAL_P(key) = p->h;
+    }
+}
+#endif
+
+#endif /* PIMPLE_COMPAT_H_ */
diff --git a/vendor/pimple/pimple/ext/pimple/tests/001.phpt b/vendor/pimple/pimple/ext/pimple/tests/001.phpt
new file mode 100644
index 0000000..0809ea2
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/001.phpt
@@ -0,0 +1,45 @@
+--TEST--
+Test for read_dim/write_dim handlers
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p[42] = 'foo';
+$p['foo'] = 42;
+
+echo $p[42];
+echo "\n";
+echo $p['foo'];
+echo "\n";
+try {
+	var_dump($p['nonexistant']);
+	echo "Exception excpected";
+} catch (InvalidArgumentException $e) { }
+
+$p[54.2] = 'foo2';
+echo $p[54];
+echo "\n";
+$p[242.99] = 'foo99';
+echo $p[242];
+
+echo "\n";
+
+$p[5] = 'bar';
+$p[5] = 'baz';
+echo $p[5];
+
+echo "\n";
+
+$p['str'] = 'str';
+$p['str'] = 'strstr';
+echo $p['str'];
+?>
+
+--EXPECTF--
+foo
+42
+foo2
+foo99
+baz
+strstr
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/002.phpt b/vendor/pimple/pimple/ext/pimple/tests/002.phpt
new file mode 100644
index 0000000..7b56d2c
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/002.phpt
@@ -0,0 +1,15 @@
+--TEST--
+Test for constructor
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+var_dump($p[42]);
+
+$p = new Pimple\Container(array(42=>'foo'));
+var_dump($p[42]);
+?>
+--EXPECT--
+NULL
+string(3) "foo"
diff --git a/vendor/pimple/pimple/ext/pimple/tests/003.phpt b/vendor/pimple/pimple/ext/pimple/tests/003.phpt
new file mode 100644
index 0000000..a22cfa3
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/003.phpt
@@ -0,0 +1,16 @@
+--TEST--
+Test empty dimensions
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p[] = 42;
+var_dump($p[0]);
+$p[41] = 'foo';
+$p[] = 'bar';
+var_dump($p[42]);
+?>
+--EXPECT--
+int(42)
+string(3) "bar"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/004.phpt b/vendor/pimple/pimple/ext/pimple/tests/004.phpt
new file mode 100644
index 0000000..1e1d251
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/004.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Test has/unset dim handlers
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p[] = 42;
+var_dump($p[0]);
+unset($p[0]);
+var_dump($p[0]);
+$p['foo'] = 'bar';
+var_dump(isset($p['foo']));
+unset($p['foo']);
+try {
+	var_dump($p['foo']);
+	echo "Excpected exception";
+} catch (InvalidArgumentException $e) { }
+var_dump(isset($p['bar']));
+$p['bar'] = NULL;
+var_dump(isset($p['bar']));
+var_dump(empty($p['bar']));
+?>
+--EXPECT--
+int(42)
+NULL
+bool(true)
+bool(false)
+bool(true)
+bool(true)
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/005.phpt b/vendor/pimple/pimple/ext/pimple/tests/005.phpt
new file mode 100644
index 0000000..0479ee0
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/005.phpt
@@ -0,0 +1,27 @@
+--TEST--
+Test simple class inheritance
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+class MyPimple extends Pimple\Container
+{
+	public $someAttr = 'fooAttr';
+
+    public function offsetget($o)
+    {
+        var_dump("hit");
+        return parent::offsetget($o);
+    }
+}
+
+$p = new MyPimple;
+$p[42] = 'foo';
+echo $p[42];
+echo "\n";
+echo $p->someAttr;
+?>
+--EXPECT--
+string(3) "hit"
+foo
+fooAttr
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/006.phpt b/vendor/pimple/pimple/ext/pimple/tests/006.phpt
new file mode 100644
index 0000000..cfe8a11
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/006.phpt
@@ -0,0 +1,51 @@
+--TEST--
+Test complex class inheritance
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+class MyPimple extends Pimple\Container
+{
+    public function offsetget($o)
+    {
+        var_dump("hit offsetget in " . __CLASS__);
+        return parent::offsetget($o);
+    }
+}
+
+class TestPimple extends MyPimple
+{
+    public function __construct($values)
+    {
+        array_shift($values);
+        parent::__construct($values);
+    }
+    
+    public function offsetget($o)
+    {
+        var_dump('hit offsetget in ' . __CLASS__);
+        return parent::offsetget($o);
+    }
+    
+    public function offsetset($o, $v)
+    {
+        var_dump('hit offsetset');
+        return parent::offsetset($o, $v);
+    }
+}
+
+$defaultValues = array('foo' => 'bar', 88 => 'baz');
+
+$p = new TestPimple($defaultValues);
+$p[42] = 'foo';
+var_dump($p[42]);
+var_dump($p[0]);
+?>
+--EXPECT--
+string(13) "hit offsetset"
+string(27) "hit offsetget in TestPimple"
+string(25) "hit offsetget in MyPimple"
+string(3) "foo"
+string(27) "hit offsetget in TestPimple"
+string(25) "hit offsetget in MyPimple"
+string(3) "baz"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/007.phpt b/vendor/pimple/pimple/ext/pimple/tests/007.phpt
new file mode 100644
index 0000000..5aac683
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/007.phpt
@@ -0,0 +1,22 @@
+--TEST--
+Test for read_dim/write_dim handlers
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p[42] = 'foo';
+$p['foo'] = 42;
+
+echo $p[42];
+echo "\n";
+echo $p['foo'];
+echo "\n";
+try {
+	var_dump($p['nonexistant']);
+	echo "Exception excpected";
+} catch (InvalidArgumentException $e) { }
+?>
+--EXPECTF--
+foo
+42
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/008.phpt b/vendor/pimple/pimple/ext/pimple/tests/008.phpt
new file mode 100644
index 0000000..db7eeec
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/008.phpt
@@ -0,0 +1,29 @@
+--TEST--
+Test frozen services
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p[42] = 'foo';
+$p[42] = 'bar';
+
+$p['foo'] = function () { };
+$p['foo'] = function () { };
+
+$a = $p['foo'];
+
+try {
+	$p['foo'] = function () { };
+	echo "Exception excpected";
+} catch (RuntimeException $e) { }
+
+$p[42] = function() { };
+$a = $p[42];
+
+try {
+	$p[42] = function () { };
+	echo "Exception excpected";
+} catch (RuntimeException $e) { }
+?>
+--EXPECTF--
diff --git a/vendor/pimple/pimple/ext/pimple/tests/009.phpt b/vendor/pimple/pimple/ext/pimple/tests/009.phpt
new file mode 100644
index 0000000..bb05ea2
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/009.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Test service is called as callback, and only once
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php 
+$p = new Pimple\Container();
+$p['foo'] = function($arg) use ($p) { var_dump($p === $arg); };
+$a = $p['foo'];
+$b = $p['foo']; /* should return not calling the callback */
+?>
+--EXPECTF--
+bool(true)
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/010.phpt b/vendor/pimple/pimple/ext/pimple/tests/010.phpt
new file mode 100644
index 0000000..badce01
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/010.phpt
@@ -0,0 +1,45 @@
+--TEST--
+Test service is called as callback for every callback type
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+function callme()
+{
+    return 'called';
+}
+
+$a = function() { return 'called'; };
+
+class Foo
+{
+    public static function bar()
+    {
+        return 'called';
+    }
+}
+ 
+$p = new Pimple\Container();
+$p['foo'] = 'callme';
+echo $p['foo'] . "\n";
+
+$p['bar'] = $a;
+echo $p['bar'] . "\n";
+
+$p['baz'] = "Foo::bar";
+echo $p['baz'] . "\n";
+
+$p['foobar'] = array('Foo', 'bar');
+var_dump($p['foobar']);
+
+?>
+--EXPECTF--
+callme
+called
+Foo::bar
+array(2) {
+  [0]=>
+  string(3) "Foo"
+  [1]=>
+  string(3) "bar"
+}
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/011.phpt b/vendor/pimple/pimple/ext/pimple/tests/011.phpt
new file mode 100644
index 0000000..6682ab8
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/011.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Test service callback throwing an exception
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+class CallBackException extends RuntimeException { }
+
+$p = new Pimple\Container();
+$p['foo'] = function () { throw new CallBackException; };
+try {
+	echo $p['foo'] . "\n";
+	echo "should not come here";
+} catch (CallBackException $e) {
+	echo "all right!";
+}
+?>
+--EXPECTF--
+all right!
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/012.phpt b/vendor/pimple/pimple/ext/pimple/tests/012.phpt
new file mode 100644
index 0000000..4c6ac48
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/012.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Test service factory
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+
+$p->factory($f = function() { var_dump('called-1'); return 'ret-1';});
+
+$p[] = $f;
+
+$p[] = function () { var_dump('called-2'); return 'ret-2'; };
+
+var_dump($p[0]);
+var_dump($p[0]);
+var_dump($p[1]);
+var_dump($p[1]);
+?>
+--EXPECTF--
+string(8) "called-1"
+string(5) "ret-1"
+string(8) "called-1"
+string(5) "ret-1"
+string(8) "called-2"
+string(5) "ret-2"
+string(5) "ret-2"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/013.phpt b/vendor/pimple/pimple/ext/pimple/tests/013.phpt
new file mode 100644
index 0000000..f419958
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/013.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Test keys()
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+
+var_dump($p->keys());
+
+$p['foo'] = 'bar';
+$p[] = 'foo';
+
+var_dump($p->keys());
+
+unset($p['foo']);
+
+var_dump($p->keys());
+?>
+--EXPECTF--
+array(0) {
+}
+array(2) {
+  [0]=>
+  string(3) "foo"
+  [1]=>
+  int(0)
+}
+array(1) {
+  [0]=>
+  int(0)
+}
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/014.phpt b/vendor/pimple/pimple/ext/pimple/tests/014.phpt
new file mode 100644
index 0000000..ac93721
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/014.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Test raw()
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+$f = function () { var_dump('called-2'); return 'ret-2'; };
+
+$p['foo'] = $f;
+$p[42]    = $f;
+
+var_dump($p['foo']);
+var_dump($p->raw('foo'));
+var_dump($p[42]);
+
+unset($p['foo']);
+
+try {
+	$p->raw('foo');
+	echo "expected exception";
+} catch (InvalidArgumentException $e) { }
+--EXPECTF--
+string(8) "called-2"
+string(5) "ret-2"
+object(Closure)#%i (0) {
+}
+string(8) "called-2"
+string(5) "ret-2"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/015.phpt b/vendor/pimple/pimple/ext/pimple/tests/015.phpt
new file mode 100644
index 0000000..314f008
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/015.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Test protect()
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+$f = function () { return 'foo'; };
+$p['foo'] = $f;
+
+$p->protect($f);
+
+var_dump($p['foo']);
+--EXPECTF--
+object(Closure)#%i (0) {
+}
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/016.phpt b/vendor/pimple/pimple/ext/pimple/tests/016.phpt
new file mode 100644
index 0000000..e55edb0
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/016.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Test extend()
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+/*
+ This is part of Pimple::extend() code :
+
+          $extended = function ($c) use ($callable, $factory) {
+             return $callable($factory($c), $c);
+          };
+*/
+
+$p = new Pimple\Container();
+$p[12] = function ($v) { var_dump($v); return 'foo';}; /* $factory in code above */
+
+$c = $p->extend(12, function ($w) { var_dump($w); return 'bar'; }); /* $callable in code above */
+
+var_dump($c('param'));
+--EXPECTF--
+string(5) "param"
+string(3) "foo"
+string(3) "bar"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/017.phpt b/vendor/pimple/pimple/ext/pimple/tests/017.phpt
new file mode 100644
index 0000000..bac23ce
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/017.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Test extend() with exception in service extension
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+$p[12] = function ($v) { return 'foo';};
+
+$c = $p->extend(12, function ($w) { throw new BadMethodCallException; });
+
+try {
+	$p[12];
+	echo "Exception expected";
+} catch (BadMethodCallException $e) { }
+--EXPECTF--
diff --git a/vendor/pimple/pimple/ext/pimple/tests/017_1.phpt b/vendor/pimple/pimple/ext/pimple/tests/017_1.phpt
new file mode 100644
index 0000000..8f881d6
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/017_1.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Test extend() with exception in service factory
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+$p = new Pimple\Container();
+$p[12] = function ($v) { throw new BadMethodCallException; };
+
+$c = $p->extend(12, function ($w) { return 'foobar'; });
+
+try {
+	$p[12];
+	echo "Exception expected";
+} catch (BadMethodCallException $e) { }
+--EXPECTF--
diff --git a/vendor/pimple/pimple/ext/pimple/tests/018.phpt b/vendor/pimple/pimple/ext/pimple/tests/018.phpt
new file mode 100644
index 0000000..27c12a1
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/018.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Test register()
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+class Foo implements Pimple\ServiceProviderInterface
+{
+    public function register(Pimple\Container $p)
+    {
+        var_dump($p);
+    }
+}
+
+$p = new Pimple\Container();
+$p->register(new Foo, array(42 => 'bar'));
+
+var_dump($p[42]);
+--EXPECTF--
+object(Pimple\Container)#1 (0) {
+}
+string(3) "bar"
\ No newline at end of file
diff --git a/vendor/pimple/pimple/ext/pimple/tests/019.phpt b/vendor/pimple/pimple/ext/pimple/tests/019.phpt
new file mode 100644
index 0000000..28a9aec
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/019.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Test register() returns static and is a fluent interface
+--SKIPIF--
+<?php if (!extension_loaded("pimple")) print "skip"; ?>
+--FILE--
+<?php
+
+class Foo implements Pimple\ServiceProviderInterface
+{
+    public function register(Pimple\Container $p)
+    {
+    }
+}
+
+$p = new Pimple\Container();
+var_dump($p === $p->register(new Foo));
+--EXPECTF--
+bool(true)
diff --git a/vendor/pimple/pimple/ext/pimple/tests/bench.phpb b/vendor/pimple/pimple/ext/pimple/tests/bench.phpb
new file mode 100644
index 0000000..8f983e6
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/bench.phpb
@@ -0,0 +1,51 @@
+<?php
+
+if (!class_exists('Pimple\Container')) {
+    require_once __DIR__ . '/../../../src/Pimple/Container.php';
+} else {
+    echo "pimple-c extension detected, using...\n\n";
+}
+
+$time = microtime(true);
+
+function foo() { }
+$factory = function () { };
+
+for ($i=0; $i<10000; $i++) {
+
+$p = new Pimple\Container;
+
+$p['foo'] = 'bar';
+
+if (!isset($p[3])) {
+    $p[3] = $p['foo'];
+    $p[]  = 'bar';
+}
+
+$p[2] = 42;
+
+if (isset($p[2])) {
+	unset($p[2]);
+}
+
+$p[42] = $p['foo'];
+
+$p['cb'] = function($arg) { };
+
+$p[] = $p['cb'];
+
+echo $p['cb'];
+echo $p['cb'];
+echo $p['cb'];
+
+//$p->factory($factory);
+
+$p['factory'] = $factory;
+
+echo $p['factory'];
+echo $p['factory'];
+echo $p['factory'];
+
+}
+
+echo microtime(true)  - $time;
diff --git a/vendor/pimple/pimple/ext/pimple/tests/bench_shared.phpb b/vendor/pimple/pimple/ext/pimple/tests/bench_shared.phpb
new file mode 100644
index 0000000..aec541f
--- /dev/null
+++ b/vendor/pimple/pimple/ext/pimple/tests/bench_shared.phpb
@@ -0,0 +1,25 @@
+<?php
+
+if (!class_exists('Pimple\Container')) {
+    require_once __DIR__ . '/../../../src/Pimple/Container.php';
+} else {
+    echo "pimple-c extension detected, using...\n\n";
+}
+
+$time = microtime(true);
+
+
+$service = function ($arg) { return "I'm a service"; };
+
+for ($i=0; $i<10000; $i++) {
+
+$p = new Pimple\Container;
+$p['my_service'] = $service;
+
+$a = $p['my_service'];
+$b = $p['my_service'];
+
+}
+
+echo microtime(true) - $time;
+?>
diff --git a/vendor/pimple/pimple/phpunit.xml.dist b/vendor/pimple/pimple/phpunit.xml.dist
new file mode 100644
index 0000000..5c8d487
--- /dev/null
+++ b/vendor/pimple/pimple/phpunit.xml.dist
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
+         backupGlobals="false"
+         colors="true"
+         bootstrap="vendor/autoload.php"
+>
+    <testsuites>
+        <testsuite name="Pimple Test Suite">
+            <directory>./src/Pimple/Tests</directory>
+        </testsuite>
+    </testsuites>
+</phpunit>
diff --git a/vendor/pimple/pimple/src/Pimple/Container.php b/vendor/pimple/pimple/src/Pimple/Container.php
new file mode 100644
index 0000000..c976431
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Container.php
@@ -0,0 +1,282 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple;
+
+/**
+ * Container main class.
+ *
+ * @author  Fabien Potencier
+ */
+class Container implements \ArrayAccess
+{
+    private $values = array();
+    private $factories;
+    private $protected;
+    private $frozen = array();
+    private $raw = array();
+    private $keys = array();
+
+    /**
+     * Instantiate the container.
+     *
+     * Objects and parameters can be passed as argument to the constructor.
+     *
+     * @param array $values The parameters or objects.
+     */
+    public function __construct(array $values = array())
+    {
+        $this->factories = new \SplObjectStorage();
+        $this->protected = new \SplObjectStorage();
+
+        foreach ($values as $key => $value) {
+            $this->offsetSet($key, $value);
+        }
+    }
+
+    /**
+     * Sets a parameter or an object.
+     *
+     * Objects must be defined as Closures.
+     *
+     * Allowing any PHP callable leads to difficult to debug problems
+     * as function names (strings) are callable (creating a function with
+     * the same name as an existing parameter would break your container).
+     *
+     * @param string $id    The unique identifier for the parameter or object
+     * @param mixed  $value The value of the parameter or a closure to define an object
+     *
+     * @throws \RuntimeException Prevent override of a frozen service
+     */
+    public function offsetSet($id, $value)
+    {
+        if (isset($this->frozen[$id])) {
+            throw new \RuntimeException(sprintf('Cannot override frozen service "%s".', $id));
+        }
+
+        $this->values[$id] = $value;
+        $this->keys[$id] = true;
+    }
+
+    /**
+     * Gets a parameter or an object.
+     *
+     * @param string $id The unique identifier for the parameter or object
+     *
+     * @return mixed The value of the parameter or an object
+     *
+     * @throws \InvalidArgumentException if the identifier is not defined
+     */
+    public function offsetGet($id)
+    {
+        if (!isset($this->keys[$id])) {
+            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
+        }
+
+        if (
+            isset($this->raw[$id])
+            || !is_object($this->values[$id])
+            || isset($this->protected[$this->values[$id]])
+            || !method_exists($this->values[$id], '__invoke')
+        ) {
+            return $this->values[$id];
+        }
+
+        if (isset($this->factories[$this->values[$id]])) {
+            return $this->values[$id]($this);
+        }
+
+        $raw = $this->values[$id];
+        $val = $this->values[$id] = $raw($this);
+        $this->raw[$id] = $raw;
+
+        $this->frozen[$id] = true;
+
+        return $val;
+    }
+
+    /**
+     * Checks if a parameter or an object is set.
+     *
+     * @param string $id The unique identifier for the parameter or object
+     *
+     * @return bool
+     */
+    public function offsetExists($id)
+    {
+        return isset($this->keys[$id]);
+    }
+
+    /**
+     * Unsets a parameter or an object.
+     *
+     * @param string $id The unique identifier for the parameter or object
+     */
+    public function offsetUnset($id)
+    {
+        if (isset($this->keys[$id])) {
+            if (is_object($this->values[$id])) {
+                unset($this->factories[$this->values[$id]], $this->protected[$this->values[$id]]);
+            }
+
+            unset($this->values[$id], $this->frozen[$id], $this->raw[$id], $this->keys[$id]);
+        }
+    }
+
+    /**
+     * Marks a callable as being a factory service.
+     *
+     * @param callable $callable A service definition to be used as a factory
+     *
+     * @return callable The passed callable
+     *
+     * @throws \InvalidArgumentException Service definition has to be a closure of an invokable object
+     */
+    public function factory($callable)
+    {
+        if (!method_exists($callable, '__invoke')) {
+            throw new \InvalidArgumentException('Service definition is not a Closure or invokable object.');
+        }
+
+        $this->factories->attach($callable);
+
+        return $callable;
+    }
+
+    /**
+     * Protects a callable from being interpreted as a service.
+     *
+     * This is useful when you want to store a callable as a parameter.
+     *
+     * @param callable $callable A callable to protect from being evaluated
+     *
+     * @return callable The passed callable
+     *
+     * @throws \InvalidArgumentException Service definition has to be a closure of an invokable object
+     */
+    public function protect($callable)
+    {
+        if (!method_exists($callable, '__invoke')) {
+            throw new \InvalidArgumentException('Callable is not a Closure or invokable object.');
+        }
+
+        $this->protected->attach($callable);
+
+        return $callable;
+    }
+
+    /**
+     * Gets a parameter or the closure defining an object.
+     *
+     * @param string $id The unique identifier for the parameter or object
+     *
+     * @return mixed The value of the parameter or the closure defining an object
+     *
+     * @throws \InvalidArgumentException if the identifier is not defined
+     */
+    public function raw($id)
+    {
+        if (!isset($this->keys[$id])) {
+            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
+        }
+
+        if (isset($this->raw[$id])) {
+            return $this->raw[$id];
+        }
+
+        return $this->values[$id];
+    }
+
+    /**
+     * Extends an object definition.
+     *
+     * Useful when you want to extend an existing object definition,
+     * without necessarily loading that object.
+     *
+     * @param string   $id       The unique identifier for the object
+     * @param callable $callable A service definition to extend the original
+     *
+     * @return callable The wrapped callable
+     *
+     * @throws \InvalidArgumentException if the identifier is not defined or not a service definition
+     */
+    public function extend($id, $callable)
+    {
+        if (!isset($this->keys[$id])) {
+            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
+        }
+
+        if (!is_object($this->values[$id]) || !method_exists($this->values[$id], '__invoke')) {
+            throw new \InvalidArgumentException(sprintf('Identifier "%s" does not contain an object definition.', $id));
+        }
+
+        if (!is_object($callable) || !method_exists($callable, '__invoke')) {
+            throw new \InvalidArgumentException('Extension service definition is not a Closure or invokable object.');
+        }
+
+        $factory = $this->values[$id];
+
+        $extended = function ($c) use ($callable, $factory) {
+            return $callable($factory($c), $c);
+        };
+
+        if (isset($this->factories[$factory])) {
+            $this->factories->detach($factory);
+            $this->factories->attach($extended);
+        }
+
+        return $this[$id] = $extended;
+    }
+
+    /**
+     * Returns all defined value names.
+     *
+     * @return array An array of value names
+     */
+    public function keys()
+    {
+        return array_keys($this->values);
+    }
+
+    /**
+     * Registers a service provider.
+     *
+     * @param ServiceProviderInterface $provider A ServiceProviderInterface instance
+     * @param array                    $values   An array of values that customizes the provider
+     *
+     * @return static
+     */
+    public function register(ServiceProviderInterface $provider, array $values = array())
+    {
+        $provider->register($this);
+
+        foreach ($values as $key => $value) {
+            $this[$key] = $value;
+        }
+
+        return $this;
+    }
+}
diff --git a/vendor/pimple/pimple/src/Pimple/ServiceProviderInterface.php b/vendor/pimple/pimple/src/Pimple/ServiceProviderInterface.php
new file mode 100644
index 0000000..c004594
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/ServiceProviderInterface.php
@@ -0,0 +1,46 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple;
+
+/**
+ * Pimple service provider interface.
+ *
+ * @author  Fabien Potencier
+ * @author  Dominik Zogg
+ */
+interface ServiceProviderInterface
+{
+    /**
+     * Registers services on the given container.
+     *
+     * This method should only be used to configure services and parameters.
+     * It should not get services.
+     *
+     * @param Container $pimple A container instance
+     */
+    public function register(Container $pimple);
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Invokable.php b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Invokable.php
new file mode 100644
index 0000000..aba453b
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Invokable.php
@@ -0,0 +1,38 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests\Fixtures;
+
+class Invokable
+{
+    public function __invoke($value = null)
+    {
+        $service = new Service();
+        $service->value = $value;
+
+        return $service;
+    }
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/NonInvokable.php b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/NonInvokable.php
new file mode 100644
index 0000000..33cd4e5
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/NonInvokable.php
@@ -0,0 +1,34 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests\Fixtures;
+
+class NonInvokable
+{
+    public function __call($a, $b)
+    {
+    }
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/PimpleServiceProvider.php b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/PimpleServiceProvider.php
new file mode 100644
index 0000000..0c910af
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/PimpleServiceProvider.php
@@ -0,0 +1,54 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests\Fixtures;
+
+use Pimple\Container;
+use Pimple\ServiceProviderInterface;
+
+class PimpleServiceProvider implements ServiceProviderInterface
+{
+    /**
+     * Registers services on the given container.
+     *
+     * This method should only be used to configure services and parameters.
+     * It should not get services.
+     *
+     * @param Container $pimple An Container instance
+     */
+    public function register(Container $pimple)
+    {
+        $pimple['param'] = 'value';
+
+        $pimple['service'] = function () {
+            return new Service();
+        };
+
+        $pimple['factory'] = $pimple->factory(function () {
+            return new Service();
+        });
+    }
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Service.php b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Service.php
new file mode 100644
index 0000000..d71b184
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/Fixtures/Service.php
@@ -0,0 +1,35 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests\Fixtures;
+
+/**
+ * @author  Igor Wiedler <igor@wiedler.ch>
+ */
+class Service
+{
+    public $value;
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/PimpleServiceProviderInterfaceTest.php b/vendor/pimple/pimple/src/Pimple/Tests/PimpleServiceProviderInterfaceTest.php
new file mode 100644
index 0000000..8e5c4c7
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/PimpleServiceProviderInterfaceTest.php
@@ -0,0 +1,76 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests;
+
+use Pimple\Container;
+
+/**
+ * @author  Dominik Zogg <dominik.zogg@gmail.com>
+ */
+class PimpleServiceProviderInterfaceTest extends \PHPUnit_Framework_TestCase
+{
+    public function testProvider()
+    {
+        $pimple = new Container();
+
+        $pimpleServiceProvider = new Fixtures\PimpleServiceProvider();
+        $pimpleServiceProvider->register($pimple);
+
+        $this->assertEquals('value', $pimple['param']);
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $pimple['service']);
+
+        $serviceOne = $pimple['factory'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+
+        $serviceTwo = $pimple['factory'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+
+        $this->assertNotSame($serviceOne, $serviceTwo);
+    }
+
+    public function testProviderWithRegisterMethod()
+    {
+        $pimple = new Container();
+
+        $pimple->register(new Fixtures\PimpleServiceProvider(), array(
+            'anotherParameter' => 'anotherValue',
+        ));
+
+        $this->assertEquals('value', $pimple['param']);
+        $this->assertEquals('anotherValue', $pimple['anotherParameter']);
+
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $pimple['service']);
+
+        $serviceOne = $pimple['factory'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+
+        $serviceTwo = $pimple['factory'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+
+        $this->assertNotSame($serviceOne, $serviceTwo);
+    }
+}
diff --git a/vendor/pimple/pimple/src/Pimple/Tests/PimpleTest.php b/vendor/pimple/pimple/src/Pimple/Tests/PimpleTest.php
new file mode 100644
index 0000000..918f620
--- /dev/null
+++ b/vendor/pimple/pimple/src/Pimple/Tests/PimpleTest.php
@@ -0,0 +1,440 @@
+<?php
+
+/*
+ * This file is part of Pimple.
+ *
+ * Copyright (c) 2009 Fabien Potencier
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is furnished
+ * to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+namespace Pimple\Tests;
+
+use Pimple\Container;
+
+/**
+ * @author  Igor Wiedler <igor@wiedler.ch>
+ */
+class PimpleTest extends \PHPUnit_Framework_TestCase
+{
+    public function testWithString()
+    {
+        $pimple = new Container();
+        $pimple['param'] = 'value';
+
+        $this->assertEquals('value', $pimple['param']);
+    }
+
+    public function testWithClosure()
+    {
+        $pimple = new Container();
+        $pimple['service'] = function () {
+            return new Fixtures\Service();
+        };
+
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $pimple['service']);
+    }
+
+    public function testServicesShouldBeDifferent()
+    {
+        $pimple = new Container();
+        $pimple['service'] = $pimple->factory(function () {
+            return new Fixtures\Service();
+        });
+
+        $serviceOne = $pimple['service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+
+        $serviceTwo = $pimple['service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+
+        $this->assertNotSame($serviceOne, $serviceTwo);
+    }
+
+    public function testShouldPassContainerAsParameter()
+    {
+        $pimple = new Container();
+        $pimple['service'] = function () {
+            return new Fixtures\Service();
+        };
+        $pimple['container'] = function ($container) {
+            return $container;
+        };
+
+        $this->assertNotSame($pimple, $pimple['service']);
+        $this->assertSame($pimple, $pimple['container']);
+    }
+
+    public function testIsset()
+    {
+        $pimple = new Container();
+        $pimple['param'] = 'value';
+        $pimple['service'] = function () {
+            return new Fixtures\Service();
+        };
+
+        $pimple['null'] = null;
+
+        $this->assertTrue(isset($pimple['param']));
+        $this->assertTrue(isset($pimple['service']));
+        $this->assertTrue(isset($pimple['null']));
+        $this->assertFalse(isset($pimple['non_existent']));
+    }
+
+    public function testConstructorInjection()
+    {
+        $params = array('param' => 'value');
+        $pimple = new Container($params);
+
+        $this->assertSame($params['param'], $pimple['param']);
+    }
+
+    /**
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Identifier "foo" is not defined.
+     */
+    public function testOffsetGetValidatesKeyIsPresent()
+    {
+        $pimple = new Container();
+        echo $pimple['foo'];
+    }
+
+    public function testOffsetGetHonorsNullValues()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = null;
+        $this->assertNull($pimple['foo']);
+    }
+
+    public function testUnset()
+    {
+        $pimple = new Container();
+        $pimple['param'] = 'value';
+        $pimple['service'] = function () {
+            return new Fixtures\Service();
+        };
+
+        unset($pimple['param'], $pimple['service']);
+        $this->assertFalse(isset($pimple['param']));
+        $this->assertFalse(isset($pimple['service']));
+    }
+
+    /**
+     * @dataProvider serviceDefinitionProvider
+     */
+    public function testShare($service)
+    {
+        $pimple = new Container();
+        $pimple['shared_service'] = $service;
+
+        $serviceOne = $pimple['shared_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+
+        $serviceTwo = $pimple['shared_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+
+        $this->assertSame($serviceOne, $serviceTwo);
+    }
+
+    /**
+     * @dataProvider serviceDefinitionProvider
+     */
+    public function testProtect($service)
+    {
+        $pimple = new Container();
+        $pimple['protected'] = $pimple->protect($service);
+
+        $this->assertSame($service, $pimple['protected']);
+    }
+
+    public function testGlobalFunctionNameAsParameterValue()
+    {
+        $pimple = new Container();
+        $pimple['global_function'] = 'strlen';
+        $this->assertSame('strlen', $pimple['global_function']);
+    }
+
+    public function testRaw()
+    {
+        $pimple = new Container();
+        $pimple['service'] = $definition = $pimple->factory(function () { return 'foo'; });
+        $this->assertSame($definition, $pimple->raw('service'));
+    }
+
+    public function testRawHonorsNullValues()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = null;
+        $this->assertNull($pimple->raw('foo'));
+    }
+
+    public function testFluentRegister()
+    {
+        $pimple = new Container();
+        $this->assertSame($pimple, $pimple->register($this->getMock('Pimple\ServiceProviderInterface')));
+    }
+
+    /**
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Identifier "foo" is not defined.
+     */
+    public function testRawValidatesKeyIsPresent()
+    {
+        $pimple = new Container();
+        $pimple->raw('foo');
+    }
+
+    /**
+     * @dataProvider serviceDefinitionProvider
+     */
+    public function testExtend($service)
+    {
+        $pimple = new Container();
+        $pimple['shared_service'] = function () {
+            return new Fixtures\Service();
+        };
+        $pimple['factory_service'] = $pimple->factory(function () {
+            return new Fixtures\Service();
+        });
+
+        $pimple->extend('shared_service', $service);
+        $serviceOne = $pimple['shared_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+        $serviceTwo = $pimple['shared_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+        $this->assertSame($serviceOne, $serviceTwo);
+        $this->assertSame($serviceOne->value, $serviceTwo->value);
+
+        $pimple->extend('factory_service', $service);
+        $serviceOne = $pimple['factory_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceOne);
+        $serviceTwo = $pimple['factory_service'];
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $serviceTwo);
+        $this->assertNotSame($serviceOne, $serviceTwo);
+        $this->assertNotSame($serviceOne->value, $serviceTwo->value);
+    }
+
+    public function testExtendDoesNotLeakWithFactories()
+    {
+        if (extension_loaded('pimple')) {
+            $this->markTestSkipped('Pimple extension does not support this test');
+        }
+        $pimple = new Container();
+
+        $pimple['foo'] = $pimple->factory(function () { return; });
+        $pimple['foo'] = $pimple->extend('foo', function ($foo, $pimple) { return; });
+        unset($pimple['foo']);
+
+        $p = new \ReflectionProperty($pimple, 'values');
+        $p->setAccessible(true);
+        $this->assertEmpty($p->getValue($pimple));
+
+        $p = new \ReflectionProperty($pimple, 'factories');
+        $p->setAccessible(true);
+        $this->assertCount(0, $p->getValue($pimple));
+    }
+
+    /**
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Identifier "foo" is not defined.
+     */
+    public function testExtendValidatesKeyIsPresent()
+    {
+        $pimple = new Container();
+        $pimple->extend('foo', function () {});
+    }
+
+    public function testKeys()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = 123;
+        $pimple['bar'] = 123;
+
+        $this->assertEquals(array('foo', 'bar'), $pimple->keys());
+    }
+
+    /** @test */
+    public function settingAnInvokableObjectShouldTreatItAsFactory()
+    {
+        $pimple = new Container();
+        $pimple['invokable'] = new Fixtures\Invokable();
+
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\Service', $pimple['invokable']);
+    }
+
+    /** @test */
+    public function settingNonInvokableObjectShouldTreatItAsParameter()
+    {
+        $pimple = new Container();
+        $pimple['non_invokable'] = new Fixtures\NonInvokable();
+
+        $this->assertInstanceOf('Pimple\Tests\Fixtures\NonInvokable', $pimple['non_invokable']);
+    }
+
+    /**
+     * @dataProvider badServiceDefinitionProvider
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Service definition is not a Closure or invokable object.
+     */
+    public function testFactoryFailsForInvalidServiceDefinitions($service)
+    {
+        $pimple = new Container();
+        $pimple->factory($service);
+    }
+
+    /**
+     * @dataProvider badServiceDefinitionProvider
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Callable is not a Closure or invokable object.
+     */
+    public function testProtectFailsForInvalidServiceDefinitions($service)
+    {
+        $pimple = new Container();
+        $pimple->protect($service);
+    }
+
+    /**
+     * @dataProvider badServiceDefinitionProvider
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Identifier "foo" does not contain an object definition.
+     */
+    public function testExtendFailsForKeysNotContainingServiceDefinitions($service)
+    {
+        $pimple = new Container();
+        $pimple['foo'] = $service;
+        $pimple->extend('foo', function () {});
+    }
+
+    /**
+     * @dataProvider badServiceDefinitionProvider
+     * @expectedException \InvalidArgumentException
+     * @expectedExceptionMessage Extension service definition is not a Closure or invokable object.
+     */
+    public function testExtendFailsForInvalidServiceDefinitions($service)
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {};
+        $pimple->extend('foo', $service);
+    }
+
+    /**
+     * Provider for invalid service definitions.
+     */
+    public function badServiceDefinitionProvider()
+    {
+        return array(
+          array(123),
+          array(new Fixtures\NonInvokable()),
+        );
+    }
+
+    /**
+     * Provider for service definitions.
+     */
+    public function serviceDefinitionProvider()
+    {
+        return array(
+            array(function ($value) {
+                $service = new Fixtures\Service();
+                $service->value = $value;
+
+                return $service;
+            }),
+            array(new Fixtures\Invokable()),
+        );
+    }
+
+    public function testDefiningNewServiceAfterFreeze()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {
+            return 'foo';
+        };
+        $foo = $pimple['foo'];
+
+        $pimple['bar'] = function () {
+            return 'bar';
+        };
+        $this->assertSame('bar', $pimple['bar']);
+    }
+
+    /**
+     * @expectedException \RuntimeException
+     * @expectedExceptionMessage Cannot override frozen service "foo".
+     */
+    public function testOverridingServiceAfterFreeze()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {
+            return 'foo';
+        };
+        $foo = $pimple['foo'];
+
+        $pimple['foo'] = function () {
+            return 'bar';
+        };
+    }
+
+    public function testRemovingServiceAfterFreeze()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {
+            return 'foo';
+        };
+        $foo = $pimple['foo'];
+
+        unset($pimple['foo']);
+        $pimple['foo'] = function () {
+            return 'bar';
+        };
+        $this->assertSame('bar', $pimple['foo']);
+    }
+
+    public function testExtendingService()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {
+            return 'foo';
+        };
+        $pimple['foo'] = $pimple->extend('foo', function ($foo, $app) {
+            return "$foo.bar";
+        });
+        $pimple['foo'] = $pimple->extend('foo', function ($foo, $app) {
+            return "$foo.baz";
+        });
+        $this->assertSame('foo.bar.baz', $pimple['foo']);
+    }
+
+    public function testExtendingServiceAfterOtherServiceFreeze()
+    {
+        $pimple = new Container();
+        $pimple['foo'] = function () {
+            return 'foo';
+        };
+        $pimple['bar'] = function () {
+            return 'bar';
+        };
+        $foo = $pimple['foo'];
+
+        $pimple['bar'] = $pimple->extend('bar', function ($bar, $app) {
+            return "$bar.baz";
+        });
+        $this->assertSame('bar.baz', $pimple['bar']);
+    }
+}
diff --git a/vendor/psr/container/.gitignore b/vendor/psr/container/.gitignore
new file mode 100644
index 0000000..b2395aa
--- /dev/null
+++ b/vendor/psr/container/.gitignore
@@ -0,0 +1,3 @@
+composer.lock
+composer.phar
+/vendor/
diff --git a/vendor/psr/container/LICENSE b/vendor/psr/container/LICENSE
new file mode 100644
index 0000000..2877a48
--- /dev/null
+++ b/vendor/psr/container/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2013-2016 container-interop
+Copyright (c) 2016 PHP Framework Interoperability Group
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/psr/container/README.md b/vendor/psr/container/README.md
new file mode 100644
index 0000000..084f6df
--- /dev/null
+++ b/vendor/psr/container/README.md
@@ -0,0 +1,5 @@
+# PSR Container
+
+This repository holds all interfaces/classes/traits related to [PSR-11](https://github.com/container-interop/fig-standards/blob/master/proposed/container.md).
+
+Note that this is not a container implementation of its own. See the specification for more details.
diff --git a/vendor/psr/container/composer.json b/vendor/psr/container/composer.json
new file mode 100644
index 0000000..b8ee012
--- /dev/null
+++ b/vendor/psr/container/composer.json
@@ -0,0 +1,27 @@
+{
+    "name": "psr/container",
+    "type": "library",
+    "description": "Common Container Interface (PHP FIG PSR-11)",
+    "keywords": ["psr", "psr-11", "container", "container-interop", "container-interface"],
+    "homepage": "https://github.com/php-fig/container",
+    "license": "MIT",
+    "authors": [
+        {
+            "name": "PHP-FIG",
+            "homepage": "http://www.php-fig.org/"
+        }
+    ],
+    "require": {
+        "php": ">=5.3.0"
+    },
+    "autoload": {
+        "psr-4": {
+            "Psr\\Container\\": "src/"
+        }
+    },
+    "extra": {
+        "branch-alias": {
+            "dev-master": "1.0.x-dev"
+        }
+    }
+}
diff --git a/vendor/psr/container/src/ContainerExceptionInterface.php b/vendor/psr/container/src/ContainerExceptionInterface.php
new file mode 100644
index 0000000..d35c6b4
--- /dev/null
+++ b/vendor/psr/container/src/ContainerExceptionInterface.php
@@ -0,0 +1,13 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Psr\Container;
+
+/**
+ * Base interface representing a generic exception in a container.
+ */
+interface ContainerExceptionInterface
+{
+}
diff --git a/vendor/psr/container/src/ContainerInterface.php b/vendor/psr/container/src/ContainerInterface.php
new file mode 100644
index 0000000..c3a7206
--- /dev/null
+++ b/vendor/psr/container/src/ContainerInterface.php
@@ -0,0 +1,37 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Psr\Container;
+
+/**
+ * Describes the interface of a container that exposes methods to read its entries.
+ */
+interface ContainerInterface
+{
+    /**
+     * Finds an entry of the container by its identifier and returns it.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @throws NotFoundExceptionInterface  No entry was found for **this** identifier.
+     * @throws ContainerExceptionInterface Error while retrieving the entry.
+     *
+     * @return mixed Entry.
+     */
+    public function get($id);
+
+    /**
+     * Returns true if the container can return an entry for the given identifier.
+     * Returns false otherwise.
+     *
+     * `has($id)` returning true does not mean that `get($id)` will not throw an exception.
+     * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @return bool
+     */
+    public function has($id);
+}
diff --git a/vendor/psr/container/src/NotFoundExceptionInterface.php b/vendor/psr/container/src/NotFoundExceptionInterface.php
new file mode 100644
index 0000000..6566704
--- /dev/null
+++ b/vendor/psr/container/src/NotFoundExceptionInterface.php
@@ -0,0 +1,13 @@
+<?php
+/**
+ * @license http://www.opensource.org/licenses/mit-license.php MIT (see the LICENSE file)
+ */
+
+namespace Psr\Container;
+
+/**
+ * No entry was found in the container.
+ */
+interface NotFoundExceptionInterface extends ContainerExceptionInterface
+{
+}
diff --git a/vendor/psr/http-message/CHANGELOG.md b/vendor/psr/http-message/CHANGELOG.md
new file mode 100644
index 0000000..74b1ef9
--- /dev/null
+++ b/vendor/psr/http-message/CHANGELOG.md
@@ -0,0 +1,36 @@
+# Changelog
+
+All notable changes to this project will be documented in this file, in reverse chronological order by release.
+
+## 1.0.1 - 2016-08-06
+
+### Added
+
+- Nothing.
+
+### Deprecated
+
+- Nothing.
+
+### Removed
+
+- Nothing.
+
+### Fixed
+
+- Updated all `@return self` annotation references in interfaces to use
+  `@return static`, which more closelly follows the semantics of the
+  specification.
+- Updated the `MessageInterface::getHeaders()` return annotation to use the
+  value `string[][]`, indicating the format is a nested array of strings.
+- Updated the `@link` annotation for `RequestInterface::withRequestTarget()`
+  to point to the correct section of RFC 7230.
+- Updated the `ServerRequestInterface::withUploadedFiles()` parameter annotation
+  to add the parameter name (`$uploadedFiles`).
+- Updated a `@throws` annotation for the `UploadedFileInterface::moveTo()`
+  method to correctly reference the method parameter (it was referencing an
+  incorrect parameter name previously).
+
+## 1.0.0 - 2016-05-18
+
+Initial stable release; reflects accepted PSR-7 specification.
diff --git a/vendor/psr/http-message/LICENSE b/vendor/psr/http-message/LICENSE
new file mode 100644
index 0000000..c2d8e45
--- /dev/null
+++ b/vendor/psr/http-message/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2014 PHP Framework Interoperability Group
+
+Permission is hereby granted, free of charge, to any person obtaining a copy 
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights 
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
+copies of the Software, and to permit persons to whom the Software is 
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in 
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/vendor/psr/http-message/README.md b/vendor/psr/http-message/README.md
new file mode 100644
index 0000000..2818533
--- /dev/null
+++ b/vendor/psr/http-message/README.md
@@ -0,0 +1,13 @@
+PSR Http Message
+================
+
+This repository holds all interfaces/classes/traits related to
+[PSR-7](http://www.php-fig.org/psr/psr-7/).
+
+Note that this is not a HTTP message implementation of its own. It is merely an
+interface that describes a HTTP message. See the specification for more details.
+
+Usage
+-----
+
+We'll certainly need some stuff in here.
\ No newline at end of file
diff --git a/vendor/psr/http-message/composer.json b/vendor/psr/http-message/composer.json
new file mode 100644
index 0000000..b0d2937
--- /dev/null
+++ b/vendor/psr/http-message/composer.json
@@ -0,0 +1,26 @@
+{
+    "name": "psr/http-message",
+    "description": "Common interface for HTTP messages",
+    "keywords": ["psr", "psr-7", "http", "http-message", "request", "response"],
+    "homepage": "https://github.com/php-fig/http-message",
+    "license": "MIT",
+    "authors": [
+        {
+            "name": "PHP-FIG",
+            "homepage": "http://www.php-fig.org/"
+        }
+    ],
+    "require": {
+        "php": ">=5.3.0"
+    },
+    "autoload": {
+        "psr-4": {
+            "Psr\\Http\\Message\\": "src/"
+        }
+    },
+    "extra": {
+        "branch-alias": {
+            "dev-master": "1.0.x-dev"
+        }
+    }
+}
diff --git a/vendor/psr/http-message/src/MessageInterface.php b/vendor/psr/http-message/src/MessageInterface.php
new file mode 100644
index 0000000..dd46e5e
--- /dev/null
+++ b/vendor/psr/http-message/src/MessageInterface.php
@@ -0,0 +1,187 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * HTTP messages consist of requests from a client to a server and responses
+ * from a server to a client. This interface defines the methods common to
+ * each.
+ *
+ * Messages are considered immutable; all methods that might change state MUST
+ * be implemented such that they retain the internal state of the current
+ * message and return an instance that contains the changed state.
+ *
+ * @link http://www.ietf.org/rfc/rfc7230.txt
+ * @link http://www.ietf.org/rfc/rfc7231.txt
+ */
+interface MessageInterface
+{
+    /**
+     * Retrieves the HTTP protocol version as a string.
+     *
+     * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
+     *
+     * @return string HTTP protocol version.
+     */
+    public function getProtocolVersion();
+
+    /**
+     * Return an instance with the specified HTTP protocol version.
+     *
+     * The version string MUST contain only the HTTP version number (e.g.,
+     * "1.1", "1.0").
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new protocol version.
+     *
+     * @param string $version HTTP protocol version
+     * @return static
+     */
+    public function withProtocolVersion($version);
+
+    /**
+     * Retrieves all message header values.
+     *
+     * The keys represent the header name as it will be sent over the wire, and
+     * each value is an array of strings associated with the header.
+     *
+     *     // Represent the headers as a string
+     *     foreach ($message->getHeaders() as $name => $values) {
+     *         echo $name . ": " . implode(", ", $values);
+     *     }
+     *
+     *     // Emit headers iteratively:
+     *     foreach ($message->getHeaders() as $name => $values) {
+     *         foreach ($values as $value) {
+     *             header(sprintf('%s: %s', $name, $value), false);
+     *         }
+     *     }
+     *
+     * While header names are not case-sensitive, getHeaders() will preserve the
+     * exact case in which headers were originally specified.
+     *
+     * @return string[][] Returns an associative array of the message's headers. Each
+     *     key MUST be a header name, and each value MUST be an array of strings
+     *     for that header.
+     */
+    public function getHeaders();
+
+    /**
+     * Checks if a header exists by the given case-insensitive name.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return bool Returns true if any header names match the given header
+     *     name using a case-insensitive string comparison. Returns false if
+     *     no matching header name is found in the message.
+     */
+    public function hasHeader($name);
+
+    /**
+     * Retrieves a message header value by the given case-insensitive name.
+     *
+     * This method returns an array of all the header values of the given
+     * case-insensitive header name.
+     *
+     * If the header does not appear in the message, this method MUST return an
+     * empty array.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return string[] An array of string values as provided for the given
+     *    header. If the header does not appear in the message, this method MUST
+     *    return an empty array.
+     */
+    public function getHeader($name);
+
+    /**
+     * Retrieves a comma-separated string of the values for a single header.
+     *
+     * This method returns all of the header values of the given
+     * case-insensitive header name as a string concatenated together using
+     * a comma.
+     *
+     * NOTE: Not all header values may be appropriately represented using
+     * comma concatenation. For such headers, use getHeader() instead
+     * and supply your own delimiter when concatenating.
+     *
+     * If the header does not appear in the message, this method MUST return
+     * an empty string.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return string A string of values as provided for the given header
+     *    concatenated together using a comma. If the header does not appear in
+     *    the message, this method MUST return an empty string.
+     */
+    public function getHeaderLine($name);
+
+    /**
+     * Return an instance with the provided value replacing the specified header.
+     *
+     * While header names are case-insensitive, the casing of the header will
+     * be preserved by this function, and returned from getHeaders().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new and/or updated header and value.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @param string|string[] $value Header value(s).
+     * @return static
+     * @throws \InvalidArgumentException for invalid header names or values.
+     */
+    public function withHeader($name, $value);
+
+    /**
+     * Return an instance with the specified header appended with the given value.
+     *
+     * Existing values for the specified header will be maintained. The new
+     * value(s) will be appended to the existing list. If the header did not
+     * exist previously, it will be added.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new header and/or value.
+     *
+     * @param string $name Case-insensitive header field name to add.
+     * @param string|string[] $value Header value(s).
+     * @return static
+     * @throws \InvalidArgumentException for invalid header names or values.
+     */
+    public function withAddedHeader($name, $value);
+
+    /**
+     * Return an instance without the specified header.
+     *
+     * Header resolution MUST be done without case-sensitivity.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that removes
+     * the named header.
+     *
+     * @param string $name Case-insensitive header field name to remove.
+     * @return static
+     */
+    public function withoutHeader($name);
+
+    /**
+     * Gets the body of the message.
+     *
+     * @return StreamInterface Returns the body as a stream.
+     */
+    public function getBody();
+
+    /**
+     * Return an instance with the specified message body.
+     *
+     * The body MUST be a StreamInterface object.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return a new instance that has the
+     * new body stream.
+     *
+     * @param StreamInterface $body Body.
+     * @return static
+     * @throws \InvalidArgumentException When the body is not valid.
+     */
+    public function withBody(StreamInterface $body);
+}
diff --git a/vendor/psr/http-message/src/RequestInterface.php b/vendor/psr/http-message/src/RequestInterface.php
new file mode 100644
index 0000000..a96d4fd
--- /dev/null
+++ b/vendor/psr/http-message/src/RequestInterface.php
@@ -0,0 +1,129 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * Representation of an outgoing, client-side request.
+ *
+ * Per the HTTP specification, this interface includes properties for
+ * each of the following:
+ *
+ * - Protocol version
+ * - HTTP method
+ * - URI
+ * - Headers
+ * - Message body
+ *
+ * During construction, implementations MUST attempt to set the Host header from
+ * a provided URI if no Host header is provided.
+ *
+ * Requests are considered immutable; all methods that might change state MUST
+ * be implemented such that they retain the internal state of the current
+ * message and return an instance that contains the changed state.
+ */
+interface RequestInterface extends MessageInterface
+{
+    /**
+     * Retrieves the message's request target.
+     *
+     * Retrieves the message's request-target either as it will appear (for
+     * clients), as it appeared at request (for servers), or as it was
+     * specified for the instance (see withRequestTarget()).
+     *
+     * In most cases, this will be the origin-form of the composed URI,
+     * unless a value was provided to the concrete implementation (see
+     * withRequestTarget() below).
+     *
+     * If no URI is available, and no request-target has been specifically
+     * provided, this method MUST return the string "/".
+     *
+     * @return string
+     */
+    public function getRequestTarget();
+
+    /**
+     * Return an instance with the specific request-target.
+     *
+     * If the request needs a non-origin-form request-target — e.g., for
+     * specifying an absolute-form, authority-form, or asterisk-form —
+     * this method may be used to create an instance with the specified
+     * request-target, verbatim.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * changed request target.
+     *
+     * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various
+     *     request-target forms allowed in request messages)
+     * @param mixed $requestTarget
+     * @return static
+     */
+    public function withRequestTarget($requestTarget);
+
+    /**
+     * Retrieves the HTTP method of the request.
+     *
+     * @return string Returns the request method.
+     */
+    public function getMethod();
+
+    /**
+     * Return an instance with the provided HTTP method.
+     *
+     * While HTTP method names are typically all uppercase characters, HTTP
+     * method names are case-sensitive and thus implementations SHOULD NOT
+     * modify the given string.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * changed request method.
+     *
+     * @param string $method Case-sensitive method.
+     * @return static
+     * @throws \InvalidArgumentException for invalid HTTP methods.
+     */
+    public function withMethod($method);
+
+    /**
+     * Retrieves the URI instance.
+     *
+     * This method MUST return a UriInterface instance.
+     *
+     * @link http://tools.ietf.org/html/rfc3986#section-4.3
+     * @return UriInterface Returns a UriInterface instance
+     *     representing the URI of the request.
+     */
+    public function getUri();
+
+    /**
+     * Returns an instance with the provided URI.
+     *
+     * This method MUST update the Host header of the returned request by
+     * default if the URI contains a host component. If the URI does not
+     * contain a host component, any pre-existing Host header MUST be carried
+     * over to the returned request.
+     *
+     * You can opt-in to preserving the original state of the Host header by
+     * setting `$preserveHost` to `true`. When `$preserveHost` is set to
+     * `true`, this method interacts with the Host header in the following ways:
+     *
+     * - If the Host header is missing or empty, and the new URI contains
+     *   a host component, this method MUST update the Host header in the returned
+     *   request.
+     * - If the Host header is missing or empty, and the new URI does not contain a
+     *   host component, this method MUST NOT update the Host header in the returned
+     *   request.
+     * - If a Host header is present and non-empty, this method MUST NOT update
+     *   the Host header in the returned request.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new UriInterface instance.
+     *
+     * @link http://tools.ietf.org/html/rfc3986#section-4.3
+     * @param UriInterface $uri New request URI to use.
+     * @param bool $preserveHost Preserve the original state of the Host header.
+     * @return static
+     */
+    public function withUri(UriInterface $uri, $preserveHost = false);
+}
diff --git a/vendor/psr/http-message/src/ResponseInterface.php b/vendor/psr/http-message/src/ResponseInterface.php
new file mode 100644
index 0000000..c306514
--- /dev/null
+++ b/vendor/psr/http-message/src/ResponseInterface.php
@@ -0,0 +1,68 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * Representation of an outgoing, server-side response.
+ *
+ * Per the HTTP specification, this interface includes properties for
+ * each of the following:
+ *
+ * - Protocol version
+ * - Status code and reason phrase
+ * - Headers
+ * - Message body
+ *
+ * Responses are considered immutable; all methods that might change state MUST
+ * be implemented such that they retain the internal state of the current
+ * message and return an instance that contains the changed state.
+ */
+interface ResponseInterface extends MessageInterface
+{
+    /**
+     * Gets the response status code.
+     *
+     * The status code is a 3-digit integer result code of the server's attempt
+     * to understand and satisfy the request.
+     *
+     * @return int Status code.
+     */
+    public function getStatusCode();
+
+    /**
+     * Return an instance with the specified status code and, optionally, reason phrase.
+     *
+     * If no reason phrase is specified, implementations MAY choose to default
+     * to the RFC 7231 or IANA recommended reason phrase for the response's
+     * status code.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated status and reason phrase.
+     *
+     * @link http://tools.ietf.org/html/rfc7231#section-6
+     * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
+     * @param int $code The 3-digit integer result code to set.
+     * @param string $reasonPhrase The reason phrase to use with the
+     *     provided status code; if none is provided, implementations MAY
+     *     use the defaults as suggested in the HTTP specification.
+     * @return static
+     * @throws \InvalidArgumentException For invalid status code arguments.
+     */
+    public function withStatus($code, $reasonPhrase = '');
+
+    /**
+     * Gets the response reason phrase associated with the status code.
+     *
+     * Because a reason phrase is not a required element in a response
+     * status line, the reason phrase value MAY be null. Implementations MAY
+     * choose to return the default RFC 7231 recommended reason phrase (or those
+     * listed in the IANA HTTP Status Code Registry) for the response's
+     * status code.
+     *
+     * @link http://tools.ietf.org/html/rfc7231#section-6
+     * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
+     * @return string Reason phrase; must return an empty string if none present.
+     */
+    public function getReasonPhrase();
+}
diff --git a/vendor/psr/http-message/src/ServerRequestInterface.php b/vendor/psr/http-message/src/ServerRequestInterface.php
new file mode 100644
index 0000000..0251234
--- /dev/null
+++ b/vendor/psr/http-message/src/ServerRequestInterface.php
@@ -0,0 +1,261 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * Representation of an incoming, server-side HTTP request.
+ *
+ * Per the HTTP specification, this interface includes properties for
+ * each of the following:
+ *
+ * - Protocol version
+ * - HTTP method
+ * - URI
+ * - Headers
+ * - Message body
+ *
+ * Additionally, it encapsulates all data as it has arrived to the
+ * application from the CGI and/or PHP environment, including:
+ *
+ * - The values represented in $_SERVER.
+ * - Any cookies provided (generally via $_COOKIE)
+ * - Query string arguments (generally via $_GET, or as parsed via parse_str())
+ * - Upload files, if any (as represented by $_FILES)
+ * - Deserialized body parameters (generally from $_POST)
+ *
+ * $_SERVER values MUST be treated as immutable, as they represent application
+ * state at the time of request; as such, no methods are provided to allow
+ * modification of those values. The other values provide such methods, as they
+ * can be restored from $_SERVER or the request body, and may need treatment
+ * during the application (e.g., body parameters may be deserialized based on
+ * content type).
+ *
+ * Additionally, this interface recognizes the utility of introspecting a
+ * request to derive and match additional parameters (e.g., via URI path
+ * matching, decrypting cookie values, deserializing non-form-encoded body
+ * content, matching authorization headers to users, etc). These parameters
+ * are stored in an "attributes" property.
+ *
+ * Requests are considered immutable; all methods that might change state MUST
+ * be implemented such that they retain the internal state of the current
+ * message and return an instance that contains the changed state.
+ */
+interface ServerRequestInterface extends RequestInterface
+{
+    /**
+     * Retrieve server parameters.
+     *
+     * Retrieves data related to the incoming request environment,
+     * typically derived from PHP's $_SERVER superglobal. The data IS NOT
+     * REQUIRED to originate from $_SERVER.
+     *
+     * @return array
+     */
+    public function getServerParams();
+
+    /**
+     * Retrieve cookies.
+     *
+     * Retrieves cookies sent by the client to the server.
+     *
+     * The data MUST be compatible with the structure of the $_COOKIE
+     * superglobal.
+     *
+     * @return array
+     */
+    public function getCookieParams();
+
+    /**
+     * Return an instance with the specified cookies.
+     *
+     * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
+     * be compatible with the structure of $_COOKIE. Typically, this data will
+     * be injected at instantiation.
+     *
+     * This method MUST NOT update the related Cookie header of the request
+     * instance, nor related values in the server params.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated cookie values.
+     *
+     * @param array $cookies Array of key/value pairs representing cookies.
+     * @return static
+     */
+    public function withCookieParams(array $cookies);
+
+    /**
+     * Retrieve query string arguments.
+     *
+     * Retrieves the deserialized query string arguments, if any.
+     *
+     * Note: the query params might not be in sync with the URI or server
+     * params. If you need to ensure you are only getting the original
+     * values, you may need to parse the query string from `getUri()->getQuery()`
+     * or from the `QUERY_STRING` server param.
+     *
+     * @return array
+     */
+    public function getQueryParams();
+
+    /**
+     * Return an instance with the specified query string arguments.
+     *
+     * These values SHOULD remain immutable over the course of the incoming
+     * request. They MAY be injected during instantiation, such as from PHP's
+     * $_GET superglobal, or MAY be derived from some other value such as the
+     * URI. In cases where the arguments are parsed from the URI, the data
+     * MUST be compatible with what PHP's parse_str() would return for
+     * purposes of how duplicate query parameters are handled, and how nested
+     * sets are handled.
+     *
+     * Setting query string arguments MUST NOT change the URI stored by the
+     * request, nor the values in the server params.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated query string arguments.
+     *
+     * @param array $query Array of query string arguments, typically from
+     *     $_GET.
+     * @return static
+     */
+    public function withQueryParams(array $query);
+
+    /**
+     * Retrieve normalized file upload data.
+     *
+     * This method returns upload metadata in a normalized tree, with each leaf
+     * an instance of Psr\Http\Message\UploadedFileInterface.
+     *
+     * These values MAY be prepared from $_FILES or the message body during
+     * instantiation, or MAY be injected via withUploadedFiles().
+     *
+     * @return array An array tree of UploadedFileInterface instances; an empty
+     *     array MUST be returned if no data is present.
+     */
+    public function getUploadedFiles();
+
+    /**
+     * Create a new instance with the specified uploaded files.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated body parameters.
+     *
+     * @param array $uploadedFiles An array tree of UploadedFileInterface instances.
+     * @return static
+     * @throws \InvalidArgumentException if an invalid structure is provided.
+     */
+    public function withUploadedFiles(array $uploadedFiles);
+
+    /**
+     * Retrieve any parameters provided in the request body.
+     *
+     * If the request Content-Type is either application/x-www-form-urlencoded
+     * or multipart/form-data, and the request method is POST, this method MUST
+     * return the contents of $_POST.
+     *
+     * Otherwise, this method may return any results of deserializing
+     * the request body content; as parsing returns structured content, the
+     * potential types MUST be arrays or objects only. A null value indicates
+     * the absence of body content.
+     *
+     * @return null|array|object The deserialized body parameters, if any.
+     *     These will typically be an array or object.
+     */
+    public function getParsedBody();
+
+    /**
+     * Return an instance with the specified body parameters.
+     *
+     * These MAY be injected during instantiation.
+     *
+     * If the request Content-Type is either application/x-www-form-urlencoded
+     * or multipart/form-data, and the request method is POST, use this method
+     * ONLY to inject the contents of $_POST.
+     *
+     * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of
+     * deserializing the request body content. Deserialization/parsing returns
+     * structured data, and, as such, this method ONLY accepts arrays or objects,
+     * or a null value if nothing was available to parse.
+     *
+     * As an example, if content negotiation determines that the request data
+     * is a JSON payload, this method could be used to create a request
+     * instance with the deserialized parameters.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated body parameters.
+     *
+     * @param null|array|object $data The deserialized body data. This will
+     *     typically be in an array or object.
+     * @return static
+     * @throws \InvalidArgumentException if an unsupported argument type is
+     *     provided.
+     */
+    public function withParsedBody($data);
+
+    /**
+     * Retrieve attributes derived from the request.
+     *
+     * The request "attributes" may be used to allow injection of any
+     * parameters derived from the request: e.g., the results of path
+     * match operations; the results of decrypting cookies; the results of
+     * deserializing non-form-encoded message bodies; etc. Attributes
+     * will be application and request specific, and CAN be mutable.
+     *
+     * @return array Attributes derived from the request.
+     */
+    public function getAttributes();
+
+    /**
+     * Retrieve a single derived request attribute.
+     *
+     * Retrieves a single derived request attribute as described in
+     * getAttributes(). If the attribute has not been previously set, returns
+     * the default value as provided.
+     *
+     * This method obviates the need for a hasAttribute() method, as it allows
+     * specifying a default value to return if the attribute is not found.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @param mixed $default Default value to return if the attribute does not exist.
+     * @return mixed
+     */
+    public function getAttribute($name, $default = null);
+
+    /**
+     * Return an instance with the specified derived request attribute.
+     *
+     * This method allows setting a single derived request attribute as
+     * described in getAttributes().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated attribute.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @param mixed $value The value of the attribute.
+     * @return static
+     */
+    public function withAttribute($name, $value);
+
+    /**
+     * Return an instance that removes the specified derived request attribute.
+     *
+     * This method allows removing a single derived request attribute as
+     * described in getAttributes().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that removes
+     * the attribute.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @return static
+     */
+    public function withoutAttribute($name);
+}
diff --git a/vendor/psr/http-message/src/StreamInterface.php b/vendor/psr/http-message/src/StreamInterface.php
new file mode 100644
index 0000000..f68f391
--- /dev/null
+++ b/vendor/psr/http-message/src/StreamInterface.php
@@ -0,0 +1,158 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * Describes a data stream.
+ *
+ * Typically, an instance will wrap a PHP stream; this interface provides
+ * a wrapper around the most common operations, including serialization of
+ * the entire stream to a string.
+ */
+interface StreamInterface
+{
+    /**
+     * Reads all data from the stream into a string, from the beginning to end.
+     *
+     * This method MUST attempt to seek to the beginning of the stream before
+     * reading data and read the stream until the end is reached.
+     *
+     * Warning: This could attempt to load a large amount of data into memory.
+     *
+     * This method MUST NOT raise an exception in order to conform with PHP's
+     * string casting operations.
+     *
+     * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
+     * @return string
+     */
+    public function __toString();
+
+    /**
+     * Closes the stream and any underlying resources.
+     *
+     * @return void
+     */
+    public function close();
+
+    /**
+     * Separates any underlying resources from the stream.
+     *
+     * After the stream has been detached, the stream is in an unusable state.
+     *
+     * @return resource|null Underlying PHP stream, if any
+     */
+    public function detach();
+
+    /**
+     * Get the size of the stream if known.
+     *
+     * @return int|null Returns the size in bytes if known, or null if unknown.
+     */
+    public function getSize();
+
+    /**
+     * Returns the current position of the file read/write pointer
+     *
+     * @return int Position of the file pointer
+     * @throws \RuntimeException on error.
+     */
+    public function tell();
+
+    /**
+     * Returns true if the stream is at the end of the stream.
+     *
+     * @return bool
+     */
+    public function eof();
+
+    /**
+     * Returns whether or not the stream is seekable.
+     *
+     * @return bool
+     */
+    public function isSeekable();
+
+    /**
+     * Seek to a position in the stream.
+     *
+     * @link http://www.php.net/manual/en/function.fseek.php
+     * @param int $offset Stream offset
+     * @param int $whence Specifies how the cursor position will be calculated
+     *     based on the seek offset. Valid values are identical to the built-in
+     *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
+     *     offset bytes SEEK_CUR: Set position to current location plus offset
+     *     SEEK_END: Set position to end-of-stream plus offset.
+     * @throws \RuntimeException on failure.
+     */
+    public function seek($offset, $whence = SEEK_SET);
+
+    /**
+     * Seek to the beginning of the stream.
+     *
+     * If the stream is not seekable, this method will raise an exception;
+     * otherwise, it will perform a seek(0).
+     *
+     * @see seek()
+     * @link http://www.php.net/manual/en/function.fseek.php
+     * @throws \RuntimeException on failure.
+     */
+    public function rewind();
+
+    /**
+     * Returns whether or not the stream is writable.
+     *
+     * @return bool
+     */
+    public function isWritable();
+
+    /**
+     * Write data to the stream.
+     *
+     * @param string $string The string that is to be written.
+     * @return int Returns the number of bytes written to the stream.
+     * @throws \RuntimeException on failure.
+     */
+    public function write($string);
+
+    /**
+     * Returns whether or not the stream is readable.
+     *
+     * @return bool
+     */
+    public function isReadable();
+
+    /**
+     * Read data from the stream.
+     *
+     * @param int $length Read up to $length bytes from the object and return
+     *     them. Fewer than $length bytes may be returned if underlying stream
+     *     call returns fewer bytes.
+     * @return string Returns the data read from the stream, or an empty string
+     *     if no bytes are available.
+     * @throws \RuntimeException if an error occurs.
+     */
+    public function read($length);
+
+    /**
+     * Returns the remaining contents in a string
+     *
+     * @return string
+     * @throws \RuntimeException if unable to read or an error occurs while
+     *     reading.
+     */
+    public function getContents();
+
+    /**
+     * Get stream metadata as an associative array or retrieve a specific key.
+     *
+     * The keys returned are identical to the keys returned from PHP's
+     * stream_get_meta_data() function.
+     *
+     * @link http://php.net/manual/en/function.stream-get-meta-data.php
+     * @param string $key Specific metadata to retrieve.
+     * @return array|mixed|null Returns an associative array if no key is
+     *     provided. Returns a specific key value if a key is provided and the
+     *     value is found, or null if the key is not found.
+     */
+    public function getMetadata($key = null);
+}
diff --git a/vendor/psr/http-message/src/UploadedFileInterface.php b/vendor/psr/http-message/src/UploadedFileInterface.php
new file mode 100644
index 0000000..f8a6901
--- /dev/null
+++ b/vendor/psr/http-message/src/UploadedFileInterface.php
@@ -0,0 +1,123 @@
+<?php
+
+namespace Psr\Http\Message;
+
+/**
+ * Value object representing a file uploaded through an HTTP request.
+ *
+ * Instances of this interface are considered immutable; all methods that
+ * might change state MUST be implemented such that they retain the internal
+ * state of the current instance and return an instance that contains the
+ * changed state.
+ */
+interface UploadedFileInterface
+{
+    /**
+     * Retrieve a stream representing the uploaded file.
+     *
+     * This method MUST return a StreamInterface instance, representing the
+     * uploaded file. The purpose of this method is to allow utilizing native PHP
+     * stream functionality to manipulate the file upload, such as
+     * stream_copy_to_stream() (though the result will need to be decorated in a
+     * native PHP stream wrapper to work with such functions).
+     *
+     * If the moveTo() method has been called previously, this method MUST raise
+     * an exception.
+     *
+     * @return StreamInterface Stream representation of the uploaded file.
+     * @throws \RuntimeException in cases when no stream is available or can be
+     *     created.
+     */
+    public function getStream();
+
+    /**
+     * Move the uploaded file to a new location.
+     *
+     * Use this method as an alternative to move_uploaded_file(). This method is
+     * guaranteed to work in both SAPI and non-SAPI environments.
+     * Implementations must determine which environment they are in, and use the
+     * appropriate method (move_uploaded_file(), rename(), or a stream
+     * operation) to perform the operation.
+     *
+     * $targetPath may be an absolute path, or a relative path. If it is a
+     * relative path, resolution should be the same as used by PHP's rename()
+     * function.
+     *
+     * The original file or stream MUST be removed on completion.
+     *
+     * If this method is called more than once, any subsequent calls MUST raise
+     * an exception.
+     *
+     * When used in an SAPI environment where $_FILES is populated, when writing
+     * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be
+     * used to ensure permissions and upload status are verified correctly.
+     *
+     * If you wish to move to a stream, use getStream(), as SAPI operations
+     * cannot guarantee writing to stream destinations.
+     *
+     * @see http://php.net/is_uploaded_file
+     * @see http://php.net/move_uploaded_file
+     * @param string $targetPath Path to which to move the uploaded file.
+     * @throws \InvalidArgumentException if the $targetPath specified is invalid.
+     * @throws \RuntimeException on any error during the move operation, or on
+     *     the second or subsequent call to the method.
+     */
+    public function moveTo($targetPath);
+    
+    /**
+     * Retrieve the file size.
+     *
+     * Implementations SHOULD return the value stored in the "size" key of
+     * the file in the $_FILES array if available, as PHP calculates this based
+     * on the actual size transmitted.
+     *
+     * @return int|null The file size in bytes or null if unknown.
+     */
+    public function getSize();
+    
+    /**
+     * Retrieve the error associated with the uploaded file.
+     *
+     * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
+     *
+     * If the file was uploaded successfully, this method MUST return
+     * UPLOAD_ERR_OK.
+     *
+     * Implementations SHOULD return the value stored in the "error" key of
+     * the file in the $_FILES array.
+     *
+     * @see http://php.net/manual/en/features.file-upload.errors.php
+     * @return int One of PHP's UPLOAD_ERR_XXX constants.
+     */
+    public function getError();
+    
+    /**
+     * Retrieve the filename sent by the client.
+     *
+     * Do not trust the value returned by this method. A client could send
+     * a malicious filename with the intention to corrupt or hack your
+     * application.
+     *
+     * Implementations SHOULD return the value stored in the "name" key of
+     * the file in the $_FILES array.
+     *
+     * @return string|null The filename sent by the client or null if none
+     *     was provided.
+     */
+    public function getClientFilename();
+    
+    /**
+     * Retrieve the media type sent by the client.
+     *
+     * Do not trust the value returned by this method. A client could send
+     * a malicious media type with the intention to corrupt or hack your
+     * application.
+     *
+     * Implementations SHOULD return the value stored in the "type" key of
+     * the file in the $_FILES array.
+     *
+     * @return string|null The media type sent by the client or null if none
+     *     was provided.
+     */
+    public function getClientMediaType();
+}
diff --git a/vendor/psr/http-message/src/UriInterface.php b/vendor/psr/http-message/src/UriInterface.php
new file mode 100644
index 0000000..9d7ab9e
--- /dev/null
+++ b/vendor/psr/http-message/src/UriInterface.php
@@ -0,0 +1,323 @@
+<?php
+namespace Psr\Http\Message;
+
+/**
+ * Value object representing a URI.
+ *
+ * This interface is meant to represent URIs according to RFC 3986 and to
+ * provide methods for most common operations. Additional functionality for
+ * working with URIs can be provided on top of the interface or externally.
+ * Its primary use is for HTTP requests, but may also be used in other
+ * contexts.
+ *
+ * Instances of this interface are considered immutable; all methods that
+ * might change state MUST be implemented such that they retain the internal
+ * state of the current instance and return an instance that contains the
+ * changed state.
+ *
+ * Typically the Host header will be also be present in the request message.
+ * For server-side requests, the scheme will typically be discoverable in the
+ * server parameters.
+ *
+ * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
+ */
+interface UriInterface
+{
+    /**
+     * Retrieve the scheme component of the URI.
+     *
+     * If no scheme is present, this method MUST return an empty string.
+     *
+     * The value returned MUST be normalized to lowercase, per RFC 3986
+     * Section 3.1.
+     *
+     * The trailing ":" character is not part of the scheme and MUST NOT be
+     * added.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-3.1
+     * @return string The URI scheme.
+     */
+    public function getScheme();
+
+    /**
+     * Retrieve the authority component of the URI.
+     *
+     * If no authority information is present, this method MUST return an empty
+     * string.
+     *
+     * The authority syntax of the URI is:
+     *
+     * <pre>
+     * [user-info@]host[:port]
+     * </pre>
+     *
+     * If the port component is not set or is the standard port for the current
+     * scheme, it SHOULD NOT be included.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-3.2
+     * @return string The URI authority, in "[user-info@]host[:port]" format.
+     */
+    public function getAuthority();
+
+    /**
+     * Retrieve the user information component of the URI.
+     *
+     * If no user information is present, this method MUST return an empty
+     * string.
+     *
+     * If a user is present in the URI, this will return that value;
+     * additionally, if the password is also present, it will be appended to the
+     * user value, with a colon (":") separating the values.
+     *
+     * The trailing "@" character is not part of the user information and MUST
+     * NOT be added.
+     *
+     * @return string The URI user information, in "username[:password]" format.
+     */
+    public function getUserInfo();
+
+    /**
+     * Retrieve the host component of the URI.
+     *
+     * If no host is present, this method MUST return an empty string.
+     *
+     * The value returned MUST be normalized to lowercase, per RFC 3986
+     * Section 3.2.2.
+     *
+     * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
+     * @return string The URI host.
+     */
+    public function getHost();
+
+    /**
+     * Retrieve the port component of the URI.
+     *
+     * If a port is present, and it is non-standard for the current scheme,
+     * this method MUST return it as an integer. If the port is the standard port
+     * used with the current scheme, this method SHOULD return null.
+     *
+     * If no port is present, and no scheme is present, this method MUST return
+     * a null value.
+     *
+     * If no port is present, but a scheme is present, this method MAY return
+     * the standard port for that scheme, but SHOULD return null.
+     *
+     * @return null|int The URI port.
+     */
+    public function getPort();
+
+    /**
+     * Retrieve the path component of the URI.
+     *
+     * The path can either be empty or absolute (starting with a slash) or
+     * rootless (not starting with a slash). Implementations MUST support all
+     * three syntaxes.
+     *
+     * Normally, the empty path "" and absolute path "/" are considered equal as
+     * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
+     * do this normalization because in contexts with a trimmed base path, e.g.
+     * the front controller, this difference becomes significant. It's the task
+     * of the user to handle both "" and "/".
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.3.
+     *
+     * As an example, if the value should include a slash ("/") not intended as
+     * delimiter between path segments, that value MUST be passed in encoded
+     * form (e.g., "%2F") to the instance.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.3
+     * @return string The URI path.
+     */
+    public function getPath();
+
+    /**
+     * Retrieve the query string of the URI.
+     *
+     * If no query string is present, this method MUST return an empty string.
+     *
+     * The leading "?" character is not part of the query and MUST NOT be
+     * added.
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.4.
+     *
+     * As an example, if a value in a key/value pair of the query string should
+     * include an ampersand ("&") not intended as a delimiter between values,
+     * that value MUST be passed in encoded form (e.g., "%26") to the instance.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.4
+     * @return string The URI query string.
+     */
+    public function getQuery();
+
+    /**
+     * Retrieve the fragment component of the URI.
+     *
+     * If no fragment is present, this method MUST return an empty string.
+     *
+     * The leading "#" character is not part of the fragment and MUST NOT be
+     * added.
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.5.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.5
+     * @return string The URI fragment.
+     */
+    public function getFragment();
+
+    /**
+     * Return an instance with the specified scheme.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified scheme.
+     *
+     * Implementations MUST support the schemes "http" and "https" case
+     * insensitively, and MAY accommodate other schemes if required.
+     *
+     * An empty scheme is equivalent to removing the scheme.
+     *
+     * @param string $scheme The scheme to use with the new instance.
+     * @return static A new instance with the specified scheme.
+     * @throws \InvalidArgumentException for invalid or unsupported schemes.
+     */
+    public function withScheme($scheme);
+
+    /**
+     * Return an instance with the specified user information.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified user information.
+     *
+     * Password is optional, but the user information MUST include the
+     * user; an empty string for the user is equivalent to removing user
+     * information.
+     *
+     * @param string $user The user name to use for authority.
+     * @param null|string $password The password associated with $user.
+     * @return static A new instance with the specified user information.
+     */
+    public function withUserInfo($user, $password = null);
+
+    /**
+     * Return an instance with the specified host.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified host.
+     *
+     * An empty host value is equivalent to removing the host.
+     *
+     * @param string $host The hostname to use with the new instance.
+     * @return static A new instance with the specified host.
+     * @throws \InvalidArgumentException for invalid hostnames.
+     */
+    public function withHost($host);
+
+    /**
+     * Return an instance with the specified port.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified port.
+     *
+     * Implementations MUST raise an exception for ports outside the
+     * established TCP and UDP port ranges.
+     *
+     * A null value provided for the port is equivalent to removing the port
+     * information.
+     *
+     * @param null|int $port The port to use with the new instance; a null value
+     *     removes the port information.
+     * @return static A new instance with the specified port.
+     * @throws \InvalidArgumentException for invalid ports.
+     */
+    public function withPort($port);
+
+    /**
+     * Return an instance with the specified path.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified path.
+     *
+     * The path can either be empty or absolute (starting with a slash) or
+     * rootless (not starting with a slash). Implementations MUST support all
+     * three syntaxes.
+     *
+     * If the path is intended to be domain-relative rather than path relative then
+     * it must begin with a slash ("/"). Paths not starting with a slash ("/")
+     * are assumed to be relative to some base path known to the application or
+     * consumer.
+     *
+     * Users can provide both encoded and decoded path characters.
+     * Implementations ensure the correct encoding as outlined in getPath().
+     *
+     * @param string $path The path to use with the new instance.
+     * @return static A new instance with the specified path.
+     * @throws \InvalidArgumentException for invalid paths.
+     */
+    public function withPath($path);
+
+    /**
+     * Return an instance with the specified query string.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified query string.
+     *
+     * Users can provide both encoded and decoded query characters.
+     * Implementations ensure the correct encoding as outlined in getQuery().
+     *
+     * An empty query string value is equivalent to removing the query string.
+     *
+     * @param string $query The query string to use with the new instance.
+     * @return static A new instance with the specified query string.
+     * @throws \InvalidArgumentException for invalid query strings.
+     */
+    public function withQuery($query);
+
+    /**
+     * Return an instance with the specified URI fragment.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified URI fragment.
+     *
+     * Users can provide both encoded and decoded fragment characters.
+     * Implementations ensure the correct encoding as outlined in getFragment().
+     *
+     * An empty fragment value is equivalent to removing the fragment.
+     *
+     * @param string $fragment The fragment to use with the new instance.
+     * @return static A new instance with the specified fragment.
+     */
+    public function withFragment($fragment);
+
+    /**
+     * Return the string representation as a URI reference.
+     *
+     * Depending on which components of the URI are present, the resulting
+     * string is either a full URI or relative reference according to RFC 3986,
+     * Section 4.1. The method concatenates the various components of the URI,
+     * using the appropriate delimiters:
+     *
+     * - If a scheme is present, it MUST be suffixed by ":".
+     * - If an authority is present, it MUST be prefixed by "//".
+     * - The path can be concatenated without delimiters. But there are two
+     *   cases where the path has to be adjusted to make the URI reference
+     *   valid as PHP does not allow to throw an exception in __toString():
+     *     - If the path is rootless and an authority is present, the path MUST
+     *       be prefixed by "/".
+     *     - If the path is starting with more than one "/" and no authority is
+     *       present, the starting slashes MUST be reduced to one.
+     * - If a query is present, it MUST be prefixed by "?".
+     * - If a fragment is present, it MUST be prefixed by "#".
+     *
+     * @see http://tools.ietf.org/html/rfc3986#section-4.1
+     * @return string
+     */
+    public function __toString();
+}
diff --git a/vendor/slim/slim/LICENSE.md b/vendor/slim/slim/LICENSE.md
new file mode 100644
index 0000000..682c21d
--- /dev/null
+++ b/vendor/slim/slim/LICENSE.md
@@ -0,0 +1,19 @@
+Copyright (c) 2011-2017 Josh Lockhart
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is furnished
+to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/vendor/slim/slim/Slim/App.php b/vendor/slim/slim/Slim/App.php
new file mode 100644
index 0000000..587e671
--- /dev/null
+++ b/vendor/slim/slim/Slim/App.php
@@ -0,0 +1,677 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Exception;
+use Slim\Exception\InvalidMethodException;
+use Slim\Http\Response;
+use Throwable;
+use Closure;
+use InvalidArgumentException;
+use Psr\Http\Message\RequestInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Container\ContainerInterface;
+use FastRoute\Dispatcher;
+use Slim\Exception\SlimException;
+use Slim\Exception\MethodNotAllowedException;
+use Slim\Exception\NotFoundException;
+use Slim\Http\Uri;
+use Slim\Http\Headers;
+use Slim\Http\Body;
+use Slim\Http\Request;
+use Slim\Interfaces\Http\EnvironmentInterface;
+use Slim\Interfaces\RouteGroupInterface;
+use Slim\Interfaces\RouteInterface;
+use Slim\Interfaces\RouterInterface;
+
+/**
+ * App
+ *
+ * This is the primary class with which you instantiate,
+ * configure, and run a Slim Framework application.
+ * The \Slim\App class also accepts Slim Framework middleware.
+ *
+ * @property-read callable $errorHandler
+ * @property-read callable $phpErrorHandler
+ * @property-read callable $notFoundHandler function($request, $response)
+ * @property-read callable $notAllowedHandler function($request, $response, $allowedHttpMethods)
+ */
+class App
+{
+    use MiddlewareAwareTrait;
+
+    /**
+     * Current version
+     *
+     * @var string
+     */
+    const VERSION = '3.8.1';
+
+    /**
+     * Container
+     *
+     * @var ContainerInterface
+     */
+    private $container;
+
+    /********************************************************************************
+     * Constructor
+     *******************************************************************************/
+
+    /**
+     * Create new application
+     *
+     * @param ContainerInterface|array $container Either a ContainerInterface or an associative array of app settings
+     * @throws InvalidArgumentException when no container is provided that implements ContainerInterface
+     */
+    public function __construct($container = [])
+    {
+        if (is_array($container)) {
+            $container = new Container($container);
+        }
+        if (!$container instanceof ContainerInterface) {
+            throw new InvalidArgumentException('Expected a ContainerInterface');
+        }
+        $this->container = $container;
+    }
+
+    /**
+     * Enable access to the DI container by consumers of $app
+     *
+     * @return ContainerInterface
+     */
+    public function getContainer()
+    {
+        return $this->container;
+    }
+
+    /**
+     * Add middleware
+     *
+     * This method prepends new middleware to the app's middleware stack.
+     *
+     * @param  callable|string    $callable The callback routine
+     *
+     * @return static
+     */
+    public function add($callable)
+    {
+        return $this->addMiddleware(new DeferredCallable($callable, $this->container));
+    }
+
+    /**
+     * Calling a non-existant method on App checks to see if there's an item
+     * in the container that is callable and if so, calls it.
+     *
+     * @param  string $method
+     * @param  array $args
+     * @return mixed
+     */
+    public function __call($method, $args)
+    {
+        if ($this->container->has($method)) {
+            $obj = $this->container->get($method);
+            if (is_callable($obj)) {
+                return call_user_func_array($obj, $args);
+            }
+        }
+
+        throw new \BadMethodCallException("Method $method is not a valid method");
+    }
+
+    /********************************************************************************
+     * Router proxy methods
+     *******************************************************************************/
+
+    /**
+     * Add GET route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function get($pattern, $callable)
+    {
+        return $this->map(['GET'], $pattern, $callable);
+    }
+
+    /**
+     * Add POST route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function post($pattern, $callable)
+    {
+        return $this->map(['POST'], $pattern, $callable);
+    }
+
+    /**
+     * Add PUT route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function put($pattern, $callable)
+    {
+        return $this->map(['PUT'], $pattern, $callable);
+    }
+
+    /**
+     * Add PATCH route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function patch($pattern, $callable)
+    {
+        return $this->map(['PATCH'], $pattern, $callable);
+    }
+
+    /**
+     * Add DELETE route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function delete($pattern, $callable)
+    {
+        return $this->map(['DELETE'], $pattern, $callable);
+    }
+
+    /**
+     * Add OPTIONS route
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function options($pattern, $callable)
+    {
+        return $this->map(['OPTIONS'], $pattern, $callable);
+    }
+
+    /**
+     * Add route for any HTTP method
+     *
+     * @param  string $pattern  The route URI pattern
+     * @param  callable|string  $callable The route callback routine
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function any($pattern, $callable)
+    {
+        return $this->map(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'], $pattern, $callable);
+    }
+
+    /**
+     * Add route with multiple methods
+     *
+     * @param  string[] $methods  Numeric array of HTTP method names
+     * @param  string   $pattern  The route URI pattern
+     * @param  callable|string    $callable The route callback routine
+     *
+     * @return RouteInterface
+     */
+    public function map(array $methods, $pattern, $callable)
+    {
+        if ($callable instanceof Closure) {
+            $callable = $callable->bindTo($this->container);
+        }
+
+        $route = $this->container->get('router')->map($methods, $pattern, $callable);
+        if (is_callable([$route, 'setContainer'])) {
+            $route->setContainer($this->container);
+        }
+
+        if (is_callable([$route, 'setOutputBuffering'])) {
+            $route->setOutputBuffering($this->container->get('settings')['outputBuffering']);
+        }
+
+        return $route;
+    }
+
+    /**
+     * Route Groups
+     *
+     * This method accepts a route pattern and a callback. All route
+     * declarations in the callback will be prepended by the group(s)
+     * that it is in.
+     *
+     * @param string   $pattern
+     * @param callable $callable
+     *
+     * @return RouteGroupInterface
+     */
+    public function group($pattern, $callable)
+    {
+        /** @var RouteGroup $group */
+        $group = $this->container->get('router')->pushGroup($pattern, $callable);
+        $group->setContainer($this->container);
+        $group($this);
+        $this->container->get('router')->popGroup();
+        return $group;
+    }
+
+    /********************************************************************************
+     * Runner
+     *******************************************************************************/
+
+    /**
+     * Run application
+     *
+     * This method traverses the application middleware stack and then sends the
+     * resultant Response object to the HTTP client.
+     *
+     * @param bool|false $silent
+     * @return ResponseInterface
+     *
+     * @throws Exception
+     * @throws MethodNotAllowedException
+     * @throws NotFoundException
+     */
+    public function run($silent = false)
+    {
+        $response = $this->container->get('response');
+
+        try {
+            $response = $this->process($this->container->get('request'), $response);
+        } catch (InvalidMethodException $e) {
+            $response = $this->processInvalidMethod($e->getRequest(), $response);
+        }
+
+        if (!$silent) {
+            $this->respond($response);
+        }
+
+        return $response;
+    }
+
+    /**
+     * Pull route info for a request with a bad method to decide whether to
+     * return a not-found error (default) or a bad-method error, then run
+     * the handler for that error, returning the resulting response.
+     *
+     * Used for cases where an incoming request has an unrecognized method,
+     * rather than throwing an exception and not catching it all the way up.
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface $response
+     * @return ResponseInterface
+     */
+    protected function processInvalidMethod(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        $router = $this->container->get('router');
+        if (is_callable([$request->getUri(), 'getBasePath']) && is_callable([$router, 'setBasePath'])) {
+            $router->setBasePath($request->getUri()->getBasePath());
+        }
+
+        $request = $this->dispatchRouterAndPrepareRoute($request, $router);
+        $routeInfo = $request->getAttribute('routeInfo', [RouterInterface::DISPATCH_STATUS => Dispatcher::NOT_FOUND]);
+
+        if ($routeInfo[RouterInterface::DISPATCH_STATUS] === Dispatcher::METHOD_NOT_ALLOWED) {
+            return $this->handleException(
+                new MethodNotAllowedException($request, $response, $routeInfo[RouterInterface::ALLOWED_METHODS]),
+                $request,
+                $response
+            );
+        }
+
+        return $this->handleException(new NotFoundException($request, $response), $request, $response);
+    }
+
+    /**
+     * Process a request
+     *
+     * This method traverses the application middleware stack and then returns the
+     * resultant Response object.
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface $response
+     * @return ResponseInterface
+     *
+     * @throws Exception
+     * @throws MethodNotAllowedException
+     * @throws NotFoundException
+     */
+    public function process(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        // Ensure basePath is set
+        $router = $this->container->get('router');
+        if (is_callable([$request->getUri(), 'getBasePath']) && is_callable([$router, 'setBasePath'])) {
+            $router->setBasePath($request->getUri()->getBasePath());
+        }
+
+        // Dispatch the Router first if the setting for this is on
+        if ($this->container->get('settings')['determineRouteBeforeAppMiddleware'] === true) {
+            // Dispatch router (note: you won't be able to alter routes after this)
+            $request = $this->dispatchRouterAndPrepareRoute($request, $router);
+        }
+
+        // Traverse middleware stack
+        try {
+            $response = $this->callMiddlewareStack($request, $response);
+        } catch (Exception $e) {
+            $response = $this->handleException($e, $request, $response);
+        } catch (Throwable $e) {
+            $response = $this->handlePhpError($e, $request, $response);
+        }
+
+        $response = $this->finalize($response);
+
+        return $response;
+    }
+
+    /**
+     * Send the response the client
+     *
+     * @param ResponseInterface $response
+     */
+    public function respond(ResponseInterface $response)
+    {
+        // Send response
+        if (!headers_sent()) {
+            // Status
+            header(sprintf(
+                'HTTP/%s %s %s',
+                $response->getProtocolVersion(),
+                $response->getStatusCode(),
+                $response->getReasonPhrase()
+            ));
+
+            // Headers
+            foreach ($response->getHeaders() as $name => $values) {
+                foreach ($values as $value) {
+                    header(sprintf('%s: %s', $name, $value), false);
+                }
+            }
+        }
+
+        // Body
+        if (!$this->isEmptyResponse($response)) {
+            $body = $response->getBody();
+            if ($body->isSeekable()) {
+                $body->rewind();
+            }
+            $settings       = $this->container->get('settings');
+            $chunkSize      = $settings['responseChunkSize'];
+
+            $contentLength  = $response->getHeaderLine('Content-Length');
+            if (!$contentLength) {
+                $contentLength = $body->getSize();
+            }
+
+
+            if (isset($contentLength)) {
+                $amountToRead = $contentLength;
+                while ($amountToRead > 0 && !$body->eof()) {
+                    $data = $body->read(min($chunkSize, $amountToRead));
+                    echo $data;
+
+                    $amountToRead -= strlen($data);
+
+                    if (connection_status() != CONNECTION_NORMAL) {
+                        break;
+                    }
+                }
+            } else {
+                while (!$body->eof()) {
+                    echo $body->read($chunkSize);
+                    if (connection_status() != CONNECTION_NORMAL) {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Invoke application
+     *
+     * This method implements the middleware interface. It receives
+     * Request and Response objects, and it returns a Response object
+     * after compiling the routes registered in the Router and dispatching
+     * the Request object to the appropriate Route callback routine.
+     *
+     * @param  ServerRequestInterface $request  The most recent Request object
+     * @param  ResponseInterface      $response The most recent Response object
+     *
+     * @return ResponseInterface
+     * @throws MethodNotAllowedException
+     * @throws NotFoundException
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        // Get the route info
+        $routeInfo = $request->getAttribute('routeInfo');
+
+        /** @var \Slim\Interfaces\RouterInterface $router */
+        $router = $this->container->get('router');
+
+        // If router hasn't been dispatched or the URI changed then dispatch
+        if (null === $routeInfo || ($routeInfo['request'] !== [$request->getMethod(), (string) $request->getUri()])) {
+            $request = $this->dispatchRouterAndPrepareRoute($request, $router);
+            $routeInfo = $request->getAttribute('routeInfo');
+        }
+
+        if ($routeInfo[0] === Dispatcher::FOUND) {
+            $route = $router->lookupRoute($routeInfo[1]);
+            return $route->run($request, $response);
+        } elseif ($routeInfo[0] === Dispatcher::METHOD_NOT_ALLOWED) {
+            if (!$this->container->has('notAllowedHandler')) {
+                throw new MethodNotAllowedException($request, $response, $routeInfo[1]);
+            }
+            /** @var callable $notAllowedHandler */
+            $notAllowedHandler = $this->container->get('notAllowedHandler');
+            return $notAllowedHandler($request, $response, $routeInfo[1]);
+        }
+
+        if (!$this->container->has('notFoundHandler')) {
+            throw new NotFoundException($request, $response);
+        }
+        /** @var callable $notFoundHandler */
+        $notFoundHandler = $this->container->get('notFoundHandler');
+        return $notFoundHandler($request, $response);
+    }
+
+    /**
+     * Perform a sub-request from within an application route
+     *
+     * This method allows you to prepare and initiate a sub-request, run within
+     * the context of the current request. This WILL NOT issue a remote HTTP
+     * request. Instead, it will route the provided URL, method, headers,
+     * cookies, body, and server variables against the set of registered
+     * application routes. The result response object is returned.
+     *
+     * @param  string            $method      The request method (e.g., GET, POST, PUT, etc.)
+     * @param  string            $path        The request URI path
+     * @param  string            $query       The request URI query string
+     * @param  array             $headers     The request headers (key-value array)
+     * @param  array             $cookies     The request cookies (key-value array)
+     * @param  string            $bodyContent The request body
+     * @param  ResponseInterface $response     The response object (optional)
+     * @return ResponseInterface
+     */
+    public function subRequest(
+        $method,
+        $path,
+        $query = '',
+        array $headers = [],
+        array $cookies = [],
+        $bodyContent = '',
+        ResponseInterface $response = null
+    ) {
+        $env = $this->container->get('environment');
+        $uri = Uri::createFromEnvironment($env)->withPath($path)->withQuery($query);
+        $headers = new Headers($headers);
+        $serverParams = $env->all();
+        $body = new Body(fopen('php://temp', 'r+'));
+        $body->write($bodyContent);
+        $body->rewind();
+        $request = new Request($method, $uri, $headers, $cookies, $serverParams, $body);
+
+        if (!$response) {
+            $response = $this->container->get('response');
+        }
+
+        return $this($request, $response);
+    }
+
+    /**
+     * Dispatch the router to find the route. Prepare the route for use.
+     *
+     * @param ServerRequestInterface $request
+     * @param RouterInterface        $router
+     * @return ServerRequestInterface
+     */
+    protected function dispatchRouterAndPrepareRoute(ServerRequestInterface $request, RouterInterface $router)
+    {
+        $routeInfo = $router->dispatch($request);
+
+        if ($routeInfo[0] === Dispatcher::FOUND) {
+            $routeArguments = [];
+            foreach ($routeInfo[2] as $k => $v) {
+                $routeArguments[$k] = urldecode($v);
+            }
+
+            $route = $router->lookupRoute($routeInfo[1]);
+            $route->prepare($request, $routeArguments);
+
+            // add route to the request's attributes in case a middleware or handler needs access to the route
+            $request = $request->withAttribute('route', $route);
+        }
+
+        $routeInfo['request'] = [$request->getMethod(), (string) $request->getUri()];
+
+        return $request->withAttribute('routeInfo', $routeInfo);
+    }
+
+    /**
+     * Finalize response
+     *
+     * @param ResponseInterface $response
+     * @return ResponseInterface
+     */
+    protected function finalize(ResponseInterface $response)
+    {
+        // stop PHP sending a Content-Type automatically
+        ini_set('default_mimetype', '');
+
+        if ($this->isEmptyResponse($response)) {
+            return $response->withoutHeader('Content-Type')->withoutHeader('Content-Length');
+        }
+
+        // Add Content-Length header if `addContentLengthHeader` setting is set
+        if (isset($this->container->get('settings')['addContentLengthHeader']) &&
+            $this->container->get('settings')['addContentLengthHeader'] == true) {
+            if (ob_get_length() > 0) {
+                throw new \RuntimeException("Unexpected data in output buffer. " .
+                    "Maybe you have characters before an opening <?php tag?");
+            }
+            $size = $response->getBody()->getSize();
+            if ($size !== null && !$response->hasHeader('Content-Length')) {
+                $response = $response->withHeader('Content-Length', (string) $size);
+            }
+        }
+
+        return $response;
+    }
+
+    /**
+     * Helper method, which returns true if the provided response must not output a body and false
+     * if the response could have a body.
+     *
+     * @see https://tools.ietf.org/html/rfc7231
+     *
+     * @param ResponseInterface $response
+     * @return bool
+     */
+    protected function isEmptyResponse(ResponseInterface $response)
+    {
+        if (method_exists($response, 'isEmpty')) {
+            return $response->isEmpty();
+        }
+
+        return in_array($response->getStatusCode(), [204, 205, 304]);
+    }
+
+    /**
+     * Call relevant handler from the Container if needed. If it doesn't exist,
+     * then just re-throw.
+     *
+     * @param  Exception $e
+     * @param  ServerRequestInterface $request
+     * @param  ResponseInterface $response
+     *
+     * @return ResponseInterface
+     * @throws Exception if a handler is needed and not found
+     */
+    protected function handleException(Exception $e, ServerRequestInterface $request, ResponseInterface $response)
+    {
+        if ($e instanceof MethodNotAllowedException) {
+            $handler = 'notAllowedHandler';
+            $params = [$e->getRequest(), $e->getResponse(), $e->getAllowedMethods()];
+        } elseif ($e instanceof NotFoundException) {
+            $handler = 'notFoundHandler';
+            $params = [$e->getRequest(), $e->getResponse(), $e];
+        } elseif ($e instanceof SlimException) {
+            // This is a Stop exception and contains the response
+            return $e->getResponse();
+        } else {
+            // Other exception, use $request and $response params
+            $handler = 'errorHandler';
+            $params = [$request, $response, $e];
+        }
+
+        if ($this->container->has($handler)) {
+            $callable = $this->container->get($handler);
+            // Call the registered handler
+            return call_user_func_array($callable, $params);
+        }
+
+        // No handlers found, so just throw the exception
+        throw $e;
+    }
+
+    /**
+     * Call relevant handler from the Container if needed. If it doesn't exist,
+     * then just re-throw.
+     *
+     * @param  Throwable $e
+     * @param  ServerRequestInterface $request
+     * @param  ResponseInterface $response
+     * @return ResponseInterface
+     * @throws Throwable
+     */
+    protected function handlePhpError(Throwable $e, ServerRequestInterface $request, ResponseInterface $response)
+    {
+        $handler = 'phpErrorHandler';
+        $params = [$request, $response, $e];
+
+        if ($this->container->has($handler)) {
+            $callable = $this->container->get($handler);
+            // Call the registered handler
+            return call_user_func_array($callable, $params);
+        }
+
+        // No handlers found, so just throw the exception
+        throw $e;
+    }
+}
diff --git a/vendor/slim/slim/Slim/CallableResolver.php b/vendor/slim/slim/Slim/CallableResolver.php
new file mode 100644
index 0000000..b2ce368
--- /dev/null
+++ b/vendor/slim/slim/Slim/CallableResolver.php
@@ -0,0 +1,110 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use RuntimeException;
+use Psr\Container\ContainerInterface;
+use Slim\Interfaces\CallableResolverInterface;
+
+/**
+ * This class resolves a string of the format 'class:method' into a closure
+ * that can be dispatched.
+ */
+final class CallableResolver implements CallableResolverInterface
+{
+    const CALLABLE_PATTERN = '!^([^\:]+)\:([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)$!';
+
+    /**
+     * @var ContainerInterface
+     */
+    private $container;
+
+    /**
+     * @param ContainerInterface $container
+     */
+    public function __construct(ContainerInterface $container)
+    {
+        $this->container = $container;
+    }
+
+    /**
+     * Resolve toResolve into a closure that that the router can dispatch.
+     *
+     * If toResolve is of the format 'class:method', then try to extract 'class'
+     * from the container otherwise instantiate it and then dispatch 'method'.
+     *
+     * @param mixed $toResolve
+     *
+     * @return callable
+     *
+     * @throws RuntimeException if the callable does not exist
+     * @throws RuntimeException if the callable is not resolvable
+     */
+    public function resolve($toResolve)
+    {
+        if (is_callable($toResolve)) {
+            return $toResolve;
+        }
+
+        if (!is_string($toResolve)) {
+            $this->assertCallable($toResolve);
+        }
+
+        // check for slim callable as "class:method"
+        if (preg_match(self::CALLABLE_PATTERN, $toResolve, $matches)) {
+            $resolved = $this->resolveCallable($matches[1], $matches[2]);
+            $this->assertCallable($resolved);
+
+            return $resolved;
+        }
+
+        $resolved = $this->resolveCallable($toResolve);
+        $this->assertCallable($resolved);
+
+        return $resolved;
+    }
+
+    /**
+     * Check if string is something in the DIC
+     * that's callable or is a class name which has an __invoke() method.
+     *
+     * @param string $class
+     * @param string $method
+     * @return callable
+     *
+     * @throws \RuntimeException if the callable does not exist
+     */
+    protected function resolveCallable($class, $method = '__invoke')
+    {
+        if ($this->container->has($class)) {
+            return [$this->container->get($class), $method];
+        }
+
+        if (!class_exists($class)) {
+            throw new RuntimeException(sprintf('Callable %s does not exist', $class));
+        }
+
+        return [new $class($this->container), $method];
+    }
+
+    /**
+     * @param Callable $callable
+     *
+     * @throws \RuntimeException if the callable is not resolvable
+     */
+    protected function assertCallable($callable)
+    {
+        if (!is_callable($callable)) {
+            throw new RuntimeException(sprintf(
+                '%s is not resolvable',
+                is_array($callable) || is_object($callable) ? json_encode($callable) : $callable
+            ));
+        }
+    }
+}
diff --git a/vendor/slim/slim/Slim/CallableResolverAwareTrait.php b/vendor/slim/slim/Slim/CallableResolverAwareTrait.php
new file mode 100644
index 0000000..ffb4eb2
--- /dev/null
+++ b/vendor/slim/slim/Slim/CallableResolverAwareTrait.php
@@ -0,0 +1,47 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use RuntimeException;
+use Psr\Container\ContainerInterface;
+use Slim\Interfaces\CallableResolverInterface;
+
+/**
+ * ResolveCallable
+ *
+ * This is an internal class that enables resolution of 'class:method' strings
+ * into a closure. This class is an implementation detail and is used only inside
+ * of the Slim application.
+ *
+ * @property ContainerInterface $container
+ */
+trait CallableResolverAwareTrait
+{
+    /**
+     * Resolve a string of the format 'class:method' into a closure that the
+     * router can dispatch.
+     *
+     * @param callable|string $callable
+     *
+     * @return \Closure
+     *
+     * @throws RuntimeException If the string cannot be resolved as a callable
+     */
+    protected function resolveCallable($callable)
+    {
+        if (!$this->container instanceof ContainerInterface) {
+            return $callable;
+        }
+
+        /** @var CallableResolverInterface $resolver */
+        $resolver = $this->container->get('callableResolver');
+
+        return $resolver->resolve($callable);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Collection.php b/vendor/slim/slim/Slim/Collection.php
new file mode 100644
index 0000000..728bb73
--- /dev/null
+++ b/vendor/slim/slim/Slim/Collection.php
@@ -0,0 +1,202 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use ArrayIterator;
+use Slim\Interfaces\CollectionInterface;
+
+/**
+ * Collection
+ *
+ * This class provides a common interface used by many other
+ * classes in a Slim application that manage "collections"
+ * of data that must be inspected and/or manipulated
+ */
+class Collection implements CollectionInterface
+{
+    /**
+     * The source data
+     *
+     * @var array
+     */
+    protected $data = [];
+
+    /**
+     * Create new collection
+     *
+     * @param array $items Pre-populate collection with this key-value array
+     */
+    public function __construct(array $items = [])
+    {
+        $this->replace($items);
+    }
+
+    /********************************************************************************
+     * Collection interface
+     *******************************************************************************/
+
+    /**
+     * Set collection item
+     *
+     * @param string $key   The data key
+     * @param mixed  $value The data value
+     */
+    public function set($key, $value)
+    {
+        $this->data[$key] = $value;
+    }
+
+    /**
+     * Get collection item for key
+     *
+     * @param string $key     The data key
+     * @param mixed  $default The default value to return if data key does not exist
+     *
+     * @return mixed The key's value, or the default value
+     */
+    public function get($key, $default = null)
+    {
+        return $this->has($key) ? $this->data[$key] : $default;
+    }
+
+    /**
+     * Add item to collection, replacing existing items with the same data key
+     *
+     * @param array $items Key-value array of data to append to this collection
+     */
+    public function replace(array $items)
+    {
+        foreach ($items as $key => $value) {
+            $this->set($key, $value);
+        }
+    }
+
+    /**
+     * Get all items in collection
+     *
+     * @return array The collection's source data
+     */
+    public function all()
+    {
+        return $this->data;
+    }
+
+    /**
+     * Get collection keys
+     *
+     * @return array The collection's source data keys
+     */
+    public function keys()
+    {
+        return array_keys($this->data);
+    }
+
+    /**
+     * Does this collection have a given key?
+     *
+     * @param string $key The data key
+     *
+     * @return bool
+     */
+    public function has($key)
+    {
+        return array_key_exists($key, $this->data);
+    }
+
+    /**
+     * Remove item from collection
+     *
+     * @param string $key The data key
+     */
+    public function remove($key)
+    {
+        unset($this->data[$key]);
+    }
+
+    /**
+     * Remove all items from collection
+     */
+    public function clear()
+    {
+        $this->data = [];
+    }
+
+    /********************************************************************************
+     * ArrayAccess interface
+     *******************************************************************************/
+
+    /**
+     * Does this collection have a given key?
+     *
+     * @param  string $key The data key
+     *
+     * @return bool
+     */
+    public function offsetExists($key)
+    {
+        return $this->has($key);
+    }
+
+    /**
+     * Get collection item for key
+     *
+     * @param string $key The data key
+     *
+     * @return mixed The key's value, or the default value
+     */
+    public function offsetGet($key)
+    {
+        return $this->get($key);
+    }
+
+    /**
+     * Set collection item
+     *
+     * @param string $key   The data key
+     * @param mixed  $value The data value
+     */
+    public function offsetSet($key, $value)
+    {
+        $this->set($key, $value);
+    }
+
+    /**
+     * Remove item from collection
+     *
+     * @param string $key The data key
+     */
+    public function offsetUnset($key)
+    {
+        $this->remove($key);
+    }
+
+    /**
+     * Get number of items in collection
+     *
+     * @return int
+     */
+    public function count()
+    {
+        return count($this->data);
+    }
+
+    /********************************************************************************
+     * IteratorAggregate interface
+     *******************************************************************************/
+
+    /**
+     * Get collection iterator
+     *
+     * @return \ArrayIterator
+     */
+    public function getIterator()
+    {
+        return new ArrayIterator($this->data);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Container.php b/vendor/slim/slim/Slim/Container.php
new file mode 100644
index 0000000..ac0d917
--- /dev/null
+++ b/vendor/slim/slim/Slim/Container.php
@@ -0,0 +1,179 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Interop\Container\ContainerInterface;
+use Interop\Container\Exception\ContainerException;
+use Pimple\Container as PimpleContainer;
+use Slim\Exception\ContainerValueNotFoundException;
+use Slim\Exception\ContainerException as SlimContainerException;
+
+/**
+ * Slim's default DI container is Pimple.
+ *
+ * Slim\App expects a container that implements Interop\Container\ContainerInterface
+ * with these service keys configured and ready for use:
+ *
+ *  - settings: an array or instance of \ArrayAccess
+ *  - environment: an instance of \Slim\Interfaces\Http\EnvironmentInterface
+ *  - request: an instance of \Psr\Http\Message\ServerRequestInterface
+ *  - response: an instance of \Psr\Http\Message\ResponseInterface
+ *  - router: an instance of \Slim\Interfaces\RouterInterface
+ *  - foundHandler: an instance of \Slim\Interfaces\InvocationStrategyInterface
+ *  - errorHandler: a callable with the signature: function($request, $response, $exception)
+ *  - notFoundHandler: a callable with the signature: function($request, $response)
+ *  - notAllowedHandler: a callable with the signature: function($request, $response, $allowedHttpMethods)
+ *  - callableResolver: an instance of \Slim\Interfaces\CallableResolverInterface
+ *
+ * @property-read array settings
+ * @property-read \Slim\Interfaces\Http\EnvironmentInterface environment
+ * @property-read \Psr\Http\Message\ServerRequestInterface request
+ * @property-read \Psr\Http\Message\ResponseInterface response
+ * @property-read \Slim\Interfaces\RouterInterface router
+ * @property-read \Slim\Interfaces\InvocationStrategyInterface foundHandler
+ * @property-read callable errorHandler
+ * @property-read callable notFoundHandler
+ * @property-read callable notAllowedHandler
+ * @property-read \Slim\Interfaces\CallableResolverInterface callableResolver
+ */
+class Container extends PimpleContainer implements ContainerInterface
+{
+    /**
+     * Default settings
+     *
+     * @var array
+     */
+    private $defaultSettings = [
+        'httpVersion' => '1.1',
+        'responseChunkSize' => 4096,
+        'outputBuffering' => 'append',
+        'determineRouteBeforeAppMiddleware' => false,
+        'displayErrorDetails' => false,
+        'addContentLengthHeader' => true,
+        'routerCacheFile' => false,
+    ];
+
+    /**
+     * Create new container
+     *
+     * @param array $values The parameters or objects.
+     */
+    public function __construct(array $values = [])
+    {
+        parent::__construct($values);
+
+        $userSettings = isset($values['settings']) ? $values['settings'] : [];
+        $this->registerDefaultServices($userSettings);
+    }
+
+    /**
+     * This function registers the default services that Slim needs to work.
+     *
+     * All services are shared - that is, they are registered such that the
+     * same instance is returned on subsequent calls.
+     *
+     * @param array $userSettings Associative array of application settings
+     *
+     * @return void
+     */
+    private function registerDefaultServices($userSettings)
+    {
+        $defaultSettings = $this->defaultSettings;
+
+        /**
+         * This service MUST return an array or an
+         * instance of \ArrayAccess.
+         *
+         * @return array|\ArrayAccess
+         */
+        $this['settings'] = function () use ($userSettings, $defaultSettings) {
+            return new Collection(array_merge($defaultSettings, $userSettings));
+        };
+
+        $defaultProvider = new DefaultServicesProvider();
+        $defaultProvider->register($this);
+    }
+
+    /********************************************************************************
+     * Methods to satisfy Interop\Container\ContainerInterface
+     *******************************************************************************/
+
+    /**
+     * Finds an entry of the container by its identifier and returns it.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @throws ContainerValueNotFoundException  No entry was found for this identifier.
+     * @throws ContainerException               Error while retrieving the entry.
+     *
+     * @return mixed Entry.
+     */
+    public function get($id)
+    {
+        if (!$this->offsetExists($id)) {
+            throw new ContainerValueNotFoundException(sprintf('Identifier "%s" is not defined.', $id));
+        }
+        try {
+            return $this->offsetGet($id);
+        } catch (\InvalidArgumentException $exception) {
+            if ($this->exceptionThrownByContainer($exception)) {
+                throw new SlimContainerException(
+                    sprintf('Container error while retrieving "%s"', $id),
+                    null,
+                    $exception
+                );
+            } else {
+                throw $exception;
+            }
+        }
+    }
+
+    /**
+     * Tests whether an exception needs to be recast for compliance with Container-Interop.  This will be if the
+     * exception was thrown by Pimple.
+     *
+     * @param \InvalidArgumentException $exception
+     *
+     * @return bool
+     */
+    private function exceptionThrownByContainer(\InvalidArgumentException $exception)
+    {
+        $trace = $exception->getTrace()[0];
+
+        return $trace['class'] === PimpleContainer::class && $trace['function'] === 'offsetGet';
+    }
+
+    /**
+     * Returns true if the container can return an entry for the given identifier.
+     * Returns false otherwise.
+     *
+     * @param string $id Identifier of the entry to look for.
+     *
+     * @return boolean
+     */
+    public function has($id)
+    {
+        return $this->offsetExists($id);
+    }
+
+
+    /********************************************************************************
+     * Magic methods for convenience
+     *******************************************************************************/
+
+    public function __get($name)
+    {
+        return $this->get($name);
+    }
+
+    public function __isset($name)
+    {
+        return $this->has($name);
+    }
+}
diff --git a/vendor/slim/slim/Slim/DefaultServicesProvider.php b/vendor/slim/slim/Slim/DefaultServicesProvider.php
new file mode 100644
index 0000000..7087e4e
--- /dev/null
+++ b/vendor/slim/slim/Slim/DefaultServicesProvider.php
@@ -0,0 +1,209 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Slim\Handlers\PhpError;
+use Slim\Handlers\Error;
+use Slim\Handlers\NotFound;
+use Slim\Handlers\NotAllowed;
+use Slim\Handlers\Strategies\RequestResponse;
+use Slim\Http\Environment;
+use Slim\Http\Headers;
+use Slim\Http\Request;
+use Slim\Http\Response;
+use Slim\Interfaces\CallableResolverInterface;
+use Slim\Interfaces\Http\EnvironmentInterface;
+use Slim\Interfaces\InvocationStrategyInterface;
+use Slim\Interfaces\RouterInterface;
+
+/**
+ * Slim's default Service Provider.
+ */
+class DefaultServicesProvider
+{
+    /**
+     * Register Slim's default services.
+     *
+     * @param Container $container A DI container implementing ArrayAccess and container-interop.
+     */
+    public function register($container)
+    {
+        if (!isset($container['environment'])) {
+            /**
+             * This service MUST return a shared instance
+             * of \Slim\Interfaces\Http\EnvironmentInterface.
+             *
+             * @return EnvironmentInterface
+             */
+            $container['environment'] = function () {
+                return new Environment($_SERVER);
+            };
+        }
+
+        if (!isset($container['request'])) {
+            /**
+             * PSR-7 Request object
+             *
+             * @param Container $container
+             *
+             * @return ServerRequestInterface
+             */
+            $container['request'] = function ($container) {
+                return Request::createFromEnvironment($container->get('environment'));
+            };
+        }
+
+        if (!isset($container['response'])) {
+            /**
+             * PSR-7 Response object
+             *
+             * @param Container $container
+             *
+             * @return ResponseInterface
+             */
+            $container['response'] = function ($container) {
+                $headers = new Headers(['Content-Type' => 'text/html; charset=UTF-8']);
+                $response = new Response(200, $headers);
+
+                return $response->withProtocolVersion($container->get('settings')['httpVersion']);
+            };
+        }
+
+        if (!isset($container['router'])) {
+            /**
+             * This service MUST return a SHARED instance
+             * of \Slim\Interfaces\RouterInterface.
+             *
+             * @param Container $container
+             *
+             * @return RouterInterface
+             */
+            $container['router'] = function ($container) {
+                $routerCacheFile = false;
+                if (isset($container->get('settings')['routerCacheFile'])) {
+                    $routerCacheFile = $container->get('settings')['routerCacheFile'];
+                }
+
+
+                $router = (new Router)->setCacheFile($routerCacheFile);
+                if (method_exists($router, 'setContainer')) {
+                    $router->setContainer($container);
+                }
+
+                return $router;
+            };
+        }
+
+        if (!isset($container['foundHandler'])) {
+            /**
+             * This service MUST return a SHARED instance
+             * of \Slim\Interfaces\InvocationStrategyInterface.
+             *
+             * @return InvocationStrategyInterface
+             */
+            $container['foundHandler'] = function () {
+                return new RequestResponse;
+            };
+        }
+
+        if (!isset($container['phpErrorHandler'])) {
+            /**
+             * This service MUST return a callable
+             * that accepts three arguments:
+             *
+             * 1. Instance of \Psr\Http\Message\ServerRequestInterface
+             * 2. Instance of \Psr\Http\Message\ResponseInterface
+             * 3. Instance of \Error
+             *
+             * The callable MUST return an instance of
+             * \Psr\Http\Message\ResponseInterface.
+             *
+             * @param Container $container
+             *
+             * @return callable
+             */
+            $container['phpErrorHandler'] = function ($container) {
+                return new PhpError($container->get('settings')['displayErrorDetails']);
+            };
+        }
+
+        if (!isset($container['errorHandler'])) {
+            /**
+             * This service MUST return a callable
+             * that accepts three arguments:
+             *
+             * 1. Instance of \Psr\Http\Message\ServerRequestInterface
+             * 2. Instance of \Psr\Http\Message\ResponseInterface
+             * 3. Instance of \Exception
+             *
+             * The callable MUST return an instance of
+             * \Psr\Http\Message\ResponseInterface.
+             *
+             * @param Container $container
+             *
+             * @return callable
+             */
+            $container['errorHandler'] = function ($container) {
+                return new Error($container->get('settings')['displayErrorDetails']);
+            };
+        }
+
+        if (!isset($container['notFoundHandler'])) {
+            /**
+             * This service MUST return a callable
+             * that accepts two arguments:
+             *
+             * 1. Instance of \Psr\Http\Message\ServerRequestInterface
+             * 2. Instance of \Psr\Http\Message\ResponseInterface
+             *
+             * The callable MUST return an instance of
+             * \Psr\Http\Message\ResponseInterface.
+             *
+             * @return callable
+             */
+            $container['notFoundHandler'] = function () {
+                return new NotFound;
+            };
+        }
+
+        if (!isset($container['notAllowedHandler'])) {
+            /**
+             * This service MUST return a callable
+             * that accepts three arguments:
+             *
+             * 1. Instance of \Psr\Http\Message\ServerRequestInterface
+             * 2. Instance of \Psr\Http\Message\ResponseInterface
+             * 3. Array of allowed HTTP methods
+             *
+             * The callable MUST return an instance of
+             * \Psr\Http\Message\ResponseInterface.
+             *
+             * @return callable
+             */
+            $container['notAllowedHandler'] = function () {
+                return new NotAllowed;
+            };
+        }
+
+        if (!isset($container['callableResolver'])) {
+            /**
+             * Instance of \Slim\Interfaces\CallableResolverInterface
+             *
+             * @param Container $container
+             *
+             * @return CallableResolverInterface
+             */
+            $container['callableResolver'] = function ($container) {
+                return new CallableResolver($container);
+            };
+        }
+    }
+}
diff --git a/vendor/slim/slim/Slim/DeferredCallable.php b/vendor/slim/slim/Slim/DeferredCallable.php
new file mode 100644
index 0000000..22887c0
--- /dev/null
+++ b/vendor/slim/slim/Slim/DeferredCallable.php
@@ -0,0 +1,45 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+
+namespace Slim;
+
+use Closure;
+use Psr\Container\ContainerInterface;
+
+class DeferredCallable
+{
+    use CallableResolverAwareTrait;
+
+    private $callable;
+    /** @var  ContainerInterface */
+    private $container;
+
+    /**
+     * DeferredMiddleware constructor.
+     * @param callable|string $callable
+     * @param ContainerInterface $container
+     */
+    public function __construct($callable, ContainerInterface $container = null)
+    {
+        $this->callable = $callable;
+        $this->container = $container;
+    }
+
+    public function __invoke()
+    {
+        $callable = $this->resolveCallable($this->callable);
+        if ($callable instanceof Closure) {
+            $callable = $callable->bindTo($this->container);
+        }
+
+        $args = func_get_args();
+
+        return call_user_func_array($callable, $args);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Exception/ContainerException.php b/vendor/slim/slim/Slim/Exception/ContainerException.php
new file mode 100644
index 0000000..b147eb9
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/ContainerException.php
@@ -0,0 +1,20 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE (MIT License)
+ */
+namespace Slim\Exception;
+
+use InvalidArgumentException;
+use Interop\Container\Exception\ContainerException as InteropContainerException;
+
+/**
+ * Container Exception
+ */
+class ContainerException extends InvalidArgumentException implements InteropContainerException
+{
+
+}
diff --git a/vendor/slim/slim/Slim/Exception/ContainerValueNotFoundException.php b/vendor/slim/slim/Slim/Exception/ContainerValueNotFoundException.php
new file mode 100644
index 0000000..c5033b6
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/ContainerValueNotFoundException.php
@@ -0,0 +1,20 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE (MIT License)
+ */
+namespace Slim\Exception;
+
+use RuntimeException;
+use Interop\Container\Exception\NotFoundException as InteropNotFoundException;
+
+/**
+ * Not Found Exception
+ */
+class ContainerValueNotFoundException extends RuntimeException implements InteropNotFoundException
+{
+
+}
diff --git a/vendor/slim/slim/Slim/Exception/InvalidMethodException.php b/vendor/slim/slim/Slim/Exception/InvalidMethodException.php
new file mode 100644
index 0000000..238bf7a
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/InvalidMethodException.php
@@ -0,0 +1,21 @@
+<?php
+
+namespace Slim\Exception;
+
+use Psr\Http\Message\ServerRequestInterface;
+
+class InvalidMethodException extends \InvalidArgumentException
+{
+    protected $request;
+
+    public function __construct(ServerRequestInterface $request, $method)
+    {
+        $this->request = $request;
+        parent::__construct(sprintf('Unsupported HTTP method "%s" provided', $method));
+    }
+
+    public function getRequest()
+    {
+        return $this->request;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Exception/MethodNotAllowedException.php b/vendor/slim/slim/Slim/Exception/MethodNotAllowedException.php
new file mode 100644
index 0000000..e73b99e
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/MethodNotAllowedException.php
@@ -0,0 +1,45 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE (MIT License)
+ */
+namespace Slim\Exception;
+
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+
+class MethodNotAllowedException extends SlimException
+{
+    /**
+     * HTTP methods allowed
+     *
+     * @var string[]
+     */
+    protected $allowedMethods;
+
+    /**
+     * Create new exception
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface $response
+     * @param string[] $allowedMethods
+     */
+    public function __construct(ServerRequestInterface $request, ResponseInterface $response, array $allowedMethods)
+    {
+        parent::__construct($request, $response);
+        $this->allowedMethods = $allowedMethods;
+    }
+
+    /**
+     * Get allowed methods
+     *
+     * @return string[]
+     */
+    public function getAllowedMethods()
+    {
+        return $this->allowedMethods;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Exception/NotFoundException.php b/vendor/slim/slim/Slim/Exception/NotFoundException.php
new file mode 100644
index 0000000..8095eac
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/NotFoundException.php
@@ -0,0 +1,14 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE (MIT License)
+ */
+namespace Slim\Exception;
+
+class NotFoundException extends SlimException
+{
+
+}
diff --git a/vendor/slim/slim/Slim/Exception/SlimException.php b/vendor/slim/slim/Slim/Exception/SlimException.php
new file mode 100644
index 0000000..2480d73
--- /dev/null
+++ b/vendor/slim/slim/Slim/Exception/SlimException.php
@@ -0,0 +1,69 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Exception;
+
+use Exception;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Stop Exception
+ *
+ * This Exception is thrown when the Slim application needs to abort
+ * processing and return control flow to the outer PHP script.
+ */
+class SlimException extends Exception
+{
+    /**
+     * A request object
+     *
+     * @var ServerRequestInterface
+     */
+    protected $request;
+
+    /**
+     * A response object to send to the HTTP client
+     *
+     * @var ResponseInterface
+     */
+    protected $response;
+
+    /**
+     * Create new exception
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface $response
+     */
+    public function __construct(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        parent::__construct();
+        $this->request = $request;
+        $this->response = $response;
+    }
+
+    /**
+     * Get request
+     *
+     * @return ServerRequestInterface
+     */
+    public function getRequest()
+    {
+        return $this->request;
+    }
+
+    /**
+     * Get response
+     *
+     * @return ResponseInterface
+     */
+    public function getResponse()
+    {
+        return $this->response;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/AbstractError.php b/vendor/slim/slim/Slim/Handlers/AbstractError.php
new file mode 100644
index 0000000..42f8dde
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/AbstractError.php
@@ -0,0 +1,99 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+/**
+ * Abstract Slim application error handler
+ */
+abstract class AbstractError extends AbstractHandler
+{
+    /**
+     * @var bool
+     */
+    protected $displayErrorDetails;
+
+    /**
+     * Constructor
+     *
+     * @param bool $displayErrorDetails Set to true to display full details
+     */
+    public function __construct($displayErrorDetails = false)
+    {
+        $this->displayErrorDetails = (bool) $displayErrorDetails;
+    }
+
+    /**
+     * Write to the error log if displayErrorDetails is false
+     *
+     * @param \Exception|\Throwable $throwable
+     *
+     * @return void
+     */
+    protected function writeToErrorLog($throwable)
+    {
+        if ($this->displayErrorDetails) {
+            return;
+        }
+
+        $message = 'Slim Application Error:' . PHP_EOL;
+        $message .= $this->renderThrowableAsText($throwable);
+        while ($throwable = $throwable->getPrevious()) {
+            $message .= PHP_EOL . 'Previous error:' . PHP_EOL;
+            $message .= $this->renderThrowableAsText($throwable);
+        }
+
+        $message .= PHP_EOL . 'View in rendered output by enabling the "displayErrorDetails" setting.' . PHP_EOL;
+
+        $this->logError($message);
+    }
+
+    /**
+     * Render error as Text.
+     *
+     * @param \Exception|\Throwable $throwable
+     *
+     * @return string
+     */
+    protected function renderThrowableAsText($throwable)
+    {
+        $text = sprintf('Type: %s' . PHP_EOL, get_class($throwable));
+
+        if ($code = $throwable->getCode()) {
+            $text .= sprintf('Code: %s' . PHP_EOL, $code);
+        }
+
+        if ($message = $throwable->getMessage()) {
+            $text .= sprintf('Message: %s' . PHP_EOL, htmlentities($message));
+        }
+
+        if ($file = $throwable->getFile()) {
+            $text .= sprintf('File: %s' . PHP_EOL, $file);
+        }
+
+        if ($line = $throwable->getLine()) {
+            $text .= sprintf('Line: %s' . PHP_EOL, $line);
+        }
+
+        if ($trace = $throwable->getTraceAsString()) {
+            $text .= sprintf('Trace: %s', $trace);
+        }
+
+        return $text;
+    }
+
+    /**
+     * Wraps the error_log function so that this can be easily tested
+     *
+     * @param $message
+     */
+    protected function logError($message)
+    {
+        error_log($message);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/AbstractHandler.php b/vendor/slim/slim/Slim/Handlers/AbstractHandler.php
new file mode 100644
index 0000000..b166a15
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/AbstractHandler.php
@@ -0,0 +1,59 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+use Psr\Http\Message\ServerRequestInterface;
+
+/**
+ * Abstract Slim application handler
+ */
+abstract class AbstractHandler
+{
+    /**
+     * Known handled content types
+     *
+     * @var array
+     */
+    protected $knownContentTypes = [
+        'application/json',
+        'application/xml',
+        'text/xml',
+        'text/html',
+    ];
+
+    /**
+     * Determine which content type we know about is wanted using Accept header
+     *
+     * Note: This method is a bare-bones implementation designed specifically for
+     * Slim's error handling requirements. Consider a fully-feature solution such
+     * as willdurand/negotiation for any other situation.
+     *
+     * @param ServerRequestInterface $request
+     * @return string
+     */
+    protected function determineContentType(ServerRequestInterface $request)
+    {
+        $acceptHeader = $request->getHeaderLine('Accept');
+        $selectedContentTypes = array_intersect(explode(',', $acceptHeader), $this->knownContentTypes);
+
+        if (count($selectedContentTypes)) {
+            return current($selectedContentTypes);
+        }
+
+        // handle +json and +xml specially
+        if (preg_match('/\+(json|xml)/', $acceptHeader, $matches)) {
+            $mediaType = 'application/' . $matches[1];
+            if (in_array($mediaType, $this->knownContentTypes)) {
+                return $mediaType;
+            }
+        }
+
+        return 'text/html';
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/Error.php b/vendor/slim/slim/Slim/Handlers/Error.php
new file mode 100644
index 0000000..dd0bc8d
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/Error.php
@@ -0,0 +1,224 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Slim\Http\Body;
+use UnexpectedValueException;
+
+/**
+ * Default Slim application error handler
+ *
+ * It outputs the error message and diagnostic information in either JSON, XML,
+ * or HTML based on the Accept header.
+ */
+class Error extends AbstractError
+{
+    /**
+     * Invoke error handler
+     *
+     * @param ServerRequestInterface $request   The most recent Request object
+     * @param ResponseInterface      $response  The most recent Response object
+     * @param \Exception             $exception The caught Exception object
+     *
+     * @return ResponseInterface
+     * @throws UnexpectedValueException
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, \Exception $exception)
+    {
+        $contentType = $this->determineContentType($request);
+        switch ($contentType) {
+            case 'application/json':
+                $output = $this->renderJsonErrorMessage($exception);
+                break;
+
+            case 'text/xml':
+            case 'application/xml':
+                $output = $this->renderXmlErrorMessage($exception);
+                break;
+
+            case 'text/html':
+                $output = $this->renderHtmlErrorMessage($exception);
+                break;
+
+            default:
+                throw new UnexpectedValueException('Cannot render unknown content type ' . $contentType);
+        }
+
+        $this->writeToErrorLog($exception);
+
+        $body = new Body(fopen('php://temp', 'r+'));
+        $body->write($output);
+
+        return $response
+                ->withStatus(500)
+                ->withHeader('Content-type', $contentType)
+                ->withBody($body);
+    }
+
+    /**
+     * Render HTML error page
+     *
+     * @param  \Exception $exception
+     *
+     * @return string
+     */
+    protected function renderHtmlErrorMessage(\Exception $exception)
+    {
+        $title = 'Slim Application Error';
+
+        if ($this->displayErrorDetails) {
+            $html = '<p>The application could not run because of the following error:</p>';
+            $html .= '<h2>Details</h2>';
+            $html .= $this->renderHtmlException($exception);
+
+            while ($exception = $exception->getPrevious()) {
+                $html .= '<h2>Previous exception</h2>';
+                $html .= $this->renderHtmlExceptionOrError($exception);
+            }
+        } else {
+            $html = '<p>A website error has occurred. Sorry for the temporary inconvenience.</p>';
+        }
+
+        $output = sprintf(
+            "<html><head><meta http-equiv='Content-Type' content='text/html; charset=utf-8'>" .
+            "<title>%s</title><style>body{margin:0;padding:30px;font:12px/1.5 Helvetica,Arial,Verdana," .
+            "sans-serif;}h1{margin:0;font-size:48px;font-weight:normal;line-height:48px;}strong{" .
+            "display:inline-block;width:65px;}</style></head><body><h1>%s</h1>%s</body></html>",
+            $title,
+            $title,
+            $html
+        );
+
+        return $output;
+    }
+
+    /**
+     * Render exception as HTML.
+     *
+     * Provided for backwards compatibility; use renderHtmlExceptionOrError().
+     *
+     * @param \Exception $exception
+     *
+     * @return string
+     */
+    protected function renderHtmlException(\Exception $exception)
+    {
+        return $this->renderHtmlExceptionOrError($exception);
+    }
+
+    /**
+     * Render exception or error as HTML.
+     *
+     * @param \Exception|\Error $exception
+     *
+     * @return string
+     */
+    protected function renderHtmlExceptionOrError($exception)
+    {
+        if (!$exception instanceof \Exception && !$exception instanceof \Error) {
+            throw new \RuntimeException("Unexpected type. Expected Exception or Error.");
+        }
+
+        $html = sprintf('<div><strong>Type:</strong> %s</div>', get_class($exception));
+
+        if (($code = $exception->getCode())) {
+            $html .= sprintf('<div><strong>Code:</strong> %s</div>', $code);
+        }
+
+        if (($message = $exception->getMessage())) {
+            $html .= sprintf('<div><strong>Message:</strong> %s</div>', htmlentities($message));
+        }
+
+        if (($file = $exception->getFile())) {
+            $html .= sprintf('<div><strong>File:</strong> %s</div>', $file);
+        }
+
+        if (($line = $exception->getLine())) {
+            $html .= sprintf('<div><strong>Line:</strong> %s</div>', $line);
+        }
+
+        if (($trace = $exception->getTraceAsString())) {
+            $html .= '<h2>Trace</h2>';
+            $html .= sprintf('<pre>%s</pre>', htmlentities($trace));
+        }
+
+        return $html;
+    }
+
+    /**
+     * Render JSON error
+     *
+     * @param \Exception $exception
+     *
+     * @return string
+     */
+    protected function renderJsonErrorMessage(\Exception $exception)
+    {
+        $error = [
+            'message' => 'Slim Application Error',
+        ];
+
+        if ($this->displayErrorDetails) {
+            $error['exception'] = [];
+
+            do {
+                $error['exception'][] = [
+                    'type' => get_class($exception),
+                    'code' => $exception->getCode(),
+                    'message' => $exception->getMessage(),
+                    'file' => $exception->getFile(),
+                    'line' => $exception->getLine(),
+                    'trace' => explode("\n", $exception->getTraceAsString()),
+                ];
+            } while ($exception = $exception->getPrevious());
+        }
+
+        return json_encode($error, JSON_PRETTY_PRINT);
+    }
+
+    /**
+     * Render XML error
+     *
+     * @param \Exception $exception
+     *
+     * @return string
+     */
+    protected function renderXmlErrorMessage(\Exception $exception)
+    {
+        $xml = "<error>\n  <message>Slim Application Error</message>\n";
+        if ($this->displayErrorDetails) {
+            do {
+                $xml .= "  <exception>\n";
+                $xml .= "    <type>" . get_class($exception) . "</type>\n";
+                $xml .= "    <code>" . $exception->getCode() . "</code>\n";
+                $xml .= "    <message>" . $this->createCdataSection($exception->getMessage()) . "</message>\n";
+                $xml .= "    <file>" . $exception->getFile() . "</file>\n";
+                $xml .= "    <line>" . $exception->getLine() . "</line>\n";
+                $xml .= "    <trace>" . $this->createCdataSection($exception->getTraceAsString()) . "</trace>\n";
+                $xml .= "  </exception>\n";
+            } while ($exception = $exception->getPrevious());
+        }
+        $xml .= "</error>";
+
+        return $xml;
+    }
+
+    /**
+     * Returns a CDATA section with the given content.
+     *
+     * @param  string $content
+     * @return string
+     */
+    private function createCdataSection($content)
+    {
+        return sprintf('<![CDATA[%s]]>', str_replace(']]>', ']]]]><![CDATA[>', $content));
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/NotAllowed.php b/vendor/slim/slim/Slim/Handlers/NotAllowed.php
new file mode 100644
index 0000000..9f382c4
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/NotAllowed.php
@@ -0,0 +1,147 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+use Slim\Http\Body;
+use UnexpectedValueException;
+
+/**
+ * Default Slim application not allowed handler
+ *
+ * It outputs a simple message in either JSON, XML or HTML based on the
+ * Accept header.
+ */
+class NotAllowed extends AbstractHandler
+{
+    /**
+     * Invoke error handler
+     *
+     * @param  ServerRequestInterface $request  The most recent Request object
+     * @param  ResponseInterface      $response The most recent Response object
+     * @param  string[]               $methods  Allowed HTTP methods
+     *
+     * @return ResponseInterface
+     * @throws UnexpectedValueException
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, array $methods)
+    {
+        if ($request->getMethod() === 'OPTIONS') {
+            $status = 200;
+            $contentType = 'text/plain';
+            $output = $this->renderPlainNotAllowedMessage($methods);
+        } else {
+            $status = 405;
+            $contentType = $this->determineContentType($request);
+            switch ($contentType) {
+                case 'application/json':
+                    $output = $this->renderJsonNotAllowedMessage($methods);
+                    break;
+
+                case 'text/xml':
+                case 'application/xml':
+                    $output = $this->renderXmlNotAllowedMessage($methods);
+                    break;
+
+                case 'text/html':
+                    $output = $this->renderHtmlNotAllowedMessage($methods);
+                    break;
+                default:
+                    throw new UnexpectedValueException('Cannot render unknown content type ' . $contentType);
+            }
+        }
+
+        $body = new Body(fopen('php://temp', 'r+'));
+        $body->write($output);
+        $allow = implode(', ', $methods);
+
+        return $response
+                ->withStatus($status)
+                ->withHeader('Content-type', $contentType)
+                ->withHeader('Allow', $allow)
+                ->withBody($body);
+    }
+
+    /**
+     * Render PLAIN not allowed message
+     *
+     * @param  array                  $methods
+     * @return string
+     */
+    protected function renderPlainNotAllowedMessage($methods)
+    {
+        $allow = implode(', ', $methods);
+
+        return 'Allowed methods: ' . $allow;
+    }
+
+    /**
+     * Render JSON not allowed message
+     *
+     * @param  array                  $methods
+     * @return string
+     */
+    protected function renderJsonNotAllowedMessage($methods)
+    {
+        $allow = implode(', ', $methods);
+
+        return '{"message":"Method not allowed. Must be one of: ' . $allow . '"}';
+    }
+
+    /**
+     * Render XML not allowed message
+     *
+     * @param  array                  $methods
+     * @return string
+     */
+    protected function renderXmlNotAllowedMessage($methods)
+    {
+        $allow = implode(', ', $methods);
+
+        return "<root><message>Method not allowed. Must be one of: $allow</message></root>";
+    }
+
+    /**
+     * Render HTML not allowed message
+     *
+     * @param  array                  $methods
+     * @return string
+     */
+    protected function renderHtmlNotAllowedMessage($methods)
+    {
+        $allow = implode(', ', $methods);
+        $output = <<<END
+<html>
+    <head>
+        <title>Method not allowed</title>
+        <style>
+            body{
+                margin:0;
+                padding:30px;
+                font:12px/1.5 Helvetica,Arial,Verdana,sans-serif;
+            }
+            h1{
+                margin:0;
+                font-size:48px;
+                font-weight:normal;
+                line-height:48px;
+            }
+        </style>
+    </head>
+    <body>
+        <h1>Method not allowed</h1>
+        <p>Method not allowed. Must be one of: <strong>$allow</strong></p>
+    </body>
+</html>
+END;
+
+        return $output;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/NotFound.php b/vendor/slim/slim/Slim/Handlers/NotFound.php
new file mode 100644
index 0000000..d4a9dec
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/NotFound.php
@@ -0,0 +1,126 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+use Slim\Http\Body;
+use UnexpectedValueException;
+
+/**
+ * Default Slim application not found handler.
+ *
+ * It outputs a simple message in either JSON, XML or HTML based on the
+ * Accept header.
+ */
+class NotFound extends AbstractHandler
+{
+    /**
+     * Invoke not found handler
+     *
+     * @param  ServerRequestInterface $request  The most recent Request object
+     * @param  ResponseInterface      $response The most recent Response object
+     *
+     * @return ResponseInterface
+     * @throws UnexpectedValueException
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        $contentType = $this->determineContentType($request);
+        switch ($contentType) {
+            case 'application/json':
+                $output = $this->renderJsonNotFoundOutput();
+                break;
+
+            case 'text/xml':
+            case 'application/xml':
+                $output = $this->renderXmlNotFoundOutput();
+                break;
+
+            case 'text/html':
+                $output = $this->renderHtmlNotFoundOutput($request);
+                break;
+
+            default:
+                throw new UnexpectedValueException('Cannot render unknown content type ' . $contentType);
+        }
+
+        $body = new Body(fopen('php://temp', 'r+'));
+        $body->write($output);
+
+        return $response->withStatus(404)
+                        ->withHeader('Content-Type', $contentType)
+                        ->withBody($body);
+    }
+
+    /**
+     * Return a response for application/json content not found
+     *
+     * @return ResponseInterface
+     */
+    protected function renderJsonNotFoundOutput()
+    {
+        return '{"message":"Not found"}';
+    }
+
+    /**
+     * Return a response for xml content not found
+     *
+     * @return ResponseInterface
+     */
+    protected function renderXmlNotFoundOutput()
+    {
+        return '<root><message>Not found</message></root>';
+    }
+
+    /**
+     * Return a response for text/html content not found
+     *
+     * @param  ServerRequestInterface $request  The most recent Request object
+     *
+     * @return ResponseInterface
+     */
+    protected function renderHtmlNotFoundOutput(ServerRequestInterface $request)
+    {
+        $homeUrl = (string)($request->getUri()->withPath('')->withQuery('')->withFragment(''));
+        return <<<END
+<html>
+    <head>
+        <title>Page Not Found</title>
+        <style>
+            body{
+                margin:0;
+                padding:30px;
+                font:12px/1.5 Helvetica,Arial,Verdana,sans-serif;
+            }
+            h1{
+                margin:0;
+                font-size:48px;
+                font-weight:normal;
+                line-height:48px;
+            }
+            strong{
+                display:inline-block;
+                width:65px;
+            }
+        </style>
+    </head>
+    <body>
+        <h1>Page Not Found</h1>
+        <p>
+            The page you are looking for could not be found. Check the address bar
+            to ensure your URL is spelled correctly. If all else fails, you can
+            visit our home page at the link below.
+        </p>
+        <a href='$homeUrl'>Visit the Home Page</a>
+    </body>
+</html>
+END;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/PhpError.php b/vendor/slim/slim/Slim/Handlers/PhpError.php
new file mode 100644
index 0000000..3ecce30
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/PhpError.php
@@ -0,0 +1,205 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Slim\Http\Body;
+use UnexpectedValueException;
+
+/**
+ * Default Slim application error handler for PHP 7+ Throwables
+ *
+ * It outputs the error message and diagnostic information in either JSON, XML,
+ * or HTML based on the Accept header.
+ */
+class PhpError extends AbstractError
+{
+    /**
+     * Invoke error handler
+     *
+     * @param ServerRequestInterface $request   The most recent Request object
+     * @param ResponseInterface      $response  The most recent Response object
+     * @param \Throwable             $error     The caught Throwable object
+     *
+     * @return ResponseInterface
+     * @throws UnexpectedValueException
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, \Throwable $error)
+    {
+        $contentType = $this->determineContentType($request);
+        switch ($contentType) {
+            case 'application/json':
+                $output = $this->renderJsonErrorMessage($error);
+                break;
+
+            case 'text/xml':
+            case 'application/xml':
+                $output = $this->renderXmlErrorMessage($error);
+                break;
+
+            case 'text/html':
+                $output = $this->renderHtmlErrorMessage($error);
+                break;
+            default:
+                throw new UnexpectedValueException('Cannot render unknown content type ' . $contentType);
+        }
+
+        $this->writeToErrorLog($error);
+
+        $body = new Body(fopen('php://temp', 'r+'));
+        $body->write($output);
+
+        return $response
+                ->withStatus(500)
+                ->withHeader('Content-type', $contentType)
+                ->withBody($body);
+    }
+
+    /**
+     * Render HTML error page
+     *
+     * @param \Throwable $error
+     *
+     * @return string
+     */
+    protected function renderHtmlErrorMessage(\Throwable $error)
+    {
+        $title = 'Slim Application Error';
+
+        if ($this->displayErrorDetails) {
+            $html = '<p>The application could not run because of the following error:</p>';
+            $html .= '<h2>Details</h2>';
+            $html .= $this->renderHtmlError($error);
+
+            while ($error = $error->getPrevious()) {
+                $html .= '<h2>Previous error</h2>';
+                $html .= $this->renderHtmlError($error);
+            }
+        } else {
+            $html = '<p>A website error has occurred. Sorry for the temporary inconvenience.</p>';
+        }
+
+        $output = sprintf(
+            "<html><head><meta http-equiv='Content-Type' content='text/html; charset=utf-8'>" .
+            "<title>%s</title><style>body{margin:0;padding:30px;font:12px/1.5 Helvetica,Arial,Verdana," .
+            "sans-serif;}h1{margin:0;font-size:48px;font-weight:normal;line-height:48px;}strong{" .
+            "display:inline-block;width:65px;}</style></head><body><h1>%s</h1>%s</body></html>",
+            $title,
+            $title,
+            $html
+        );
+
+        return $output;
+    }
+
+    /**
+     * Render error as HTML.
+     *
+     * @param \Throwable $error
+     *
+     * @return string
+     */
+    protected function renderHtmlError(\Throwable $error)
+    {
+        $html = sprintf('<div><strong>Type:</strong> %s</div>', get_class($error));
+
+        if (($code = $error->getCode())) {
+            $html .= sprintf('<div><strong>Code:</strong> %s</div>', $code);
+        }
+
+        if (($message = $error->getMessage())) {
+            $html .= sprintf('<div><strong>Message:</strong> %s</div>', htmlentities($message));
+        }
+
+        if (($file = $error->getFile())) {
+            $html .= sprintf('<div><strong>File:</strong> %s</div>', $file);
+        }
+
+        if (($line = $error->getLine())) {
+            $html .= sprintf('<div><strong>Line:</strong> %s</div>', $line);
+        }
+
+        if (($trace = $error->getTraceAsString())) {
+            $html .= '<h2>Trace</h2>';
+            $html .= sprintf('<pre>%s</pre>', htmlentities($trace));
+        }
+
+        return $html;
+    }
+
+    /**
+     * Render JSON error
+     *
+     * @param \Throwable $error
+     *
+     * @return string
+     */
+    protected function renderJsonErrorMessage(\Throwable $error)
+    {
+        $json = [
+            'message' => 'Slim Application Error',
+        ];
+
+        if ($this->displayErrorDetails) {
+            $json['error'] = [];
+
+            do {
+                $json['error'][] = [
+                    'type' => get_class($error),
+                    'code' => $error->getCode(),
+                    'message' => $error->getMessage(),
+                    'file' => $error->getFile(),
+                    'line' => $error->getLine(),
+                    'trace' => explode("\n", $error->getTraceAsString()),
+                ];
+            } while ($error = $error->getPrevious());
+        }
+
+        return json_encode($json, JSON_PRETTY_PRINT);
+    }
+
+    /**
+     * Render XML error
+     *
+     * @param \Throwable $error
+     *
+     * @return string
+     */
+    protected function renderXmlErrorMessage(\Throwable $error)
+    {
+        $xml = "<error>\n  <message>Slim Application Error</message>\n";
+        if ($this->displayErrorDetails) {
+            do {
+                $xml .= "  <error>\n";
+                $xml .= "    <type>" . get_class($error) . "</type>\n";
+                $xml .= "    <code>" . $error->getCode() . "</code>\n";
+                $xml .= "    <message>" . $this->createCdataSection($error->getMessage()) . "</message>\n";
+                $xml .= "    <file>" . $error->getFile() . "</file>\n";
+                $xml .= "    <line>" . $error->getLine() . "</line>\n";
+                $xml .= "    <trace>" . $this->createCdataSection($error->getTraceAsString()) . "</trace>\n";
+                $xml .= "  </error>\n";
+            } while ($error = $error->getPrevious());
+        }
+        $xml .= "</error>";
+
+        return $xml;
+    }
+
+    /**
+     * Returns a CDATA section with the given content.
+     *
+     * @param  string $content
+     * @return string
+     */
+    private function createCdataSection($content)
+    {
+        return sprintf('<![CDATA[%s]]>', str_replace(']]>', ']]]]><![CDATA[>', $content));
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponse.php b/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponse.php
new file mode 100644
index 0000000..ad99b56
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponse.php
@@ -0,0 +1,43 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers\Strategies;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Slim\Interfaces\InvocationStrategyInterface;
+
+/**
+ * Default route callback strategy with route parameters as an array of arguments.
+ */
+class RequestResponse implements InvocationStrategyInterface
+{
+    /**
+     * Invoke a route callable with request, response, and all route parameters
+     * as an array of arguments.
+     *
+     * @param array|callable         $callable
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface      $response
+     * @param array                  $routeArguments
+     *
+     * @return mixed
+     */
+    public function __invoke(
+        callable $callable,
+        ServerRequestInterface $request,
+        ResponseInterface $response,
+        array $routeArguments
+    ) {
+        foreach ($routeArguments as $k => $v) {
+            $request = $request->withAttribute($k, $v);
+        }
+
+        return call_user_func($callable, $request, $response, $routeArguments);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponseArgs.php b/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponseArgs.php
new file mode 100644
index 0000000..739cc7e
--- /dev/null
+++ b/vendor/slim/slim/Slim/Handlers/Strategies/RequestResponseArgs.php
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Handlers\Strategies;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+use Slim\Interfaces\InvocationStrategyInterface;
+
+/**
+ * Route callback strategy with route parameters as individual arguments.
+ */
+class RequestResponseArgs implements InvocationStrategyInterface
+{
+
+    /**
+     * Invoke a route callable with request, response and all route parameters
+     * as individual arguments.
+     *
+     * @param array|callable         $callable
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface      $response
+     * @param array                  $routeArguments
+     *
+     * @return mixed
+     */
+    public function __invoke(
+        callable $callable,
+        ServerRequestInterface $request,
+        ResponseInterface $response,
+        array $routeArguments
+    ) {
+        array_unshift($routeArguments, $request, $response);
+
+        return call_user_func_array($callable, $routeArguments);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Body.php b/vendor/slim/slim/Slim/Http/Body.php
new file mode 100644
index 0000000..7a7b4df
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Body.php
@@ -0,0 +1,22 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+/**
+ * Body
+ *
+ * This class represents an HTTP message body and encapsulates a
+ * streamable resource according to the PSR-7 standard.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
+ */
+class Body extends Stream
+{
+
+}
diff --git a/vendor/slim/slim/Slim/Http/Cookies.php b/vendor/slim/slim/Slim/Http/Cookies.php
new file mode 100644
index 0000000..c07c96f
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Cookies.php
@@ -0,0 +1,195 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use InvalidArgumentException;
+use Slim\Interfaces\Http\CookiesInterface;
+
+/**
+ * Cookie helper
+ */
+class Cookies implements CookiesInterface
+{
+    /**
+     * Cookies from HTTP request
+     *
+     * @var array
+     */
+    protected $requestCookies = [];
+
+    /**
+     * Cookies for HTTP response
+     *
+     * @var array
+     */
+    protected $responseCookies = [];
+
+    /**
+     * Default cookie properties
+     *
+     * @var array
+     */
+    protected $defaults = [
+        'value' => '',
+        'domain' => null,
+        'hostonly' => null,
+        'path' => null,
+        'expires' => null,
+        'secure' => false,
+        'httponly' => false
+    ];
+
+    /**
+     * Create new cookies helper
+     *
+     * @param array $cookies
+     */
+    public function __construct(array $cookies = [])
+    {
+        $this->requestCookies = $cookies;
+    }
+
+    /**
+     * Set default cookie properties
+     *
+     * @param array $settings
+     */
+    public function setDefaults(array $settings)
+    {
+        $this->defaults = array_replace($this->defaults, $settings);
+    }
+
+    /**
+     * Get request cookie
+     *
+     * @param  string $name    Cookie name
+     * @param  mixed  $default Cookie default value
+     *
+     * @return mixed Cookie value if present, else default
+     */
+    public function get($name, $default = null)
+    {
+        return isset($this->requestCookies[$name]) ? $this->requestCookies[$name] : $default;
+    }
+
+    /**
+     * Set response cookie
+     *
+     * @param string       $name  Cookie name
+     * @param string|array $value Cookie value, or cookie properties
+     */
+    public function set($name, $value)
+    {
+        if (!is_array($value)) {
+            $value = ['value' => (string)$value];
+        }
+        $this->responseCookies[$name] = array_replace($this->defaults, $value);
+    }
+
+    /**
+     * Convert to `Set-Cookie` headers
+     *
+     * @return string[]
+     */
+    public function toHeaders()
+    {
+        $headers = [];
+        foreach ($this->responseCookies as $name => $properties) {
+            $headers[] = $this->toHeader($name, $properties);
+        }
+
+        return $headers;
+    }
+
+    /**
+     * Convert to `Set-Cookie` header
+     *
+     * @param  string $name       Cookie name
+     * @param  array  $properties Cookie properties
+     *
+     * @return string
+     */
+    protected function toHeader($name, array $properties)
+    {
+        $result = urlencode($name) . '=' . urlencode($properties['value']);
+
+        if (isset($properties['domain'])) {
+            $result .= '; domain=' . $properties['domain'];
+        }
+
+        if (isset($properties['path'])) {
+            $result .= '; path=' . $properties['path'];
+        }
+
+        if (isset($properties['expires'])) {
+            if (is_string($properties['expires'])) {
+                $timestamp = strtotime($properties['expires']);
+            } else {
+                $timestamp = (int)$properties['expires'];
+            }
+            if ($timestamp !== 0) {
+                $result .= '; expires=' . gmdate('D, d-M-Y H:i:s e', $timestamp);
+            }
+        }
+
+        if (isset($properties['secure']) && $properties['secure']) {
+            $result .= '; secure';
+        }
+
+        if (isset($properties['hostonly']) && $properties['hostonly']) {
+            $result .= '; HostOnly';
+        }
+
+        if (isset($properties['httponly']) && $properties['httponly']) {
+            $result .= '; HttpOnly';
+        }
+
+        return $result;
+    }
+
+    /**
+     * Parse HTTP request `Cookie:` header and extract
+     * into a PHP associative array.
+     *
+     * @param  string $header The raw HTTP request `Cookie:` header
+     *
+     * @return array Associative array of cookie names and values
+     *
+     * @throws InvalidArgumentException if the cookie data cannot be parsed
+     */
+    public static function parseHeader($header)
+    {
+        if (is_array($header) === true) {
+            $header = isset($header[0]) ? $header[0] : '';
+        }
+
+        if (is_string($header) === false) {
+            throw new InvalidArgumentException('Cannot parse Cookie data. Header value must be a string.');
+        }
+
+        $header = rtrim($header, "\r\n");
+        $pieces = preg_split('@[;]\s*@', $header);
+        $cookies = [];
+
+        foreach ($pieces as $cookie) {
+            $cookie = explode('=', $cookie, 2);
+
+            if (count($cookie) === 2) {
+                $key = urldecode($cookie[0]);
+                $value = urldecode($cookie[1]);
+
+                if (!isset($cookies[$key])) {
+                    $cookies[$key] = $value;
+                }
+            }
+        }
+
+        return $cookies;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Environment.php b/vendor/slim/slim/Slim/Http/Environment.php
new file mode 100644
index 0000000..786dc0a
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Environment.php
@@ -0,0 +1,52 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use Slim\Collection;
+use Slim\Interfaces\Http\EnvironmentInterface;
+
+/**
+ * Environment
+ *
+ * This class decouples the Slim application from the global PHP environment.
+ * This is particularly useful for unit testing, but it also lets us create
+ * custom sub-requests.
+ */
+class Environment extends Collection implements EnvironmentInterface
+{
+    /**
+     * Create mock environment
+     *
+     * @param  array $userData Array of custom environment keys and values
+     *
+     * @return self
+     */
+    public static function mock(array $userData = [])
+    {
+        $data = array_merge([
+            'SERVER_PROTOCOL'      => 'HTTP/1.1',
+            'REQUEST_METHOD'       => 'GET',
+            'SCRIPT_NAME'          => '',
+            'REQUEST_URI'          => '',
+            'QUERY_STRING'         => '',
+            'SERVER_NAME'          => 'localhost',
+            'SERVER_PORT'          => 80,
+            'HTTP_HOST'            => 'localhost',
+            'HTTP_ACCEPT'          => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
+            'HTTP_ACCEPT_LANGUAGE' => 'en-US,en;q=0.8',
+            'HTTP_ACCEPT_CHARSET'  => 'ISO-8859-1,utf-8;q=0.7,*;q=0.3',
+            'HTTP_USER_AGENT'      => 'Slim Framework',
+            'REMOTE_ADDR'          => '127.0.0.1',
+            'REQUEST_TIME'         => time(),
+            'REQUEST_TIME_FLOAT'   => microtime(true),
+        ], $userData);
+
+        return new static($data);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Headers.php b/vendor/slim/slim/Slim/Http/Headers.php
new file mode 100644
index 0000000..f8c4ac1
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Headers.php
@@ -0,0 +1,222 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use Slim\Collection;
+use Slim\Interfaces\Http\HeadersInterface;
+
+/**
+ * Headers
+ *
+ * This class represents a collection of HTTP headers
+ * that is used in both the HTTP request and response objects.
+ * It also enables header name case-insensitivity when
+ * getting or setting a header value.
+ *
+ * Each HTTP header can have multiple values. This class
+ * stores values into an array for each header name. When
+ * you request a header value, you receive an array of values
+ * for that header.
+ */
+class Headers extends Collection implements HeadersInterface
+{
+    /**
+     * Special HTTP headers that do not have the "HTTP_" prefix
+     *
+     * @var array
+     */
+    protected static $special = [
+        'CONTENT_TYPE' => 1,
+        'CONTENT_LENGTH' => 1,
+        'PHP_AUTH_USER' => 1,
+        'PHP_AUTH_PW' => 1,
+        'PHP_AUTH_DIGEST' => 1,
+        'AUTH_TYPE' => 1,
+    ];
+
+    /**
+     * Create new headers collection with data extracted from
+     * the application Environment object
+     *
+     * @param Environment $environment The Slim application Environment
+     *
+     * @return self
+     */
+    public static function createFromEnvironment(Environment $environment)
+    {
+        $data = [];
+        $environment = self::determineAuthorization($environment);
+        foreach ($environment as $key => $value) {
+            $key = strtoupper($key);
+            if (isset(static::$special[$key]) || strpos($key, 'HTTP_') === 0) {
+                if ($key !== 'HTTP_CONTENT_LENGTH') {
+                    $data[$key] =  $value;
+                }
+            }
+        }
+
+        return new static($data);
+    }
+
+    /**
+     * If HTTP_AUTHORIZATION does not exist tries to get it from
+     * getallheaders() when available.
+     *
+     * @param Environment $environment The Slim application Environment
+     *
+     * @return Environment
+     */
+
+    public static function determineAuthorization(Environment $environment)
+    {
+        $authorization = $environment->get('HTTP_AUTHORIZATION');
+
+        if (null === $authorization && is_callable('getallheaders')) {
+            $headers = getallheaders();
+            $headers = array_change_key_case($headers, CASE_LOWER);
+            if (isset($headers['authorization'])) {
+                $environment->set('HTTP_AUTHORIZATION', $headers['authorization']);
+            }
+        }
+
+        return $environment;
+    }
+
+    /**
+     * Return array of HTTP header names and values.
+     * This method returns the _original_ header name
+     * as specified by the end user.
+     *
+     * @return array
+     */
+    public function all()
+    {
+        $all = parent::all();
+        $out = [];
+        foreach ($all as $key => $props) {
+            $out[$props['originalKey']] = $props['value'];
+        }
+
+        return $out;
+    }
+
+    /**
+     * Set HTTP header value
+     *
+     * This method sets a header value. It replaces
+     * any values that may already exist for the header name.
+     *
+     * @param string $key   The case-insensitive header name
+     * @param string $value The header value
+     */
+    public function set($key, $value)
+    {
+        if (!is_array($value)) {
+            $value = [$value];
+        }
+        parent::set($this->normalizeKey($key), [
+            'value' => $value,
+            'originalKey' => $key
+        ]);
+    }
+
+    /**
+     * Get HTTP header value
+     *
+     * @param  string  $key     The case-insensitive header name
+     * @param  mixed   $default The default value if key does not exist
+     *
+     * @return string[]
+     */
+    public function get($key, $default = null)
+    {
+        if ($this->has($key)) {
+            return parent::get($this->normalizeKey($key))['value'];
+        }
+
+        return $default;
+    }
+
+    /**
+     * Get HTTP header key as originally specified
+     *
+     * @param  string   $key     The case-insensitive header name
+     * @param  mixed    $default The default value if key does not exist
+     *
+     * @return string
+     */
+    public function getOriginalKey($key, $default = null)
+    {
+        if ($this->has($key)) {
+            return parent::get($this->normalizeKey($key))['originalKey'];
+        }
+
+        return $default;
+    }
+
+    /**
+     * Add HTTP header value
+     *
+     * This method appends a header value. Unlike the set() method,
+     * this method _appends_ this new value to any values
+     * that already exist for this header name.
+     *
+     * @param string       $key   The case-insensitive header name
+     * @param array|string $value The new header value(s)
+     */
+    public function add($key, $value)
+    {
+        $oldValues = $this->get($key, []);
+        $newValues = is_array($value) ? $value : [$value];
+        $this->set($key, array_merge($oldValues, array_values($newValues)));
+    }
+
+    /**
+     * Does this collection have a given header?
+     *
+     * @param  string $key The case-insensitive header name
+     *
+     * @return bool
+     */
+    public function has($key)
+    {
+        return parent::has($this->normalizeKey($key));
+    }
+
+    /**
+     * Remove header from collection
+     *
+     * @param  string $key The case-insensitive header name
+     */
+    public function remove($key)
+    {
+        parent::remove($this->normalizeKey($key));
+    }
+
+    /**
+     * Normalize header name
+     *
+     * This method transforms header names into a
+     * normalized form. This is how we enable case-insensitive
+     * header names in the other methods in this class.
+     *
+     * @param  string $key The case-insensitive header name
+     *
+     * @return string Normalized header name
+     */
+    public function normalizeKey($key)
+    {
+        $key = strtr(strtolower($key), '_', '-');
+        if (strpos($key, 'http-') === 0) {
+            $key = substr($key, 5);
+        }
+
+        return $key;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Message.php b/vendor/slim/slim/Slim/Http/Message.php
new file mode 100644
index 0000000..d02a43c
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Message.php
@@ -0,0 +1,304 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use InvalidArgumentException;
+use Psr\Http\Message\MessageInterface;
+use Psr\Http\Message\StreamInterface;
+
+/**
+ * Abstract message (base class for Request and Response)
+ *
+ * This class represents a general HTTP message. It provides common properties and methods for
+ * the HTTP request and response, as defined in the PSR-7 MessageInterface.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
+ * @see Slim\Http\Request
+ * @see Slim\Http\Response
+ */
+abstract class Message implements MessageInterface
+{
+    /**
+     * Protocol version
+     *
+     * @var string
+     */
+    protected $protocolVersion = '1.1';
+
+    /**
+     * A map of valid protocol versions
+     *
+     * @var array
+     */
+    protected static $validProtocolVersions = [
+        '1.0' => true,
+        '1.1' => true,
+        '2.0' => true,
+    ];
+
+    /**
+     * Headers
+     *
+     * @var \Slim\Interfaces\Http\HeadersInterface
+     */
+    protected $headers;
+
+    /**
+     * Body object
+     *
+     * @var \Psr\Http\Message\StreamInterface
+     */
+    protected $body;
+
+
+    /**
+     * Disable magic setter to ensure immutability
+     */
+    public function __set($name, $value)
+    {
+        // Do nothing
+    }
+
+    /*******************************************************************************
+     * Protocol
+     ******************************************************************************/
+
+    /**
+     * Retrieves the HTTP protocol version as a string.
+     *
+     * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
+     *
+     * @return string HTTP protocol version.
+     */
+    public function getProtocolVersion()
+    {
+        return $this->protocolVersion;
+    }
+
+    /**
+     * Return an instance with the specified HTTP protocol version.
+     *
+     * The version string MUST contain only the HTTP version number (e.g.,
+     * "1.1", "1.0").
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new protocol version.
+     *
+     * @param string $version HTTP protocol version
+     * @return static
+     * @throws InvalidArgumentException if the http version is an invalid number
+     */
+    public function withProtocolVersion($version)
+    {
+        if (!isset(self::$validProtocolVersions[$version])) {
+            throw new InvalidArgumentException(
+                'Invalid HTTP version. Must be one of: '
+                . implode(', ', array_keys(self::$validProtocolVersions))
+            );
+        }
+        $clone = clone $this;
+        $clone->protocolVersion = $version;
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * Headers
+     ******************************************************************************/
+
+    /**
+     * Retrieves all message header values.
+     *
+     * The keys represent the header name as it will be sent over the wire, and
+     * each value is an array of strings associated with the header.
+     *
+     *     // Represent the headers as a string
+     *     foreach ($message->getHeaders() as $name => $values) {
+     *         echo $name . ": " . implode(", ", $values);
+     *     }
+     *
+     *     // Emit headers iteratively:
+     *     foreach ($message->getHeaders() as $name => $values) {
+     *         foreach ($values as $value) {
+     *             header(sprintf('%s: %s', $name, $value), false);
+     *         }
+     *     }
+     *
+     * While header names are not case-sensitive, getHeaders() will preserve the
+     * exact case in which headers were originally specified.
+     *
+     * @return array Returns an associative array of the message's headers. Each
+     *     key MUST be a header name, and each value MUST be an array of strings
+     *     for that header.
+     */
+    public function getHeaders()
+    {
+        return $this->headers->all();
+    }
+
+    /**
+     * Checks if a header exists by the given case-insensitive name.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return bool Returns true if any header names match the given header
+     *     name using a case-insensitive string comparison. Returns false if
+     *     no matching header name is found in the message.
+     */
+    public function hasHeader($name)
+    {
+        return $this->headers->has($name);
+    }
+
+    /**
+     * Retrieves a message header value by the given case-insensitive name.
+     *
+     * This method returns an array of all the header values of the given
+     * case-insensitive header name.
+     *
+     * If the header does not appear in the message, this method MUST return an
+     * empty array.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return string[] An array of string values as provided for the given
+     *    header. If the header does not appear in the message, this method MUST
+     *    return an empty array.
+     */
+    public function getHeader($name)
+    {
+        return $this->headers->get($name, []);
+    }
+
+    /**
+     * Retrieves a comma-separated string of the values for a single header.
+     *
+     * This method returns all of the header values of the given
+     * case-insensitive header name as a string concatenated together using
+     * a comma.
+     *
+     * NOTE: Not all header values may be appropriately represented using
+     * comma concatenation. For such headers, use getHeader() instead
+     * and supply your own delimiter when concatenating.
+     *
+     * If the header does not appear in the message, this method MUST return
+     * an empty string.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @return string A string of values as provided for the given header
+     *    concatenated together using a comma. If the header does not appear in
+     *    the message, this method MUST return an empty string.
+     */
+    public function getHeaderLine($name)
+    {
+        return implode(',', $this->headers->get($name, []));
+    }
+
+    /**
+     * Return an instance with the provided value replacing the specified header.
+     *
+     * While header names are case-insensitive, the casing of the header will
+     * be preserved by this function, and returned from getHeaders().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new and/or updated header and value.
+     *
+     * @param string $name Case-insensitive header field name.
+     * @param string|string[] $value Header value(s).
+     * @return static
+     * @throws \InvalidArgumentException for invalid header names or values.
+     */
+    public function withHeader($name, $value)
+    {
+        $clone = clone $this;
+        $clone->headers->set($name, $value);
+
+        return $clone;
+    }
+
+    /**
+     * Return an instance with the specified header appended with the given value.
+     *
+     * Existing values for the specified header will be maintained. The new
+     * value(s) will be appended to the existing list. If the header did not
+     * exist previously, it will be added.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new header and/or value.
+     *
+     * @param string $name Case-insensitive header field name to add.
+     * @param string|string[] $value Header value(s).
+     * @return static
+     * @throws \InvalidArgumentException for invalid header names or values.
+     */
+    public function withAddedHeader($name, $value)
+    {
+        $clone = clone $this;
+        $clone->headers->add($name, $value);
+
+        return $clone;
+    }
+
+    /**
+     * Return an instance without the specified header.
+     *
+     * Header resolution MUST be done without case-sensitivity.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that removes
+     * the named header.
+     *
+     * @param string $name Case-insensitive header field name to remove.
+     * @return static
+     */
+    public function withoutHeader($name)
+    {
+        $clone = clone $this;
+        $clone->headers->remove($name);
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * Body
+     ******************************************************************************/
+
+    /**
+     * Gets the body of the message.
+     *
+     * @return StreamInterface Returns the body as a stream.
+     */
+    public function getBody()
+    {
+        return $this->body;
+    }
+
+    /**
+     * Return an instance with the specified message body.
+     *
+     * The body MUST be a StreamInterface object.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return a new instance that has the
+     * new body stream.
+     *
+     * @param StreamInterface $body Body.
+     * @return static
+     * @throws \InvalidArgumentException When the body is not valid.
+     */
+    public function withBody(StreamInterface $body)
+    {
+        // TODO: Test for invalid body?
+        $clone = clone $this;
+        $clone->body = $body;
+
+        return $clone;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Request.php b/vendor/slim/slim/Slim/Http/Request.php
new file mode 100644
index 0000000..f67050b
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Request.php
@@ -0,0 +1,1216 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use Closure;
+use InvalidArgumentException;
+use Psr\Http\Message\UploadedFileInterface;
+use RuntimeException;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\UriInterface;
+use Psr\Http\Message\StreamInterface;
+use Slim\Collection;
+use Slim\Exception\InvalidMethodException;
+use Slim\Exception\MethodNotAllowedException;
+use Slim\Interfaces\Http\HeadersInterface;
+
+/**
+ * Request
+ *
+ * This class represents an HTTP request. It manages
+ * the request method, URI, headers, cookies, and body
+ * according to the PSR-7 standard.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
+ * @link https://github.com/php-fig/http-message/blob/master/src/RequestInterface.php
+ * @link https://github.com/php-fig/http-message/blob/master/src/ServerRequestInterface.php
+ */
+class Request extends Message implements ServerRequestInterface
+{
+    /**
+     * The request method
+     *
+     * @var string
+     */
+    protected $method;
+
+    /**
+     * The original request method (ignoring override)
+     *
+     * @var string
+     */
+    protected $originalMethod;
+
+    /**
+     * The request URI object
+     *
+     * @var \Psr\Http\Message\UriInterface
+     */
+    protected $uri;
+
+    /**
+     * The request URI target (path + query string)
+     *
+     * @var string
+     */
+    protected $requestTarget;
+
+    /**
+     * The request query string params
+     *
+     * @var array
+     */
+    protected $queryParams;
+
+    /**
+     * The request cookies
+     *
+     * @var array
+     */
+    protected $cookies;
+
+    /**
+     * The server environment variables at the time the request was created.
+     *
+     * @var array
+     */
+    protected $serverParams;
+
+    /**
+     * The request attributes (route segment names and values)
+     *
+     * @var \Slim\Collection
+     */
+    protected $attributes;
+
+    /**
+     * The request body parsed (if possible) into a PHP array or object
+     *
+     * @var null|array|object
+     */
+    protected $bodyParsed = false;
+
+    /**
+     * List of request body parsers (e.g., url-encoded, JSON, XML, multipart)
+     *
+     * @var callable[]
+     */
+    protected $bodyParsers = [];
+
+    /**
+     * List of uploaded files
+     *
+     * @var UploadedFileInterface[]
+     */
+    protected $uploadedFiles;
+
+    /**
+     * Valid request methods
+     *
+     * @var string[]
+     */
+    protected $validMethods = [
+        'CONNECT' => 1,
+        'DELETE' => 1,
+        'GET' => 1,
+        'HEAD' => 1,
+        'OPTIONS' => 1,
+        'PATCH' => 1,
+        'POST' => 1,
+        'PUT' => 1,
+        'TRACE' => 1,
+    ];
+
+    /**
+     * Create new HTTP request with data extracted from the application
+     * Environment object
+     *
+     * @param  Environment $environment The Slim application Environment
+     *
+     * @return static
+     */
+    public static function createFromEnvironment(Environment $environment)
+    {
+        $method = $environment['REQUEST_METHOD'];
+        $uri = Uri::createFromEnvironment($environment);
+        $headers = Headers::createFromEnvironment($environment);
+        $cookies = Cookies::parseHeader($headers->get('Cookie', []));
+        $serverParams = $environment->all();
+        $body = new RequestBody();
+        $uploadedFiles = UploadedFile::createFromEnvironment($environment);
+
+        $request = new static($method, $uri, $headers, $cookies, $serverParams, $body, $uploadedFiles);
+
+        if ($method === 'POST' &&
+            in_array($request->getMediaType(), ['application/x-www-form-urlencoded', 'multipart/form-data'])
+        ) {
+            // parsed body must be $_POST
+            $request = $request->withParsedBody($_POST);
+        }
+        return $request;
+    }
+
+    /**
+     * Create new HTTP request.
+     *
+     * Adds a host header when none was provided and a host is defined in uri.
+     *
+     * @param string           $method        The request method
+     * @param UriInterface     $uri           The request URI object
+     * @param HeadersInterface $headers       The request headers collection
+     * @param array            $cookies       The request cookies collection
+     * @param array            $serverParams  The server environment variables
+     * @param StreamInterface  $body          The request body object
+     * @param array            $uploadedFiles The request uploadedFiles collection
+     * @throws InvalidMethodException on invalid HTTP method
+     */
+    public function __construct(
+        $method,
+        UriInterface $uri,
+        HeadersInterface $headers,
+        array $cookies,
+        array $serverParams,
+        StreamInterface $body,
+        array $uploadedFiles = []
+    ) {
+        try {
+            $this->originalMethod = $this->filterMethod($method);
+        } catch (InvalidMethodException $e) {
+            $this->originalMethod = $method;
+        }
+
+        $this->uri = $uri;
+        $this->headers = $headers;
+        $this->cookies = $cookies;
+        $this->serverParams = $serverParams;
+        $this->attributes = new Collection();
+        $this->body = $body;
+        $this->uploadedFiles = $uploadedFiles;
+
+        if (isset($serverParams['SERVER_PROTOCOL'])) {
+            $this->protocolVersion = str_replace('HTTP/', '', $serverParams['SERVER_PROTOCOL']);
+        }
+
+        if (!$this->headers->has('Host') || $this->uri->getHost() !== '') {
+            $this->headers->set('Host', $this->uri->getHost());
+        }
+
+        $this->registerMediaTypeParser('application/json', function ($input) {
+            $result = json_decode($input, true);
+            if (!is_array($result)) {
+                return null;
+            }
+            return $result;
+        });
+
+        $this->registerMediaTypeParser('application/xml', function ($input) {
+            $backup = libxml_disable_entity_loader(true);
+            $backup_errors = libxml_use_internal_errors(true);
+            $result = simplexml_load_string($input);
+            libxml_disable_entity_loader($backup);
+            libxml_clear_errors();
+            libxml_use_internal_errors($backup_errors);
+            if ($result === false) {
+                return null;
+            }
+            return $result;
+        });
+
+        $this->registerMediaTypeParser('text/xml', function ($input) {
+            $backup = libxml_disable_entity_loader(true);
+            $backup_errors = libxml_use_internal_errors(true);
+            $result = simplexml_load_string($input);
+            libxml_disable_entity_loader($backup);
+            libxml_clear_errors();
+            libxml_use_internal_errors($backup_errors);
+            if ($result === false) {
+                return null;
+            }
+            return $result;
+        });
+
+        $this->registerMediaTypeParser('application/x-www-form-urlencoded', function ($input) {
+            parse_str($input, $data);
+            return $data;
+        });
+
+        // if the request had an invalid method, we can throw it now
+        if (isset($e) && $e instanceof InvalidMethodException) {
+            throw $e;
+        }
+    }
+
+    /**
+     * This method is applied to the cloned object
+     * after PHP performs an initial shallow-copy. This
+     * method completes a deep-copy by creating new objects
+     * for the cloned object's internal reference pointers.
+     */
+    public function __clone()
+    {
+        $this->headers = clone $this->headers;
+        $this->attributes = clone $this->attributes;
+        $this->body = clone $this->body;
+    }
+
+    /*******************************************************************************
+     * Method
+     ******************************************************************************/
+
+    /**
+     * Retrieves the HTTP method of the request.
+     *
+     * @return string Returns the request method.
+     */
+    public function getMethod()
+    {
+        if ($this->method === null) {
+            $this->method = $this->originalMethod;
+            $customMethod = $this->getHeaderLine('X-Http-Method-Override');
+
+            if ($customMethod) {
+                $this->method = $this->filterMethod($customMethod);
+            } elseif ($this->originalMethod === 'POST') {
+                $overrideMethod = $this->filterMethod($this->getParsedBodyParam('_METHOD'));
+                if ($overrideMethod !== null) {
+                    $this->method = $overrideMethod;
+                }
+
+                if ($this->getBody()->eof()) {
+                    $this->getBody()->rewind();
+                }
+            }
+        }
+
+        return $this->method;
+    }
+
+    /**
+     * Get the original HTTP method (ignore override).
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return string
+     */
+    public function getOriginalMethod()
+    {
+        return $this->originalMethod;
+    }
+
+    /**
+     * Return an instance with the provided HTTP method.
+     *
+     * While HTTP method names are typically all uppercase characters, HTTP
+     * method names are case-sensitive and thus implementations SHOULD NOT
+     * modify the given string.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * changed request method.
+     *
+     * @param string $method Case-sensitive method.
+     * @return static
+     * @throws \InvalidArgumentException for invalid HTTP methods.
+     */
+    public function withMethod($method)
+    {
+        $method = $this->filterMethod($method);
+        $clone = clone $this;
+        $clone->originalMethod = $method;
+        $clone->method = $method;
+
+        return $clone;
+    }
+
+    /**
+     * Validate the HTTP method
+     *
+     * @param  null|string $method
+     * @return null|string
+     * @throws \InvalidArgumentException on invalid HTTP method.
+     */
+    protected function filterMethod($method)
+    {
+        if ($method === null) {
+            return $method;
+        }
+
+        if (!is_string($method)) {
+            throw new InvalidArgumentException(sprintf(
+                'Unsupported HTTP method; must be a string, received %s',
+                (is_object($method) ? get_class($method) : gettype($method))
+            ));
+        }
+
+        $method = strtoupper($method);
+        if (!isset($this->validMethods[$method])) {
+            throw new InvalidMethodException($this, $method);
+        }
+
+        return $method;
+    }
+
+    /**
+     * Does this request use a given method?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param  string $method HTTP method
+     * @return bool
+     */
+    public function isMethod($method)
+    {
+        return $this->getMethod() === $method;
+    }
+
+    /**
+     * Is this a GET request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isGet()
+    {
+        return $this->isMethod('GET');
+    }
+
+    /**
+     * Is this a POST request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isPost()
+    {
+        return $this->isMethod('POST');
+    }
+
+    /**
+     * Is this a PUT request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isPut()
+    {
+        return $this->isMethod('PUT');
+    }
+
+    /**
+     * Is this a PATCH request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isPatch()
+    {
+        return $this->isMethod('PATCH');
+    }
+
+    /**
+     * Is this a DELETE request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isDelete()
+    {
+        return $this->isMethod('DELETE');
+    }
+
+    /**
+     * Is this a HEAD request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isHead()
+    {
+        return $this->isMethod('HEAD');
+    }
+
+    /**
+     * Is this a OPTIONS request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isOptions()
+    {
+        return $this->isMethod('OPTIONS');
+    }
+
+    /**
+     * Is this an XHR request?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isXhr()
+    {
+        return $this->getHeaderLine('X-Requested-With') === 'XMLHttpRequest';
+    }
+
+    /*******************************************************************************
+     * URI
+     ******************************************************************************/
+
+    /**
+     * Retrieves the message's request target.
+     *
+     * Retrieves the message's request-target either as it will appear (for
+     * clients), as it appeared at request (for servers), or as it was
+     * specified for the instance (see withRequestTarget()).
+     *
+     * In most cases, this will be the origin-form of the composed URI,
+     * unless a value was provided to the concrete implementation (see
+     * withRequestTarget() below).
+     *
+     * If no URI is available, and no request-target has been specifically
+     * provided, this method MUST return the string "/".
+     *
+     * @return string
+     */
+    public function getRequestTarget()
+    {
+        if ($this->requestTarget) {
+            return $this->requestTarget;
+        }
+
+        if ($this->uri === null) {
+            return '/';
+        }
+
+        $basePath = $this->uri->getBasePath();
+        $path = $this->uri->getPath();
+        $path = $basePath . '/' . ltrim($path, '/');
+
+        $query = $this->uri->getQuery();
+        if ($query) {
+            $path .= '?' . $query;
+        }
+        $this->requestTarget = $path;
+
+        return $this->requestTarget;
+    }
+
+    /**
+     * Return an instance with the specific request-target.
+     *
+     * If the request needs a non-origin-form request-target — e.g., for
+     * specifying an absolute-form, authority-form, or asterisk-form —
+     * this method may be used to create an instance with the specified
+     * request-target, verbatim.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * changed request target.
+     *
+     * @link http://tools.ietf.org/html/rfc7230#section-2.7 (for the various
+     *     request-target forms allowed in request messages)
+     * @param mixed $requestTarget
+     * @return static
+     * @throws InvalidArgumentException if the request target is invalid
+     */
+    public function withRequestTarget($requestTarget)
+    {
+        if (preg_match('#\s#', $requestTarget)) {
+            throw new InvalidArgumentException(
+                'Invalid request target provided; must be a string and cannot contain whitespace'
+            );
+        }
+        $clone = clone $this;
+        $clone->requestTarget = $requestTarget;
+
+        return $clone;
+    }
+
+    /**
+     * Retrieves the URI instance.
+     *
+     * This method MUST return a UriInterface instance.
+     *
+     * @link http://tools.ietf.org/html/rfc3986#section-4.3
+     * @return UriInterface Returns a UriInterface instance
+     *     representing the URI of the request.
+     */
+    public function getUri()
+    {
+        return $this->uri;
+    }
+
+    /**
+     * Returns an instance with the provided URI.
+     *
+     * This method MUST update the Host header of the returned request by
+     * default if the URI contains a host component. If the URI does not
+     * contain a host component, any pre-existing Host header MUST be carried
+     * over to the returned request.
+     *
+     * You can opt-in to preserving the original state of the Host header by
+     * setting `$preserveHost` to `true`. When `$preserveHost` is set to
+     * `true`, this method interacts with the Host header in the following ways:
+     *
+     * - If the the Host header is missing or empty, and the new URI contains
+     *   a host component, this method MUST update the Host header in the returned
+     *   request.
+     * - If the Host header is missing or empty, and the new URI does not contain a
+     *   host component, this method MUST NOT update the Host header in the returned
+     *   request.
+     * - If a Host header is present and non-empty, this method MUST NOT update
+     *   the Host header in the returned request.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * new UriInterface instance.
+     *
+     * @link http://tools.ietf.org/html/rfc3986#section-4.3
+     * @param UriInterface $uri New request URI to use.
+     * @param bool $preserveHost Preserve the original state of the Host header.
+     * @return static
+     */
+    public function withUri(UriInterface $uri, $preserveHost = false)
+    {
+        $clone = clone $this;
+        $clone->uri = $uri;
+
+        if (!$preserveHost) {
+            if ($uri->getHost() !== '') {
+                $clone->headers->set('Host', $uri->getHost());
+            }
+        } else {
+            if ($uri->getHost() !== '' && (!$this->hasHeader('Host') || $this->getHeaderLine('Host') === '')) {
+                $clone->headers->set('Host', $uri->getHost());
+            }
+        }
+
+        return $clone;
+    }
+
+    /**
+     * Get request content type.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return string|null The request content type, if known
+     */
+    public function getContentType()
+    {
+        $result = $this->getHeader('Content-Type');
+
+        return $result ? $result[0] : null;
+    }
+
+    /**
+     * Get request media type, if known.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return string|null The request media type, minus content-type params
+     */
+    public function getMediaType()
+    {
+        $contentType = $this->getContentType();
+        if ($contentType) {
+            $contentTypeParts = preg_split('/\s*[;,]\s*/', $contentType);
+
+            return strtolower($contentTypeParts[0]);
+        }
+
+        return null;
+    }
+
+    /**
+     * Get request media type params, if known.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return array
+     */
+    public function getMediaTypeParams()
+    {
+        $contentType = $this->getContentType();
+        $contentTypeParams = [];
+        if ($contentType) {
+            $contentTypeParts = preg_split('/\s*[;,]\s*/', $contentType);
+            $contentTypePartsLength = count($contentTypeParts);
+            for ($i = 1; $i < $contentTypePartsLength; $i++) {
+                $paramParts = explode('=', $contentTypeParts[$i]);
+                $contentTypeParams[strtolower($paramParts[0])] = $paramParts[1];
+            }
+        }
+
+        return $contentTypeParams;
+    }
+
+    /**
+     * Get request content character set, if known.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return string|null
+     */
+    public function getContentCharset()
+    {
+        $mediaTypeParams = $this->getMediaTypeParams();
+        if (isset($mediaTypeParams['charset'])) {
+            return $mediaTypeParams['charset'];
+        }
+
+        return null;
+    }
+
+    /**
+     * Get request content length, if known.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return int|null
+     */
+    public function getContentLength()
+    {
+        $result = $this->headers->get('Content-Length');
+
+        return $result ? (int)$result[0] : null;
+    }
+
+    /*******************************************************************************
+     * Cookies
+     ******************************************************************************/
+
+    /**
+     * Retrieve cookies.
+     *
+     * Retrieves cookies sent by the client to the server.
+     *
+     * The data MUST be compatible with the structure of the $_COOKIE
+     * superglobal.
+     *
+     * @return array
+     */
+    public function getCookieParams()
+    {
+        return $this->cookies;
+    }
+
+    /**
+     * Fetch cookie value from cookies sent by the client to the server.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param string $key     The attribute name.
+     * @param mixed  $default Default value to return if the attribute does not exist.
+     *
+     * @return mixed
+     */
+    public function getCookieParam($key, $default = null)
+    {
+        $cookies = $this->getCookieParams();
+        $result = $default;
+        if (isset($cookies[$key])) {
+            $result = $cookies[$key];
+        }
+
+        return $result;
+    }
+
+    /**
+     * Return an instance with the specified cookies.
+     *
+     * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
+     * be compatible with the structure of $_COOKIE. Typically, this data will
+     * be injected at instantiation.
+     *
+     * This method MUST NOT update the related Cookie header of the request
+     * instance, nor related values in the server params.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated cookie values.
+     *
+     * @param array $cookies Array of key/value pairs representing cookies.
+     * @return static
+     */
+    public function withCookieParams(array $cookies)
+    {
+        $clone = clone $this;
+        $clone->cookies = $cookies;
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * Query Params
+     ******************************************************************************/
+
+    /**
+     * Retrieve query string arguments.
+     *
+     * Retrieves the deserialized query string arguments, if any.
+     *
+     * Note: the query params might not be in sync with the URI or server
+     * params. If you need to ensure you are only getting the original
+     * values, you may need to parse the query string from `getUri()->getQuery()`
+     * or from the `QUERY_STRING` server param.
+     *
+     * @return array
+     */
+    public function getQueryParams()
+    {
+        if (is_array($this->queryParams)) {
+            return $this->queryParams;
+        }
+
+        if ($this->uri === null) {
+            return [];
+        }
+
+        parse_str($this->uri->getQuery(), $this->queryParams); // <-- URL decodes data
+
+        return $this->queryParams;
+    }
+
+    /**
+     * Return an instance with the specified query string arguments.
+     *
+     * These values SHOULD remain immutable over the course of the incoming
+     * request. They MAY be injected during instantiation, such as from PHP's
+     * $_GET superglobal, or MAY be derived from some other value such as the
+     * URI. In cases where the arguments are parsed from the URI, the data
+     * MUST be compatible with what PHP's parse_str() would return for
+     * purposes of how duplicate query parameters are handled, and how nested
+     * sets are handled.
+     *
+     * Setting query string arguments MUST NOT change the URI stored by the
+     * request, nor the values in the server params.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated query string arguments.
+     *
+     * @param array $query Array of query string arguments, typically from
+     *     $_GET.
+     * @return static
+     */
+    public function withQueryParams(array $query)
+    {
+        $clone = clone $this;
+        $clone->queryParams = $query;
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * File Params
+     ******************************************************************************/
+
+    /**
+     * Retrieve normalized file upload data.
+     *
+     * This method returns upload metadata in a normalized tree, with each leaf
+     * an instance of Psr\Http\Message\UploadedFileInterface.
+     *
+     * These values MAY be prepared from $_FILES or the message body during
+     * instantiation, or MAY be injected via withUploadedFiles().
+     *
+     * @return array An array tree of UploadedFileInterface instances; an empty
+     *     array MUST be returned if no data is present.
+     */
+    public function getUploadedFiles()
+    {
+        return $this->uploadedFiles;
+    }
+
+    /**
+     * Create a new instance with the specified uploaded files.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated body parameters.
+     *
+     * @param array $uploadedFiles An array tree of UploadedFileInterface instances.
+     * @return static
+     * @throws \InvalidArgumentException if an invalid structure is provided.
+     */
+    public function withUploadedFiles(array $uploadedFiles)
+    {
+        $clone = clone $this;
+        $clone->uploadedFiles = $uploadedFiles;
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * Server Params
+     ******************************************************************************/
+
+    /**
+     * Retrieve server parameters.
+     *
+     * Retrieves data related to the incoming request environment,
+     * typically derived from PHP's $_SERVER superglobal. The data IS NOT
+     * REQUIRED to originate from $_SERVER.
+     *
+     * @return array
+     */
+    public function getServerParams()
+    {
+        return $this->serverParams;
+    }
+
+    /**
+     * Retrieve a server parameter.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param  string $key
+     * @param  mixed  $default
+     * @return mixed
+     */
+    public function getServerParam($key, $default = null)
+    {
+        $serverParams = $this->getServerParams();
+
+        return isset($serverParams[$key]) ? $serverParams[$key] : $default;
+    }
+
+    /*******************************************************************************
+     * Attributes
+     ******************************************************************************/
+
+    /**
+     * Retrieve attributes derived from the request.
+     *
+     * The request "attributes" may be used to allow injection of any
+     * parameters derived from the request: e.g., the results of path
+     * match operations; the results of decrypting cookies; the results of
+     * deserializing non-form-encoded message bodies; etc. Attributes
+     * will be application and request specific, and CAN be mutable.
+     *
+     * @return array Attributes derived from the request.
+     */
+    public function getAttributes()
+    {
+        return $this->attributes->all();
+    }
+
+    /**
+     * Retrieve a single derived request attribute.
+     *
+     * Retrieves a single derived request attribute as described in
+     * getAttributes(). If the attribute has not been previously set, returns
+     * the default value as provided.
+     *
+     * This method obviates the need for a hasAttribute() method, as it allows
+     * specifying a default value to return if the attribute is not found.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @param mixed $default Default value to return if the attribute does not exist.
+     * @return mixed
+     */
+    public function getAttribute($name, $default = null)
+    {
+        return $this->attributes->get($name, $default);
+    }
+
+    /**
+     * Return an instance with the specified derived request attribute.
+     *
+     * This method allows setting a single derived request attribute as
+     * described in getAttributes().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated attribute.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @param mixed $value The value of the attribute.
+     * @return static
+     */
+    public function withAttribute($name, $value)
+    {
+        $clone = clone $this;
+        $clone->attributes->set($name, $value);
+
+        return $clone;
+    }
+
+    /**
+     * Create a new instance with the specified derived request attributes.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * This method allows setting all new derived request attributes as
+     * described in getAttributes().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return a new instance that has the
+     * updated attributes.
+     *
+     * @param  array $attributes New attributes
+     * @return static
+     */
+    public function withAttributes(array $attributes)
+    {
+        $clone = clone $this;
+        $clone->attributes = new Collection($attributes);
+
+        return $clone;
+    }
+
+    /**
+     * Return an instance that removes the specified derived request attribute.
+     *
+     * This method allows removing a single derived request attribute as
+     * described in getAttributes().
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that removes
+     * the attribute.
+     *
+     * @see getAttributes()
+     * @param string $name The attribute name.
+     * @return static
+     */
+    public function withoutAttribute($name)
+    {
+        $clone = clone $this;
+        $clone->attributes->remove($name);
+
+        return $clone;
+    }
+
+    /*******************************************************************************
+     * Body
+     ******************************************************************************/
+
+    /**
+     * Retrieve any parameters provided in the request body.
+     *
+     * If the request Content-Type is either application/x-www-form-urlencoded
+     * or multipart/form-data, and the request method is POST, this method MUST
+     * return the contents of $_POST.
+     *
+     * Otherwise, this method may return any results of deserializing
+     * the request body content; as parsing returns structured content, the
+     * potential types MUST be arrays or objects only. A null value indicates
+     * the absence of body content.
+     *
+     * @return null|array|object The deserialized body parameters, if any.
+     *     These will typically be an array or object.
+     * @throws RuntimeException if the request body media type parser returns an invalid value
+     */
+    public function getParsedBody()
+    {
+        if ($this->bodyParsed !== false) {
+            return $this->bodyParsed;
+        }
+
+        if (!$this->body) {
+            return null;
+        }
+
+        $mediaType = $this->getMediaType();
+
+        // look for a media type with a structured syntax suffix (RFC 6839)
+        $parts = explode('+', $mediaType);
+        if (count($parts) >= 2) {
+            $mediaType = 'application/' . $parts[count($parts)-1];
+        }
+
+        if (isset($this->bodyParsers[$mediaType]) === true) {
+            $body = (string)$this->getBody();
+            $parsed = $this->bodyParsers[$mediaType]($body);
+
+            if (!is_null($parsed) && !is_object($parsed) && !is_array($parsed)) {
+                throw new RuntimeException(
+                    'Request body media type parser return value must be an array, an object, or null'
+                );
+            }
+            $this->bodyParsed = $parsed;
+            return $this->bodyParsed;
+        }
+
+        return null;
+    }
+
+    /**
+     * Return an instance with the specified body parameters.
+     *
+     * These MAY be injected during instantiation.
+     *
+     * If the request Content-Type is either application/x-www-form-urlencoded
+     * or multipart/form-data, and the request method is POST, use this method
+     * ONLY to inject the contents of $_POST.
+     *
+     * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of
+     * deserializing the request body content. Deserialization/parsing returns
+     * structured data, and, as such, this method ONLY accepts arrays or objects,
+     * or a null value if nothing was available to parse.
+     *
+     * As an example, if content negotiation determines that the request data
+     * is a JSON payload, this method could be used to create a request
+     * instance with the deserialized parameters.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated body parameters.
+     *
+     * @param null|array|object $data The deserialized body data. This will
+     *     typically be in an array or object.
+     * @return static
+     * @throws \InvalidArgumentException if an unsupported argument type is
+     *     provided.
+     */
+    public function withParsedBody($data)
+    {
+        if (!is_null($data) && !is_object($data) && !is_array($data)) {
+            throw new InvalidArgumentException('Parsed body value must be an array, an object, or null');
+        }
+
+        $clone = clone $this;
+        $clone->bodyParsed = $data;
+
+        return $clone;
+    }
+
+    /**
+     * Force Body to be parsed again.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return $this
+     */
+    public function reparseBody()
+    {
+        $this->bodyParsed = false;
+
+        return $this;
+    }
+
+    /**
+     * Register media type parser.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param string   $mediaType A HTTP media type (excluding content-type
+     *     params).
+     * @param callable $callable  A callable that returns parsed contents for
+     *     media type.
+     */
+    public function registerMediaTypeParser($mediaType, callable $callable)
+    {
+        if ($callable instanceof Closure) {
+            $callable = $callable->bindTo($this);
+        }
+        $this->bodyParsers[(string)$mediaType] = $callable;
+    }
+
+    /*******************************************************************************
+     * Parameters (e.g., POST and GET data)
+     ******************************************************************************/
+
+    /**
+     * Fetch request parameter value from body or query string (in that order).
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param  string $key The parameter key.
+     * @param  string $default The default value.
+     *
+     * @return mixed The parameter value.
+     */
+    public function getParam($key, $default = null)
+    {
+        $postParams = $this->getParsedBody();
+        $getParams = $this->getQueryParams();
+        $result = $default;
+        if (is_array($postParams) && isset($postParams[$key])) {
+            $result = $postParams[$key];
+        } elseif (is_object($postParams) && property_exists($postParams, $key)) {
+            $result = $postParams->$key;
+        } elseif (isset($getParams[$key])) {
+            $result = $getParams[$key];
+        }
+
+        return $result;
+    }
+
+    /**
+     * Fetch parameter value from request body.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param string $key
+     * @param mixed $default
+     *
+     * @return mixed
+     */
+    public function getParsedBodyParam($key, $default = null)
+    {
+        $postParams = $this->getParsedBody();
+        $result = $default;
+        if (is_array($postParams) && isset($postParams[$key])) {
+            $result = $postParams[$key];
+        } elseif (is_object($postParams) && property_exists($postParams, $key)) {
+            $result = $postParams->$key;
+        }
+
+        return $result;
+    }
+
+    /**
+     * Fetch parameter value from query string.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param string $key
+     * @param mixed $default
+     *
+     * @return mixed
+     */
+    public function getQueryParam($key, $default = null)
+    {
+        $getParams = $this->getQueryParams();
+        $result = $default;
+        if (isset($getParams[$key])) {
+            $result = $getParams[$key];
+        }
+
+        return $result;
+    }
+
+    /**
+     * Fetch associative array of body and query string parameters.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return array
+     */
+    public function getParams()
+    {
+        $params = $this->getQueryParams();
+        $postParams = $this->getParsedBody();
+        if ($postParams) {
+            $params = array_merge($params, (array)$postParams);
+        }
+
+        return $params;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/RequestBody.php b/vendor/slim/slim/Slim/Http/RequestBody.php
new file mode 100644
index 0000000..50887fd
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/RequestBody.php
@@ -0,0 +1,27 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+/**
+ * Provides a PSR-7 implementation of a reusable raw request body
+ */
+class RequestBody extends Body
+{
+    /**
+     * Create a new RequestBody.
+     */
+    public function __construct()
+    {
+        $stream = fopen('php://temp', 'w+');
+        stream_copy_to_stream(fopen('php://input', 'r'), $stream);
+        rewind($stream);
+
+        parent::__construct($stream);
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Response.php b/vendor/slim/slim/Slim/Http/Response.php
new file mode 100644
index 0000000..dd96505
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Response.php
@@ -0,0 +1,480 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use InvalidArgumentException;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamInterface;
+use Psr\Http\Message\UriInterface;
+use Slim\Interfaces\Http\HeadersInterface;
+
+/**
+ * Response
+ *
+ * This class represents an HTTP response. It manages
+ * the response status, headers, and body
+ * according to the PSR-7 standard.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/MessageInterface.php
+ * @link https://github.com/php-fig/http-message/blob/master/src/ResponseInterface.php
+ */
+class Response extends Message implements ResponseInterface
+{
+    /**
+     * Status code
+     *
+     * @var int
+     */
+    protected $status = 200;
+
+    /**
+     * Reason phrase
+     *
+     * @var string
+     */
+    protected $reasonPhrase = '';
+
+    /**
+     * Status codes and reason phrases
+     *
+     * @var array
+     */
+    protected static $messages = [
+        //Informational 1xx
+        100 => 'Continue',
+        101 => 'Switching Protocols',
+        102 => 'Processing',
+        //Successful 2xx
+        200 => 'OK',
+        201 => 'Created',
+        202 => 'Accepted',
+        203 => 'Non-Authoritative Information',
+        204 => 'No Content',
+        205 => 'Reset Content',
+        206 => 'Partial Content',
+        207 => 'Multi-Status',
+        208 => 'Already Reported',
+        226 => 'IM Used',
+        //Redirection 3xx
+        300 => 'Multiple Choices',
+        301 => 'Moved Permanently',
+        302 => 'Found',
+        303 => 'See Other',
+        304 => 'Not Modified',
+        305 => 'Use Proxy',
+        306 => '(Unused)',
+        307 => 'Temporary Redirect',
+        308 => 'Permanent Redirect',
+        //Client Error 4xx
+        400 => 'Bad Request',
+        401 => 'Unauthorized',
+        402 => 'Payment Required',
+        403 => 'Forbidden',
+        404 => 'Not Found',
+        405 => 'Method Not Allowed',
+        406 => 'Not Acceptable',
+        407 => 'Proxy Authentication Required',
+        408 => 'Request Timeout',
+        409 => 'Conflict',
+        410 => 'Gone',
+        411 => 'Length Required',
+        412 => 'Precondition Failed',
+        413 => 'Request Entity Too Large',
+        414 => 'Request-URI Too Long',
+        415 => 'Unsupported Media Type',
+        416 => 'Requested Range Not Satisfiable',
+        417 => 'Expectation Failed',
+        418 => 'I\'m a teapot',
+        421 => 'Misdirected Request',
+        422 => 'Unprocessable Entity',
+        423 => 'Locked',
+        424 => 'Failed Dependency',
+        426 => 'Upgrade Required',
+        428 => 'Precondition Required',
+        429 => 'Too Many Requests',
+        431 => 'Request Header Fields Too Large',
+        444 => 'Connection Closed Without Response',
+        451 => 'Unavailable For Legal Reasons',
+        499 => 'Client Closed Request',
+        //Server Error 5xx
+        500 => 'Internal Server Error',
+        501 => 'Not Implemented',
+        502 => 'Bad Gateway',
+        503 => 'Service Unavailable',
+        504 => 'Gateway Timeout',
+        505 => 'HTTP Version Not Supported',
+        506 => 'Variant Also Negotiates',
+        507 => 'Insufficient Storage',
+        508 => 'Loop Detected',
+        510 => 'Not Extended',
+        511 => 'Network Authentication Required',
+        599 => 'Network Connect Timeout Error',
+    ];
+
+    /**
+     * EOL characters used for HTTP response.
+     *
+     * @var string
+     */
+     const EOL = "\r\n";
+
+    /**
+     * Create new HTTP response.
+     *
+     * @param int                   $status  The response status code.
+     * @param HeadersInterface|null $headers The response headers.
+     * @param StreamInterface|null  $body    The response body.
+     */
+    public function __construct($status = 200, HeadersInterface $headers = null, StreamInterface $body = null)
+    {
+        $this->status = $this->filterStatus($status);
+        $this->headers = $headers ? $headers : new Headers();
+        $this->body = $body ? $body : new Body(fopen('php://temp', 'r+'));
+    }
+
+    /**
+     * This method is applied to the cloned object
+     * after PHP performs an initial shallow-copy. This
+     * method completes a deep-copy by creating new objects
+     * for the cloned object's internal reference pointers.
+     */
+    public function __clone()
+    {
+        $this->headers = clone $this->headers;
+    }
+
+    /*******************************************************************************
+     * Status
+     ******************************************************************************/
+
+    /**
+     * Gets the response status code.
+     *
+     * The status code is a 3-digit integer result code of the server's attempt
+     * to understand and satisfy the request.
+     *
+     * @return int Status code.
+     */
+    public function getStatusCode()
+    {
+        return $this->status;
+    }
+
+    /**
+     * Return an instance with the specified status code and, optionally, reason phrase.
+     *
+     * If no reason phrase is specified, implementations MAY choose to default
+     * to the RFC 7231 or IANA recommended reason phrase for the response's
+     * status code.
+     *
+     * This method MUST be implemented in such a way as to retain the
+     * immutability of the message, and MUST return an instance that has the
+     * updated status and reason phrase.
+     *
+     * @link http://tools.ietf.org/html/rfc7231#section-6
+     * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
+     * @param int $code The 3-digit integer result code to set.
+     * @param string $reasonPhrase The reason phrase to use with the
+     *     provided status code; if none is provided, implementations MAY
+     *     use the defaults as suggested in the HTTP specification.
+     * @return static
+     * @throws \InvalidArgumentException For invalid status code arguments.
+     */
+    public function withStatus($code, $reasonPhrase = '')
+    {
+        $code = $this->filterStatus($code);
+
+        if (!is_string($reasonPhrase) && !method_exists($reasonPhrase, '__toString')) {
+            throw new InvalidArgumentException('ReasonPhrase must be a string');
+        }
+
+        $clone = clone $this;
+        $clone->status = $code;
+        if ($reasonPhrase === '' && isset(static::$messages[$code])) {
+            $reasonPhrase = static::$messages[$code];
+        }
+
+        if ($reasonPhrase === '') {
+            throw new InvalidArgumentException('ReasonPhrase must be supplied for this code');
+        }
+
+        $clone->reasonPhrase = $reasonPhrase;
+
+        return $clone;
+    }
+
+    /**
+     * Filter HTTP status code.
+     *
+     * @param  int $status HTTP status code.
+     * @return int
+     * @throws \InvalidArgumentException If an invalid HTTP status code is provided.
+     */
+    protected function filterStatus($status)
+    {
+        if (!is_integer($status) || $status<100 || $status>599) {
+            throw new InvalidArgumentException('Invalid HTTP status code');
+        }
+
+        return $status;
+    }
+
+    /**
+     * Gets the response reason phrase associated with the status code.
+     *
+     * Because a reason phrase is not a required element in a response
+     * status line, the reason phrase value MAY be null. Implementations MAY
+     * choose to return the default RFC 7231 recommended reason phrase (or those
+     * listed in the IANA HTTP Status Code Registry) for the response's
+     * status code.
+     *
+     * @link http://tools.ietf.org/html/rfc7231#section-6
+     * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
+     * @return string Reason phrase; must return an empty string if none present.
+     */
+    public function getReasonPhrase()
+    {
+        if ($this->reasonPhrase) {
+            return $this->reasonPhrase;
+        }
+        if (isset(static::$messages[$this->status])) {
+            return static::$messages[$this->status];
+        }
+        return '';
+    }
+
+    /*******************************************************************************
+     * Body
+     ******************************************************************************/
+
+    /**
+     * Write data to the response body.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * Proxies to the underlying stream and writes the provided data to it.
+     *
+     * @param string $data
+     * @return $this
+     */
+    public function write($data)
+    {
+        $this->getBody()->write($data);
+
+        return $this;
+    }
+
+    /*******************************************************************************
+     * Response Helpers
+     ******************************************************************************/
+
+    /**
+     * Redirect.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * This method prepares the response object to return an HTTP Redirect
+     * response to the client.
+     *
+     * @param  string|UriInterface $url    The redirect destination.
+     * @param  int|null            $status The redirect HTTP status code.
+     * @return static
+     */
+    public function withRedirect($url, $status = null)
+    {
+        $responseWithRedirect = $this->withHeader('Location', (string)$url);
+
+        if (is_null($status) && $this->getStatusCode() === 200) {
+            $status = 302;
+        }
+
+        if (!is_null($status)) {
+            return $responseWithRedirect->withStatus($status);
+        }
+
+        return $responseWithRedirect;
+    }
+
+    /**
+     * Json.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * This method prepares the response object to return an HTTP Json
+     * response to the client.
+     *
+     * @param  mixed  $data   The data
+     * @param  int    $status The HTTP status code.
+     * @param  int    $encodingOptions Json encoding options
+     * @throws \RuntimeException
+     * @return static
+     */
+    public function withJson($data, $status = null, $encodingOptions = 0)
+    {
+        $response = $this->withBody(new Body(fopen('php://temp', 'r+')));
+        $response->body->write($json = json_encode($data, $encodingOptions));
+
+        // Ensure that the json encoding passed successfully
+        if ($json === false) {
+            throw new \RuntimeException(json_last_error_msg(), json_last_error());
+        }
+
+        $responseWithJson = $response->withHeader('Content-Type', 'application/json;charset=utf-8');
+        if (isset($status)) {
+            return $responseWithJson->withStatus($status);
+        }
+        return $responseWithJson;
+    }
+
+    /**
+     * Is this response empty?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isEmpty()
+    {
+        return in_array($this->getStatusCode(), [204, 205, 304]);
+    }
+
+    /**
+     * Is this response informational?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isInformational()
+    {
+        return $this->getStatusCode() >= 100 && $this->getStatusCode() < 200;
+    }
+
+    /**
+     * Is this response OK?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isOk()
+    {
+        return $this->getStatusCode() === 200;
+    }
+
+    /**
+     * Is this response successful?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isSuccessful()
+    {
+        return $this->getStatusCode() >= 200 && $this->getStatusCode() < 300;
+    }
+
+    /**
+     * Is this response a redirect?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isRedirect()
+    {
+        return in_array($this->getStatusCode(), [301, 302, 303, 307]);
+    }
+
+    /**
+     * Is this response a redirection?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isRedirection()
+    {
+        return $this->getStatusCode() >= 300 && $this->getStatusCode() < 400;
+    }
+
+    /**
+     * Is this response forbidden?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     * @api
+     */
+    public function isForbidden()
+    {
+        return $this->getStatusCode() === 403;
+    }
+
+    /**
+     * Is this response not Found?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isNotFound()
+    {
+        return $this->getStatusCode() === 404;
+    }
+
+    /**
+     * Is this response a client error?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isClientError()
+    {
+        return $this->getStatusCode() >= 400 && $this->getStatusCode() < 500;
+    }
+
+    /**
+     * Is this response a server error?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    public function isServerError()
+    {
+        return $this->getStatusCode() >= 500 && $this->getStatusCode() < 600;
+    }
+
+    /**
+     * Convert response to string.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return string
+     */
+    public function __toString()
+    {
+        $output = sprintf(
+            'HTTP/%s %s %s',
+            $this->getProtocolVersion(),
+            $this->getStatusCode(),
+            $this->getReasonPhrase()
+        );
+        $output .= Response::EOL;
+        foreach ($this->getHeaders() as $name => $values) {
+            $output .= sprintf('%s: %s', $name, $this->getHeaderLine($name)) . Response::EOL;
+        }
+        $output .= Response::EOL;
+        $output .= (string)$this->getBody();
+
+        return $output;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Stream.php b/vendor/slim/slim/Slim/Http/Stream.php
new file mode 100644
index 0000000..27c7a76
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Stream.php
@@ -0,0 +1,450 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use InvalidArgumentException;
+use Psr\Http\Message\StreamInterface;
+use RuntimeException;
+
+/**
+ * Represents a data stream as defined in PSR-7.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
+ */
+class Stream implements StreamInterface
+{
+    /**
+     * Bit mask to determine if the stream is a pipe
+     *
+     * This is octal as per header stat.h
+     */
+    const FSTAT_MODE_S_IFIFO = 0010000;
+
+    /**
+     * Resource modes
+     *
+     * @var  array
+     * @link http://php.net/manual/function.fopen.php
+     */
+    protected static $modes = [
+        'readable' => ['r', 'r+', 'w+', 'a+', 'x+', 'c+'],
+        'writable' => ['r+', 'w', 'w+', 'a', 'a+', 'x', 'x+', 'c', 'c+'],
+    ];
+
+    /**
+     * The underlying stream resource
+     *
+     * @var resource
+     */
+    protected $stream;
+
+    /**
+     * Stream metadata
+     *
+     * @var array
+     */
+    protected $meta;
+
+    /**
+     * Is this stream readable?
+     *
+     * @var bool
+     */
+    protected $readable;
+
+    /**
+     * Is this stream writable?
+     *
+     * @var bool
+     */
+    protected $writable;
+
+    /**
+     * Is this stream seekable?
+     *
+     * @var bool
+     */
+    protected $seekable;
+
+    /**
+     * The size of the stream if known
+     *
+     * @var null|int
+     */
+    protected $size;
+
+    /**
+     * Is this stream a pipe?
+     *
+     * @var bool
+     */
+    protected $isPipe;
+
+    /**
+     * Create a new Stream.
+     *
+     * @param  resource $stream A PHP resource handle.
+     *
+     * @throws InvalidArgumentException If argument is not a resource.
+     */
+    public function __construct($stream)
+    {
+        $this->attach($stream);
+    }
+
+    /**
+     * Get stream metadata as an associative array or retrieve a specific key.
+     *
+     * The keys returned are identical to the keys returned from PHP's
+     * stream_get_meta_data() function.
+     *
+     * @link http://php.net/manual/en/function.stream-get-meta-data.php
+     *
+     * @param string $key Specific metadata to retrieve.
+     *
+     * @return array|mixed|null Returns an associative array if no key is
+     *     provided. Returns a specific key value if a key is provided and the
+     *     value is found, or null if the key is not found.
+     */
+    public function getMetadata($key = null)
+    {
+        $this->meta = stream_get_meta_data($this->stream);
+        if (is_null($key) === true) {
+            return $this->meta;
+        }
+
+        return isset($this->meta[$key]) ? $this->meta[$key] : null;
+    }
+
+    /**
+     * Is a resource attached to this stream?
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @return bool
+     */
+    protected function isAttached()
+    {
+        return is_resource($this->stream);
+    }
+
+    /**
+     * Attach new resource to this object.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param resource $newStream A PHP resource handle.
+     *
+     * @throws InvalidArgumentException If argument is not a valid PHP resource.
+     */
+    protected function attach($newStream)
+    {
+        if (is_resource($newStream) === false) {
+            throw new InvalidArgumentException(__METHOD__ . ' argument must be a valid PHP resource');
+        }
+
+        if ($this->isAttached() === true) {
+            $this->detach();
+        }
+
+        $this->stream = $newStream;
+    }
+
+    /**
+     * Separates any underlying resources from the stream.
+     *
+     * After the stream has been detached, the stream is in an unusable state.
+     *
+     * @return resource|null Underlying PHP stream, if any
+     */
+    public function detach()
+    {
+        $oldResource = $this->stream;
+        $this->stream = null;
+        $this->meta = null;
+        $this->readable = null;
+        $this->writable = null;
+        $this->seekable = null;
+        $this->size = null;
+        $this->isPipe = null;
+
+        return $oldResource;
+    }
+
+    /**
+     * Reads all data from the stream into a string, from the beginning to end.
+     *
+     * This method MUST attempt to seek to the beginning of the stream before
+     * reading data and read the stream until the end is reached.
+     *
+     * Warning: This could attempt to load a large amount of data into memory.
+     *
+     * This method MUST NOT raise an exception in order to conform with PHP's
+     * string casting operations.
+     *
+     * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
+     * @return string
+     */
+    public function __toString()
+    {
+        if (!$this->isAttached()) {
+            return '';
+        }
+
+        try {
+            $this->rewind();
+            return $this->getContents();
+        } catch (RuntimeException $e) {
+            return '';
+        }
+    }
+
+    /**
+     * Closes the stream and any underlying resources.
+     */
+    public function close()
+    {
+        if ($this->isAttached() === true) {
+            if ($this->isPipe()) {
+                pclose($this->stream);
+            } else {
+                fclose($this->stream);
+            }
+        }
+
+        $this->detach();
+    }
+
+    /**
+     * Get the size of the stream if known.
+     *
+     * @return int|null Returns the size in bytes if known, or null if unknown.
+     */
+    public function getSize()
+    {
+        if (!$this->size && $this->isAttached() === true) {
+            $stats = fstat($this->stream);
+            $this->size = isset($stats['size']) && !$this->isPipe() ? $stats['size'] : null;
+        }
+
+        return $this->size;
+    }
+
+    /**
+     * Returns the current position of the file read/write pointer
+     *
+     * @return int Position of the file pointer
+     *
+     * @throws RuntimeException on error.
+     */
+    public function tell()
+    {
+        if (!$this->isAttached() || ($position = ftell($this->stream)) === false || $this->isPipe()) {
+            throw new RuntimeException('Could not get the position of the pointer in stream');
+        }
+
+        return $position;
+    }
+
+    /**
+     * Returns true if the stream is at the end of the stream.
+     *
+     * @return bool
+     */
+    public function eof()
+    {
+        return $this->isAttached() ? feof($this->stream) : true;
+    }
+
+    /**
+     * Returns whether or not the stream is readable.
+     *
+     * @return bool
+     */
+    public function isReadable()
+    {
+        if ($this->readable === null) {
+            if ($this->isPipe()) {
+                $this->readable = true;
+            } else {
+                $this->readable = false;
+                if ($this->isAttached()) {
+                    $meta = $this->getMetadata();
+                    foreach (self::$modes['readable'] as $mode) {
+                        if (strpos($meta['mode'], $mode) === 0) {
+                            $this->readable = true;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        return $this->readable;
+    }
+
+    /**
+     * Returns whether or not the stream is writable.
+     *
+     * @return bool
+     */
+    public function isWritable()
+    {
+        if ($this->writable === null) {
+            $this->writable = false;
+            if ($this->isAttached()) {
+                $meta = $this->getMetadata();
+                foreach (self::$modes['writable'] as $mode) {
+                    if (strpos($meta['mode'], $mode) === 0) {
+                        $this->writable = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        return $this->writable;
+    }
+
+    /**
+     * Returns whether or not the stream is seekable.
+     *
+     * @return bool
+     */
+    public function isSeekable()
+    {
+        if ($this->seekable === null) {
+            $this->seekable = false;
+            if ($this->isAttached()) {
+                $meta = $this->getMetadata();
+                $this->seekable = !$this->isPipe() && $meta['seekable'];
+            }
+        }
+
+        return $this->seekable;
+    }
+
+    /**
+     * Seek to a position in the stream.
+     *
+     * @link http://www.php.net/manual/en/function.fseek.php
+     *
+     * @param int $offset Stream offset
+     * @param int $whence Specifies how the cursor position will be calculated
+     *     based on the seek offset. Valid values are identical to the built-in
+     *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
+     *     offset bytes SEEK_CUR: Set position to current location plus offset
+     *     SEEK_END: Set position to end-of-stream plus offset.
+     *
+     * @throws RuntimeException on failure.
+     */
+    public function seek($offset, $whence = SEEK_SET)
+    {
+        // Note that fseek returns 0 on success!
+        if (!$this->isSeekable() || fseek($this->stream, $offset, $whence) === -1) {
+            throw new RuntimeException('Could not seek in stream');
+        }
+    }
+
+    /**
+     * Seek to the beginning of the stream.
+     *
+     * If the stream is not seekable, this method will raise an exception;
+     * otherwise, it will perform a seek(0).
+     *
+     * @see seek()
+     *
+     * @link http://www.php.net/manual/en/function.fseek.php
+     *
+     * @throws RuntimeException on failure.
+     */
+    public function rewind()
+    {
+        if (!$this->isSeekable() || rewind($this->stream) === false) {
+            throw new RuntimeException('Could not rewind stream');
+        }
+    }
+
+    /**
+     * Read data from the stream.
+     *
+     * @param int $length Read up to $length bytes from the object and return
+     *     them. Fewer than $length bytes may be returned if underlying stream
+     *     call returns fewer bytes.
+     *
+     * @return string Returns the data read from the stream, or an empty string
+     *     if no bytes are available.
+     *
+     * @throws RuntimeException if an error occurs.
+     */
+    public function read($length)
+    {
+        if (!$this->isReadable() || ($data = fread($this->stream, $length)) === false) {
+            throw new RuntimeException('Could not read from stream');
+        }
+
+        return $data;
+    }
+
+    /**
+     * Write data to the stream.
+     *
+     * @param string $string The string that is to be written.
+     *
+     * @return int Returns the number of bytes written to the stream.
+     *
+     * @throws RuntimeException on failure.
+     */
+    public function write($string)
+    {
+        if (!$this->isWritable() || ($written = fwrite($this->stream, $string)) === false) {
+            throw new RuntimeException('Could not write to stream');
+        }
+
+        // reset size so that it will be recalculated on next call to getSize()
+        $this->size = null;
+
+        return $written;
+    }
+
+    /**
+     * Returns the remaining contents in a string
+     *
+     * @return string
+     *
+     * @throws RuntimeException if unable to read or an error occurs while
+     *     reading.
+     */
+    public function getContents()
+    {
+        if (!$this->isReadable() || ($contents = stream_get_contents($this->stream)) === false) {
+            throw new RuntimeException('Could not get contents of stream');
+        }
+
+        return $contents;
+    }
+
+    /**
+     * Returns whether or not the stream is a pipe.
+     *
+     * @return bool
+     */
+    public function isPipe()
+    {
+        if ($this->isPipe === null) {
+            $this->isPipe = false;
+            if ($this->isAttached()) {
+                $mode = fstat($this->stream)['mode'];
+                $this->isPipe = ($mode & self::FSTAT_MODE_S_IFIFO) !== 0;
+            }
+        }
+
+        return $this->isPipe;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/UploadedFile.php b/vendor/slim/slim/Slim/Http/UploadedFile.php
new file mode 100644
index 0000000..ae5dfb6
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/UploadedFile.php
@@ -0,0 +1,327 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use RuntimeException;
+use InvalidArgumentException;
+use Psr\Http\Message\StreamInterface;
+use Psr\Http\Message\UploadedFileInterface;
+
+/**
+ * Represents Uploaded Files.
+ *
+ * It manages and normalizes uploaded files according to the PSR-7 standard.
+ *
+ * @link https://github.com/php-fig/http-message/blob/master/src/UploadedFileInterface.php
+ * @link https://github.com/php-fig/http-message/blob/master/src/StreamInterface.php
+ */
+class UploadedFile implements UploadedFileInterface
+{
+    /**
+     * The client-provided full path to the file
+     *
+     * @note this is public to maintain BC with 3.1.0 and earlier.
+     *
+     * @var string
+     */
+    public $file;
+    /**
+     * The client-provided file name.
+     *
+     * @var string
+     */
+    protected $name;
+    /**
+     * The client-provided media type of the file.
+     *
+     * @var string
+     */
+    protected $type;
+    /**
+     * The size of the file in bytes.
+     *
+     * @var int
+     */
+    protected $size;
+    /**
+     * A valid PHP UPLOAD_ERR_xxx code for the file upload.
+     *
+     * @var int
+     */
+    protected $error = UPLOAD_ERR_OK;
+    /**
+     * Indicates if the upload is from a SAPI environment.
+     *
+     * @var bool
+     */
+    protected $sapi = false;
+    /**
+     * An optional StreamInterface wrapping the file resource.
+     *
+     * @var StreamInterface
+     */
+    protected $stream;
+    /**
+     * Indicates if the uploaded file has already been moved.
+     *
+     * @var bool
+     */
+    protected $moved = false;
+
+    /**
+     * Create a normalized tree of UploadedFile instances from the Environment.
+     *
+     * @param Environment $env The environment
+     *
+     * @return array|null A normalized tree of UploadedFile instances or null if none are provided.
+     */
+    public static function createFromEnvironment(Environment $env)
+    {
+        if (is_array($env['slim.files']) && $env->has('slim.files')) {
+            return $env['slim.files'];
+        } elseif (isset($_FILES)) {
+            return static::parseUploadedFiles($_FILES);
+        }
+
+        return [];
+    }
+
+    /**
+     * Parse a non-normalized, i.e. $_FILES superglobal, tree of uploaded file data.
+     *
+     * @param array $uploadedFiles The non-normalized tree of uploaded file data.
+     *
+     * @return array A normalized tree of UploadedFile instances.
+     */
+    private static function parseUploadedFiles(array $uploadedFiles)
+    {
+        $parsed = [];
+        foreach ($uploadedFiles as $field => $uploadedFile) {
+            if (!isset($uploadedFile['error'])) {
+                if (is_array($uploadedFile)) {
+                    $parsed[$field] = static::parseUploadedFiles($uploadedFile);
+                }
+                continue;
+            }
+
+            $parsed[$field] = [];
+            if (!is_array($uploadedFile['error'])) {
+                $parsed[$field] = new static(
+                    $uploadedFile['tmp_name'],
+                    isset($uploadedFile['name']) ? $uploadedFile['name'] : null,
+                    isset($uploadedFile['type']) ? $uploadedFile['type'] : null,
+                    isset($uploadedFile['size']) ? $uploadedFile['size'] : null,
+                    $uploadedFile['error'],
+                    true
+                );
+            } else {
+                $subArray = [];
+                foreach ($uploadedFile['error'] as $fileIdx => $error) {
+                    // normalise subarray and re-parse to move the input's keyname up a level
+                    $subArray[$fileIdx]['name'] = $uploadedFile['name'][$fileIdx];
+                    $subArray[$fileIdx]['type'] = $uploadedFile['type'][$fileIdx];
+                    $subArray[$fileIdx]['tmp_name'] = $uploadedFile['tmp_name'][$fileIdx];
+                    $subArray[$fileIdx]['error'] = $uploadedFile['error'][$fileIdx];
+                    $subArray[$fileIdx]['size'] = $uploadedFile['size'][$fileIdx];
+
+                    $parsed[$field] = static::parseUploadedFiles($subArray);
+                }
+            }
+        }
+
+        return $parsed;
+    }
+
+    /**
+     * Construct a new UploadedFile instance.
+     *
+     * @param string      $file The full path to the uploaded file provided by the client.
+     * @param string|null $name The file name.
+     * @param string|null $type The file media type.
+     * @param int|null    $size The file size in bytes.
+     * @param int         $error The UPLOAD_ERR_XXX code representing the status of the upload.
+     * @param bool        $sapi Indicates if the upload is in a SAPI environment.
+     */
+    public function __construct($file, $name = null, $type = null, $size = null, $error = UPLOAD_ERR_OK, $sapi = false)
+    {
+        $this->file = $file;
+        $this->name = $name;
+        $this->type = $type;
+        $this->size = $size;
+        $this->error = $error;
+        $this->sapi = $sapi;
+    }
+
+    /**
+     * Retrieve a stream representing the uploaded file.
+     *
+     * This method MUST return a StreamInterface instance, representing the
+     * uploaded file. The purpose of this method is to allow utilizing native PHP
+     * stream functionality to manipulate the file upload, such as
+     * stream_copy_to_stream() (though the result will need to be decorated in a
+     * native PHP stream wrapper to work with such functions).
+     *
+     * If the moveTo() method has been called previously, this method MUST raise
+     * an exception.
+     *
+     * @return StreamInterface Stream representation of the uploaded file.
+     * @throws \RuntimeException in cases when no stream is available or can be
+     *     created.
+     */
+    public function getStream()
+    {
+        if ($this->moved) {
+            throw new \RuntimeException(sprintf('Uploaded file %1s has already been moved', $this->name));
+        }
+        if ($this->stream === null) {
+            $this->stream = new Stream(fopen($this->file, 'r'));
+        }
+
+        return $this->stream;
+    }
+
+    /**
+     * Move the uploaded file to a new location.
+     *
+     * Use this method as an alternative to move_uploaded_file(). This method is
+     * guaranteed to work in both SAPI and non-SAPI environments.
+     * Implementations must determine which environment they are in, and use the
+     * appropriate method (move_uploaded_file(), rename(), or a stream
+     * operation) to perform the operation.
+     *
+     * $targetPath may be an absolute path, or a relative path. If it is a
+     * relative path, resolution should be the same as used by PHP's rename()
+     * function.
+     *
+     * The original file or stream MUST be removed on completion.
+     *
+     * If this method is called more than once, any subsequent calls MUST raise
+     * an exception.
+     *
+     * When used in an SAPI environment where $_FILES is populated, when writing
+     * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be
+     * used to ensure permissions and upload status are verified correctly.
+     *
+     * If you wish to move to a stream, use getStream(), as SAPI operations
+     * cannot guarantee writing to stream destinations.
+     *
+     * @see http://php.net/is_uploaded_file
+     * @see http://php.net/move_uploaded_file
+     *
+     * @param string $targetPath Path to which to move the uploaded file.
+     *
+     * @throws InvalidArgumentException if the $path specified is invalid.
+     * @throws RuntimeException on any error during the move operation, or on
+     *     the second or subsequent call to the method.
+     */
+    public function moveTo($targetPath)
+    {
+        if ($this->moved) {
+            throw new RuntimeException('Uploaded file already moved');
+        }
+
+        $targetIsStream = strpos($targetPath, '://') > 0;
+        if (!$targetIsStream && !is_writable(dirname($targetPath))) {
+            throw new InvalidArgumentException('Upload target path is not writable');
+        }
+
+        if ($targetIsStream) {
+            if (!copy($this->file, $targetPath)) {
+                throw new RuntimeException(sprintf('Error moving uploaded file %1s to %2s', $this->name, $targetPath));
+            }
+            if (!unlink($this->file)) {
+                throw new RuntimeException(sprintf('Error removing uploaded file %1s', $this->name));
+            }
+        } elseif ($this->sapi) {
+            if (!is_uploaded_file($this->file)) {
+                throw new RuntimeException(sprintf('%1s is not a valid uploaded file', $this->file));
+            }
+
+            if (!move_uploaded_file($this->file, $targetPath)) {
+                throw new RuntimeException(sprintf('Error moving uploaded file %1s to %2s', $this->name, $targetPath));
+            }
+        } else {
+            if (!rename($this->file, $targetPath)) {
+                throw new RuntimeException(sprintf('Error moving uploaded file %1s to %2s', $this->name, $targetPath));
+            }
+        }
+
+        $this->moved = true;
+    }
+
+    /**
+     * Retrieve the error associated with the uploaded file.
+     *
+     * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
+     *
+     * If the file was uploaded successfully, this method MUST return
+     * UPLOAD_ERR_OK.
+     *
+     * Implementations SHOULD return the value stored in the "error" key of
+     * the file in the $_FILES array.
+     *
+     * @see http://php.net/manual/en/features.file-upload.errors.php
+     *
+     * @return int One of PHP's UPLOAD_ERR_XXX constants.
+     */
+    public function getError()
+    {
+        return $this->error;
+    }
+
+    /**
+     * Retrieve the filename sent by the client.
+     *
+     * Do not trust the value returned by this method. A client could send
+     * a malicious filename with the intention to corrupt or hack your
+     * application.
+     *
+     * Implementations SHOULD return the value stored in the "name" key of
+     * the file in the $_FILES array.
+     *
+     * @return string|null The filename sent by the client or null if none
+     *     was provided.
+     */
+    public function getClientFilename()
+    {
+        return $this->name;
+    }
+
+    /**
+     * Retrieve the media type sent by the client.
+     *
+     * Do not trust the value returned by this method. A client could send
+     * a malicious media type with the intention to corrupt or hack your
+     * application.
+     *
+     * Implementations SHOULD return the value stored in the "type" key of
+     * the file in the $_FILES array.
+     *
+     * @return string|null The media type sent by the client or null if none
+     *     was provided.
+     */
+    public function getClientMediaType()
+    {
+        return $this->type;
+    }
+
+    /**
+     * Retrieve the file size.
+     *
+     * Implementations SHOULD return the value stored in the "size" key of
+     * the file in the $_FILES array if available, as PHP calculates this based
+     * on the actual size transmitted.
+     *
+     * @return int|null The file size in bytes or null if unknown.
+     */
+    public function getSize()
+    {
+        return $this->size;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Http/Uri.php b/vendor/slim/slim/Slim/Http/Uri.php
new file mode 100644
index 0000000..31f202a
--- /dev/null
+++ b/vendor/slim/slim/Slim/Http/Uri.php
@@ -0,0 +1,824 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Http;
+
+use InvalidArgumentException;
+use \Psr\Http\Message\UriInterface;
+use Slim\Http\Environment;
+
+/**
+ * Value object representing a URI.
+ *
+ * This interface is meant to represent URIs according to RFC 3986 and to
+ * provide methods for most common operations. Additional functionality for
+ * working with URIs can be provided on top of the interface or externally.
+ * Its primary use is for HTTP requests, but may also be used in other
+ * contexts.
+ *
+ * Instances of this interface are considered immutable; all methods that
+ * might change state MUST be implemented such that they retain the internal
+ * state of the current instance and return an instance that contains the
+ * changed state.
+ *
+ * Typically the Host header will be also be present in the request message.
+ * For server-side requests, the scheme will typically be discoverable in the
+ * server parameters.
+ *
+ * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
+ */
+class Uri implements UriInterface
+{
+    /**
+     * Uri scheme (without "://" suffix)
+     *
+     * @var string
+     */
+    protected $scheme = '';
+
+    /**
+     * Uri user
+     *
+     * @var string
+     */
+    protected $user = '';
+
+    /**
+     * Uri password
+     *
+     * @var string
+     */
+    protected $password = '';
+
+    /**
+     * Uri host
+     *
+     * @var string
+     */
+    protected $host = '';
+
+    /**
+     * Uri port number
+     *
+     * @var null|int
+     */
+    protected $port;
+
+    /**
+     * Uri base path
+     *
+     * @var string
+     */
+    protected $basePath = '';
+
+    /**
+     * Uri path
+     *
+     * @var string
+     */
+    protected $path = '';
+
+    /**
+     * Uri query string (without "?" prefix)
+     *
+     * @var string
+     */
+    protected $query = '';
+
+    /**
+     * Uri fragment string (without "#" prefix)
+     *
+     * @var string
+     */
+    protected $fragment = '';
+
+    /**
+     * Create new Uri.
+     *
+     * @param string $scheme   Uri scheme.
+     * @param string $host     Uri host.
+     * @param int    $port     Uri port number.
+     * @param string $path     Uri path.
+     * @param string $query    Uri query string.
+     * @param string $fragment Uri fragment.
+     * @param string $user     Uri user.
+     * @param string $password Uri password.
+     */
+    public function __construct(
+        $scheme,
+        $host,
+        $port = null,
+        $path = '/',
+        $query = '',
+        $fragment = '',
+        $user = '',
+        $password = ''
+    ) {
+        $this->scheme = $this->filterScheme($scheme);
+        $this->host = $host;
+        $this->port = $this->filterPort($port);
+        $this->path = empty($path) ? '/' : $this->filterPath($path);
+        $this->query = $this->filterQuery($query);
+        $this->fragment = $this->filterQuery($fragment);
+        $this->user = $user;
+        $this->password = $password;
+    }
+
+    /**
+     * Create new Uri from string.
+     *
+     * @param  string $uri Complete Uri string
+     *     (i.e., https://user:pass@host:443/path?query).
+     *
+     * @return self
+     */
+    public static function createFromString($uri)
+    {
+        if (!is_string($uri) && !method_exists($uri, '__toString')) {
+            throw new InvalidArgumentException('Uri must be a string');
+        }
+
+        $parts = parse_url($uri);
+        $scheme = isset($parts['scheme']) ? $parts['scheme'] : '';
+        $user = isset($parts['user']) ? $parts['user'] : '';
+        $pass = isset($parts['pass']) ? $parts['pass'] : '';
+        $host = isset($parts['host']) ? $parts['host'] : '';
+        $port = isset($parts['port']) ? $parts['port'] : null;
+        $path = isset($parts['path']) ? $parts['path'] : '';
+        $query = isset($parts['query']) ? $parts['query'] : '';
+        $fragment = isset($parts['fragment']) ? $parts['fragment'] : '';
+
+        return new static($scheme, $host, $port, $path, $query, $fragment, $user, $pass);
+    }
+
+    /**
+     * Create new Uri from environment.
+     *
+     * @param Environment $env
+     *
+     * @return self
+     */
+    public static function createFromEnvironment(Environment $env)
+    {
+        // Scheme
+        $isSecure = $env->get('HTTPS');
+        $scheme = (empty($isSecure) || $isSecure === 'off') ? 'http' : 'https';
+
+        // Authority: Username and password
+        $username = $env->get('PHP_AUTH_USER', '');
+        $password = $env->get('PHP_AUTH_PW', '');
+
+        // Authority: Host
+        if ($env->has('HTTP_HOST')) {
+            $host = $env->get('HTTP_HOST');
+        } else {
+            $host = $env->get('SERVER_NAME');
+        }
+
+        // Authority: Port
+        $port = (int)$env->get('SERVER_PORT', 80);
+        if (preg_match('/^(\[[a-fA-F0-9:.]+\])(:\d+)?\z/', $host, $matches)) {
+            $host = $matches[1];
+
+            if ($matches[2]) {
+                $port = (int) substr($matches[2], 1);
+            }
+        } else {
+            $pos = strpos($host, ':');
+            if ($pos !== false) {
+                $port = (int) substr($host, $pos + 1);
+                $host = strstr($host, ':', true);
+            }
+        }
+
+        // Path
+        $requestScriptName = parse_url($env->get('SCRIPT_NAME'), PHP_URL_PATH);
+        $requestScriptDir = dirname($requestScriptName);
+
+        // parse_url() requires a full URL. As we don't extract the domain name or scheme,
+        // we use a stand-in.
+        $requestUri = parse_url('http://example.com' . $env->get('REQUEST_URI'), PHP_URL_PATH);
+
+        $basePath = '';
+        $virtualPath = $requestUri;
+        if (stripos($requestUri, $requestScriptName) === 0) {
+            $basePath = $requestScriptName;
+        } elseif ($requestScriptDir !== '/' && stripos($requestUri, $requestScriptDir) === 0) {
+            $basePath = $requestScriptDir;
+        }
+
+        if ($basePath) {
+            $virtualPath = ltrim(substr($requestUri, strlen($basePath)), '/');
+        }
+
+        // Query string
+        $queryString = $env->get('QUERY_STRING', '');
+        if ($queryString === '') {
+            $queryString = parse_url('http://example.com' . $env->get('REQUEST_URI'), PHP_URL_QUERY);
+        }
+
+        // Fragment
+        $fragment = '';
+
+        // Build Uri
+        $uri = new static($scheme, $host, $port, $virtualPath, $queryString, $fragment, $username, $password);
+        if ($basePath) {
+            $uri = $uri->withBasePath($basePath);
+        }
+
+        return $uri;
+    }
+
+    /********************************************************************************
+     * Scheme
+     *******************************************************************************/
+
+    /**
+     * Retrieve the scheme component of the URI.
+     *
+     * If no scheme is present, this method MUST return an empty string.
+     *
+     * The value returned MUST be normalized to lowercase, per RFC 3986
+     * Section 3.1.
+     *
+     * The trailing ":" character is not part of the scheme and MUST NOT be
+     * added.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-3.1
+     * @return string The URI scheme.
+     */
+    public function getScheme()
+    {
+        return $this->scheme;
+    }
+
+    /**
+     * Return an instance with the specified scheme.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified scheme.
+     *
+     * Implementations MUST support the schemes "http" and "https" case
+     * insensitively, and MAY accommodate other schemes if required.
+     *
+     * An empty scheme is equivalent to removing the scheme.
+     *
+     * @param string $scheme The scheme to use with the new instance.
+     * @return self A new instance with the specified scheme.
+     * @throws \InvalidArgumentException for invalid or unsupported schemes.
+     */
+    public function withScheme($scheme)
+    {
+        $scheme = $this->filterScheme($scheme);
+        $clone = clone $this;
+        $clone->scheme = $scheme;
+
+        return $clone;
+    }
+
+    /**
+     * Filter Uri scheme.
+     *
+     * @param  string $scheme Raw Uri scheme.
+     * @return string
+     *
+     * @throws InvalidArgumentException If the Uri scheme is not a string.
+     * @throws InvalidArgumentException If Uri scheme is not "", "https", or "http".
+     */
+    protected function filterScheme($scheme)
+    {
+        static $valid = [
+            '' => true,
+            'https' => true,
+            'http' => true,
+        ];
+
+        if (!is_string($scheme) && !method_exists($scheme, '__toString')) {
+            throw new InvalidArgumentException('Uri scheme must be a string');
+        }
+
+        $scheme = str_replace('://', '', strtolower((string)$scheme));
+        if (!isset($valid[$scheme])) {
+            throw new InvalidArgumentException('Uri scheme must be one of: "", "https", "http"');
+        }
+
+        return $scheme;
+    }
+
+    /********************************************************************************
+     * Authority
+     *******************************************************************************/
+
+    /**
+     * Retrieve the authority component of the URI.
+     *
+     * If no authority information is present, this method MUST return an empty
+     * string.
+     *
+     * The authority syntax of the URI is:
+     *
+     * <pre>
+     * [user-info@]host[:port]
+     * </pre>
+     *
+     * If the port component is not set or is the standard port for the current
+     * scheme, it SHOULD NOT be included.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-3.2
+     * @return string The URI authority, in "[user-info@]host[:port]" format.
+     */
+    public function getAuthority()
+    {
+        $userInfo = $this->getUserInfo();
+        $host = $this->getHost();
+        $port = $this->getPort();
+
+        return ($userInfo ? $userInfo . '@' : '') . $host . ($port !== null ? ':' . $port : '');
+    }
+
+    /**
+     * Retrieve the user information component of the URI.
+     *
+     * If no user information is present, this method MUST return an empty
+     * string.
+     *
+     * If a user is present in the URI, this will return that value;
+     * additionally, if the password is also present, it will be appended to the
+     * user value, with a colon (":") separating the values.
+     *
+     * The trailing "@" character is not part of the user information and MUST
+     * NOT be added.
+     *
+     * @return string The URI user information, in "username[:password]" format.
+     */
+    public function getUserInfo()
+    {
+        return $this->user . ($this->password ? ':' . $this->password : '');
+    }
+
+    /**
+     * Return an instance with the specified user information.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified user information.
+     *
+     * Password is optional, but the user information MUST include the
+     * user; an empty string for the user is equivalent to removing user
+     * information.
+     *
+     * @param string $user The user name to use for authority.
+     * @param null|string $password The password associated with $user.
+     * @return self A new instance with the specified user information.
+     */
+    public function withUserInfo($user, $password = null)
+    {
+        $clone = clone $this;
+        $clone->user = $user;
+        $clone->password = $password ? $password : '';
+
+        return $clone;
+    }
+
+    /**
+     * Retrieve the host component of the URI.
+     *
+     * If no host is present, this method MUST return an empty string.
+     *
+     * The value returned MUST be normalized to lowercase, per RFC 3986
+     * Section 3.2.2.
+     *
+     * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
+     * @return string The URI host.
+     */
+    public function getHost()
+    {
+        return $this->host;
+    }
+
+    /**
+     * Return an instance with the specified host.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified host.
+     *
+     * An empty host value is equivalent to removing the host.
+     *
+     * @param string $host The hostname to use with the new instance.
+     * @return self A new instance with the specified host.
+     * @throws \InvalidArgumentException for invalid hostnames.
+     */
+    public function withHost($host)
+    {
+        $clone = clone $this;
+        $clone->host = $host;
+
+        return $clone;
+    }
+
+    /**
+     * Retrieve the port component of the URI.
+     *
+     * If a port is present, and it is non-standard for the current scheme,
+     * this method MUST return it as an integer. If the port is the standard port
+     * used with the current scheme, this method SHOULD return null.
+     *
+     * If no port is present, and no scheme is present, this method MUST return
+     * a null value.
+     *
+     * If no port is present, but a scheme is present, this method MAY return
+     * the standard port for that scheme, but SHOULD return null.
+     *
+     * @return null|int The URI port.
+     */
+    public function getPort()
+    {
+        return $this->port && !$this->hasStandardPort() ? $this->port : null;
+    }
+
+    /**
+     * Return an instance with the specified port.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified port.
+     *
+     * Implementations MUST raise an exception for ports outside the
+     * established TCP and UDP port ranges.
+     *
+     * A null value provided for the port is equivalent to removing the port
+     * information.
+     *
+     * @param null|int $port The port to use with the new instance; a null value
+     *     removes the port information.
+     * @return self A new instance with the specified port.
+     * @throws \InvalidArgumentException for invalid ports.
+     */
+    public function withPort($port)
+    {
+        $port = $this->filterPort($port);
+        $clone = clone $this;
+        $clone->port = $port;
+
+        return $clone;
+    }
+
+    /**
+     * Does this Uri use a standard port?
+     *
+     * @return bool
+     */
+    protected function hasStandardPort()
+    {
+        return ($this->scheme === 'http' && $this->port === 80) || ($this->scheme === 'https' && $this->port === 443);
+    }
+
+    /**
+     * Filter Uri port.
+     *
+     * @param  null|int $port The Uri port number.
+     * @return null|int
+     *
+     * @throws InvalidArgumentException If the port is invalid.
+     */
+    protected function filterPort($port)
+    {
+        if (is_null($port) || (is_integer($port) && ($port >= 1 && $port <= 65535))) {
+            return $port;
+        }
+
+        throw new InvalidArgumentException('Uri port must be null or an integer between 1 and 65535 (inclusive)');
+    }
+
+    /********************************************************************************
+     * Path
+     *******************************************************************************/
+
+    /**
+     * Retrieve the path component of the URI.
+     *
+     * The path can either be empty or absolute (starting with a slash) or
+     * rootless (not starting with a slash). Implementations MUST support all
+     * three syntaxes.
+     *
+     * Normally, the empty path "" and absolute path "/" are considered equal as
+     * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
+     * do this normalization because in contexts with a trimmed base path, e.g.
+     * the front controller, this difference becomes significant. It's the task
+     * of the user to handle both "" and "/".
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.3.
+     *
+     * As an example, if the value should include a slash ("/") not intended as
+     * delimiter between path segments, that value MUST be passed in encoded
+     * form (e.g., "%2F") to the instance.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.3
+     * @return string The URI path.
+     */
+    public function getPath()
+    {
+        return $this->path;
+    }
+
+    /**
+     * Return an instance with the specified path.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified path.
+     *
+     * The path can either be empty or absolute (starting with a slash) or
+     * rootless (not starting with a slash). Implementations MUST support all
+     * three syntaxes.
+     *
+     * If the path is intended to be domain-relative rather than path relative then
+     * it must begin with a slash ("/"). Paths not starting with a slash ("/")
+     * are assumed to be relative to some base path known to the application or
+     * consumer.
+     *
+     * Users can provide both encoded and decoded path characters.
+     * Implementations ensure the correct encoding as outlined in getPath().
+     *
+     * @param string $path The path to use with the new instance.
+     * @return self A new instance with the specified path.
+     * @throws \InvalidArgumentException for invalid paths.
+     */
+    public function withPath($path)
+    {
+        if (!is_string($path)) {
+            throw new InvalidArgumentException('Uri path must be a string');
+        }
+
+        $clone = clone $this;
+        $clone->path = $this->filterPath($path);
+
+        // if the path is absolute, then clear basePath
+        if (substr($path, 0, 1) == '/') {
+            $clone->basePath = '';
+        }
+
+        return $clone;
+    }
+
+    /**
+     * Retrieve the base path segment of the URI.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * This method MUST return a string; if no path is present it MUST return
+     * an empty string.
+     *
+     * @return string The base path segment of the URI.
+     */
+    public function getBasePath()
+    {
+        return $this->basePath;
+    }
+
+    /**
+     * Set base path.
+     *
+     * Note: This method is not part of the PSR-7 standard.
+     *
+     * @param  string $basePath
+     * @return self
+     */
+    public function withBasePath($basePath)
+    {
+        if (!is_string($basePath)) {
+            throw new InvalidArgumentException('Uri path must be a string');
+        }
+        if (!empty($basePath)) {
+            $basePath = '/' . trim($basePath, '/'); // <-- Trim on both sides
+        }
+        $clone = clone $this;
+
+        if ($basePath !== '/') {
+            $clone->basePath = $this->filterPath($basePath);
+        }
+
+        return $clone;
+    }
+
+    /**
+     * Filter Uri path.
+     *
+     * This method percent-encodes all reserved
+     * characters in the provided path string. This method
+     * will NOT double-encode characters that are already
+     * percent-encoded.
+     *
+     * @param  string $path The raw uri path.
+     * @return string       The RFC 3986 percent-encoded uri path.
+     * @link   http://www.faqs.org/rfcs/rfc3986.html
+     */
+    protected function filterPath($path)
+    {
+        return preg_replace_callback(
+            '/(?:[^a-zA-Z0-9_\-\.~:@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/',
+            function ($match) {
+                return rawurlencode($match[0]);
+            },
+            $path
+        );
+    }
+
+    /********************************************************************************
+     * Query
+     *******************************************************************************/
+
+    /**
+     * Retrieve the query string of the URI.
+     *
+     * If no query string is present, this method MUST return an empty string.
+     *
+     * The leading "?" character is not part of the query and MUST NOT be
+     * added.
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.4.
+     *
+     * As an example, if a value in a key/value pair of the query string should
+     * include an ampersand ("&") not intended as a delimiter between values,
+     * that value MUST be passed in encoded form (e.g., "%26") to the instance.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.4
+     * @return string The URI query string.
+     */
+    public function getQuery()
+    {
+        return $this->query;
+    }
+
+    /**
+     * Return an instance with the specified query string.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified query string.
+     *
+     * Users can provide both encoded and decoded query characters.
+     * Implementations ensure the correct encoding as outlined in getQuery().
+     *
+     * An empty query string value is equivalent to removing the query string.
+     *
+     * @param string $query The query string to use with the new instance.
+     * @return self A new instance with the specified query string.
+     * @throws \InvalidArgumentException for invalid query strings.
+     */
+    public function withQuery($query)
+    {
+        if (!is_string($query) && !method_exists($query, '__toString')) {
+            throw new InvalidArgumentException('Uri query must be a string');
+        }
+        $query = ltrim((string)$query, '?');
+        $clone = clone $this;
+        $clone->query = $this->filterQuery($query);
+
+        return $clone;
+    }
+
+    /**
+     * Filters the query string or fragment of a URI.
+     *
+     * @param string $query The raw uri query string.
+     * @return string The percent-encoded query string.
+     */
+    protected function filterQuery($query)
+    {
+        return preg_replace_callback(
+            '/(?:[^a-zA-Z0-9_\-\.~!\$&\'\(\)\*\+,;=%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/',
+            function ($match) {
+                return rawurlencode($match[0]);
+            },
+            $query
+        );
+    }
+
+    /********************************************************************************
+     * Fragment
+     *******************************************************************************/
+
+    /**
+     * Retrieve the fragment component of the URI.
+     *
+     * If no fragment is present, this method MUST return an empty string.
+     *
+     * The leading "#" character is not part of the fragment and MUST NOT be
+     * added.
+     *
+     * The value returned MUST be percent-encoded, but MUST NOT double-encode
+     * any characters. To determine what characters to encode, please refer to
+     * RFC 3986, Sections 2 and 3.5.
+     *
+     * @see https://tools.ietf.org/html/rfc3986#section-2
+     * @see https://tools.ietf.org/html/rfc3986#section-3.5
+     * @return string The URI fragment.
+     */
+    public function getFragment()
+    {
+        return $this->fragment;
+    }
+
+    /**
+     * Return an instance with the specified URI fragment.
+     *
+     * This method MUST retain the state of the current instance, and return
+     * an instance that contains the specified URI fragment.
+     *
+     * Users can provide both encoded and decoded fragment characters.
+     * Implementations ensure the correct encoding as outlined in getFragment().
+     *
+     * An empty fragment value is equivalent to removing the fragment.
+     *
+     * @param string $fragment The fragment to use with the new instance.
+     * @return self A new instance with the specified fragment.
+     */
+    public function withFragment($fragment)
+    {
+        if (!is_string($fragment) && !method_exists($fragment, '__toString')) {
+            throw new InvalidArgumentException('Uri fragment must be a string');
+        }
+        $fragment = ltrim((string)$fragment, '#');
+        $clone = clone $this;
+        $clone->fragment = $this->filterQuery($fragment);
+
+        return $clone;
+    }
+
+    /********************************************************************************
+     * Helpers
+     *******************************************************************************/
+
+    /**
+     * Return the string representation as a URI reference.
+     *
+     * Depending on which components of the URI are present, the resulting
+     * string is either a full URI or relative reference according to RFC 3986,
+     * Section 4.1. The method concatenates the various components of the URI,
+     * using the appropriate delimiters:
+     *
+     * - If a scheme is present, it MUST be suffixed by ":".
+     * - If an authority is present, it MUST be prefixed by "//".
+     * - The path can be concatenated without delimiters. But there are two
+     *   cases where the path has to be adjusted to make the URI reference
+     *   valid as PHP does not allow to throw an exception in __toString():
+     *     - If the path is rootless and an authority is present, the path MUST
+     *       be prefixed by "/".
+     *     - If the path is starting with more than one "/" and no authority is
+     *       present, the starting slashes MUST be reduced to one.
+     * - If a query is present, it MUST be prefixed by "?".
+     * - If a fragment is present, it MUST be prefixed by "#".
+     *
+     * @see http://tools.ietf.org/html/rfc3986#section-4.1
+     * @return string
+     */
+    public function __toString()
+    {
+        $scheme = $this->getScheme();
+        $authority = $this->getAuthority();
+        $basePath = $this->getBasePath();
+        $path = $this->getPath();
+        $query = $this->getQuery();
+        $fragment = $this->getFragment();
+
+        $path = $basePath . '/' . ltrim($path, '/');
+
+        return ($scheme ? $scheme . ':' : '')
+            . ($authority ? '//' . $authority : '')
+            . $path
+            . ($query ? '?' . $query : '')
+            . ($fragment ? '#' . $fragment : '');
+    }
+
+    /**
+     * Return the fully qualified base URL.
+     *
+     * Note that this method never includes a trailing /
+     *
+     * This method is not part of PSR-7.
+     *
+     * @return string
+     */
+    public function getBaseUrl()
+    {
+        $scheme = $this->getScheme();
+        $authority = $this->getAuthority();
+        $basePath = $this->getBasePath();
+
+        if ($authority && substr($basePath, 0, 1) !== '/') {
+            $basePath = $basePath . '/' . $basePath;
+        }
+
+        return ($scheme ? $scheme . ':' : '')
+            . ($authority ? '//' . $authority : '')
+            . rtrim($basePath, '/');
+    }
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/CallableResolverInterface.php b/vendor/slim/slim/Slim/Interfaces/CallableResolverInterface.php
new file mode 100644
index 0000000..17d81db
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/CallableResolverInterface.php
@@ -0,0 +1,27 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+/**
+ * Resolves a callable.
+ *
+ * @package Slim
+ * @since 3.0.0
+ */
+interface CallableResolverInterface
+{
+    /**
+     * Invoke the resolved callable.
+     *
+     * @param mixed $toResolve
+     *
+     * @return callable
+     */
+    public function resolve($toResolve);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/CollectionInterface.php b/vendor/slim/slim/Slim/Interfaces/CollectionInterface.php
new file mode 100644
index 0000000..be995bf
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/CollectionInterface.php
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+/**
+ * Collection Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface CollectionInterface extends \ArrayAccess, \Countable, \IteratorAggregate
+{
+    public function set($key, $value);
+
+    public function get($key, $default = null);
+
+    public function replace(array $items);
+
+    public function all();
+
+    public function has($key);
+
+    public function remove($key);
+
+    public function clear();
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/Http/CookiesInterface.php b/vendor/slim/slim/Slim/Interfaces/Http/CookiesInterface.php
new file mode 100644
index 0000000..206175a
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/Http/CookiesInterface.php
@@ -0,0 +1,23 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces\Http;
+
+/**
+ * Cookies Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface CookiesInterface
+{
+    public function get($name, $default = null);
+    public function set($name, $value);
+    public function toHeaders();
+    public static function parseHeader($header);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/Http/EnvironmentInterface.php b/vendor/slim/slim/Slim/Interfaces/Http/EnvironmentInterface.php
new file mode 100644
index 0000000..af19d28
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/Http/EnvironmentInterface.php
@@ -0,0 +1,20 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces\Http;
+
+/**
+ * Environment Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface EnvironmentInterface
+{
+    public static function mock(array $settings = []);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/Http/HeadersInterface.php b/vendor/slim/slim/Slim/Interfaces/Http/HeadersInterface.php
new file mode 100644
index 0000000..b737705
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/Http/HeadersInterface.php
@@ -0,0 +1,24 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces\Http;
+
+use Slim\Interfaces\CollectionInterface;
+
+/**
+ * Headers Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface HeadersInterface extends CollectionInterface
+{
+    public function add($key, $value);
+
+    public function normalizeKey($key);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/InvocationStrategyInterface.php b/vendor/slim/slim/Slim/Interfaces/InvocationStrategyInterface.php
new file mode 100644
index 0000000..14a92c1
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/InvocationStrategyInterface.php
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\ServerRequestInterface;
+
+/**
+ * Defines a contract for invoking a route callable.
+ */
+interface InvocationStrategyInterface
+{
+    /**
+     * Invoke a route callable.
+     *
+     * @param callable               $callable The callable to invoke using the strategy.
+     * @param ServerRequestInterface $request The request object.
+     * @param ResponseInterface      $response The response object.
+     * @param array                  $routeArguments The route's placholder arguments
+     *
+     * @return ResponseInterface|string The response from the callable.
+     */
+    public function __invoke(
+        callable $callable,
+        ServerRequestInterface $request,
+        ResponseInterface $response,
+        array $routeArguments
+    );
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/RouteGroupInterface.php b/vendor/slim/slim/Slim/Interfaces/RouteGroupInterface.php
new file mode 100644
index 0000000..5ed3303
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/RouteGroupInterface.php
@@ -0,0 +1,46 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+use Slim\App;
+
+/**
+ * RouteGroup Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface RouteGroupInterface
+{
+    /**
+     * Get route pattern
+     *
+     * @return string
+     */
+    public function getPattern();
+
+    /**
+     * Prepend middleware to the group middleware collection
+     *
+     * @param callable|string $callable The callback routine
+     *
+     * @return RouteGroupInterface
+     */
+    public function add($callable);
+
+    /**
+     * Execute route group callable in the context of the Slim App
+     *
+     * This method invokes the route group object's callable, collecting
+     * nested route objects
+     *
+     * @param App $app
+     */
+    public function __invoke(App $app);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/RouteInterface.php b/vendor/slim/slim/Slim/Interfaces/RouteInterface.php
new file mode 100644
index 0000000..d2d0d24
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/RouteInterface.php
@@ -0,0 +1,129 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+use InvalidArgumentException;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+
+/**
+ * Route Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface RouteInterface
+{
+
+    /**
+     * Retrieve a specific route argument
+     *
+     * @param string $name
+     * @param string|null $default
+     *
+     * @return string|null
+     */
+    public function getArgument($name, $default = null);
+
+    /**
+     * Get route arguments
+     *
+     * @return string[]
+     */
+    public function getArguments();
+
+    /**
+     * Get route name
+     *
+     * @return null|string
+     */
+    public function getName();
+
+    /**
+     * Get route pattern
+     *
+     * @return string
+     */
+    public function getPattern();
+
+    /**
+     * Set a route argument
+     *
+     * @param string $name
+     * @param string $value
+     *
+     * @return self
+     */
+    public function setArgument($name, $value);
+
+    /**
+     * Replace route arguments
+     *
+     * @param string[] $arguments
+     *
+     * @return self
+     */
+    public function setArguments(array $arguments);
+
+    /**
+     * Set route name
+     *
+     * @param string $name
+     *
+     * @return static
+     * @throws InvalidArgumentException if the route name is not a string
+     */
+    public function setName($name);
+
+    /**
+     * Add middleware
+     *
+     * This method prepends new middleware to the route's middleware stack.
+     *
+     * @param callable|string $callable The callback routine
+     *
+     * @return RouteInterface
+     */
+    public function add($callable);
+
+    /**
+     * Prepare the route for use
+     *
+     * @param ServerRequestInterface $request
+     * @param array $arguments
+     */
+    public function prepare(ServerRequestInterface $request, array $arguments);
+
+    /**
+     * Run route
+     *
+     * This method traverses the middleware stack, including the route's callable
+     * and captures the resultant HTTP response object. It then sends the response
+     * back to the Application.
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface $response
+     * @return ResponseInterface
+     */
+    public function run(ServerRequestInterface $request, ResponseInterface $response);
+
+    /**
+     * Dispatch route callable against current Request and Response objects
+     *
+     * This method invokes the route object's callable. If middleware is
+     * registered for the route, each callable middleware is invoked in
+     * the order specified.
+     *
+     * @param ServerRequestInterface $request  The current Request object
+     * @param ResponseInterface      $response The current Response object
+     *
+     * @return ResponseInterface
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response);
+}
diff --git a/vendor/slim/slim/Slim/Interfaces/RouterInterface.php b/vendor/slim/slim/Slim/Interfaces/RouterInterface.php
new file mode 100644
index 0000000..2ab8b67
--- /dev/null
+++ b/vendor/slim/slim/Slim/Interfaces/RouterInterface.php
@@ -0,0 +1,111 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim\Interfaces;
+
+use RuntimeException;
+use InvalidArgumentException;
+use Psr\Http\Message\ServerRequestInterface;
+
+/**
+ * Router Interface
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+interface RouterInterface
+{
+    // array keys from route result
+    const DISPATCH_STATUS = 0;
+    const ALLOWED_METHODS = 1;
+
+    /**
+     * Add route
+     *
+     * @param string[] $methods Array of HTTP methods
+     * @param string   $pattern The route pattern
+     * @param callable $handler The route callable
+     *
+     * @return RouteInterface
+     */
+    public function map($methods, $pattern, $handler);
+
+    /**
+     * Dispatch router for HTTP request
+     *
+     * @param  ServerRequestInterface $request The current HTTP request object
+     *
+     * @return array
+     *
+     * @link   https://github.com/nikic/FastRoute/blob/master/src/Dispatcher.php
+     */
+    public function dispatch(ServerRequestInterface $request);
+
+    /**
+     * Add a route group to the array
+     *
+     * @param string   $pattern The group pattern
+     * @param callable $callable A group callable
+     *
+     * @return RouteGroupInterface
+     */
+    public function pushGroup($pattern, $callable);
+
+    /**
+     * Removes the last route group from the array
+     *
+     * @return bool True if successful, else False
+     */
+    public function popGroup();
+
+    /**
+     * Get named route object
+     *
+     * @param string $name        Route name
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     *
+     * @throws RuntimeException   If named route does not exist
+     */
+    public function getNamedRoute($name);
+
+    /**
+     * @param $identifier
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function lookupRoute($identifier);
+
+    /**
+     * Build the path for a named route excluding the base path
+     *
+     * @param string $name        Route name
+     * @param array  $data        Named argument replacement data
+     * @param array  $queryParams Optional query string parameters
+     *
+     * @return string
+     *
+     * @throws RuntimeException         If named route does not exist
+     * @throws InvalidArgumentException If required data not provided
+     */
+    public function relativePathFor($name, array $data = [], array $queryParams = []);
+
+    /**
+     * Build the path for a named route including the base path
+     *
+     * @param string $name        Route name
+     * @param array  $data        Named argument replacement data
+     * @param array  $queryParams Optional query string parameters
+     *
+     * @return string
+     *
+     * @throws RuntimeException         If named route does not exist
+     * @throws InvalidArgumentException If required data not provided
+     */
+    public function pathFor($name, array $data = [], array $queryParams = []);
+}
diff --git a/vendor/slim/slim/Slim/MiddlewareAwareTrait.php b/vendor/slim/slim/Slim/MiddlewareAwareTrait.php
new file mode 100644
index 0000000..14404b5
--- /dev/null
+++ b/vendor/slim/slim/Slim/MiddlewareAwareTrait.php
@@ -0,0 +1,126 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use RuntimeException;
+use SplStack;
+use SplDoublyLinkedList;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+use UnexpectedValueException;
+
+/**
+ * Middleware
+ *
+ * This is an internal class that enables concentric middleware layers. This
+ * class is an implementation detail and is used only inside of the Slim
+ * application; it is not visible to—and should not be used by—end users.
+ */
+trait MiddlewareAwareTrait
+{
+    /**
+     * Middleware call stack
+     *
+     * @var  \SplStack
+     * @link http://php.net/manual/class.splstack.php
+     */
+    protected $stack;
+
+    /**
+     * Middleware stack lock
+     *
+     * @var bool
+     */
+    protected $middlewareLock = false;
+
+    /**
+     * Add middleware
+     *
+     * This method prepends new middleware to the application middleware stack.
+     *
+     * @param callable $callable Any callable that accepts three arguments:
+     *                           1. A Request object
+     *                           2. A Response object
+     *                           3. A "next" middleware callable
+     * @return static
+     *
+     * @throws RuntimeException         If middleware is added while the stack is dequeuing
+     * @throws UnexpectedValueException If the middleware doesn't return a Psr\Http\Message\ResponseInterface
+     */
+    protected function addMiddleware(callable $callable)
+    {
+        if ($this->middlewareLock) {
+            throw new RuntimeException('Middleware can’t be added once the stack is dequeuing');
+        }
+
+        if (is_null($this->stack)) {
+            $this->seedMiddlewareStack();
+        }
+        $next = $this->stack->top();
+        $this->stack[] = function (
+            ServerRequestInterface $request,
+            ResponseInterface $response
+        ) use (
+            $callable,
+            $next
+        ) {
+            $result = call_user_func($callable, $request, $response, $next);
+            if ($result instanceof ResponseInterface === false) {
+                throw new UnexpectedValueException(
+                    'Middleware must return instance of \Psr\Http\Message\ResponseInterface'
+                );
+            }
+
+            return $result;
+        };
+
+        return $this;
+    }
+
+    /**
+     * Seed middleware stack with first callable
+     *
+     * @param callable $kernel The last item to run as middleware
+     *
+     * @throws RuntimeException if the stack is seeded more than once
+     */
+    protected function seedMiddlewareStack(callable $kernel = null)
+    {
+        if (!is_null($this->stack)) {
+            throw new RuntimeException('MiddlewareStack can only be seeded once.');
+        }
+        if ($kernel === null) {
+            $kernel = $this;
+        }
+        $this->stack = new SplStack;
+        $this->stack->setIteratorMode(SplDoublyLinkedList::IT_MODE_LIFO | SplDoublyLinkedList::IT_MODE_KEEP);
+        $this->stack[] = $kernel;
+    }
+
+    /**
+     * Call middleware stack
+     *
+     * @param  ServerRequestInterface $request A request object
+     * @param  ResponseInterface      $response A response object
+     *
+     * @return ResponseInterface
+     */
+    public function callMiddlewareStack(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        if (is_null($this->stack)) {
+            $this->seedMiddlewareStack();
+        }
+        /** @var callable $start */
+        $start = $this->stack->top();
+        $this->middlewareLock = true;
+        $response = $start($request, $response);
+        $this->middlewareLock = false;
+        return $response;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Routable.php b/vendor/slim/slim/Slim/Routable.php
new file mode 100644
index 0000000..c912db4
--- /dev/null
+++ b/vendor/slim/slim/Slim/Routable.php
@@ -0,0 +1,106 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Psr\Container\ContainerInterface;
+
+/**
+ * A routable, middleware-aware object
+ *
+ * @package Slim
+ * @since   3.0.0
+ */
+abstract class Routable
+{
+    use CallableResolverAwareTrait;
+
+    /**
+     * Route callable
+     *
+     * @var callable
+     */
+    protected $callable;
+
+    /**
+     * Container
+     *
+     * @var ContainerInterface
+     */
+    protected $container;
+
+    /**
+     * Route middleware
+     *
+     * @var callable[]
+     */
+    protected $middleware = [];
+
+    /**
+     * Route pattern
+     *
+     * @var string
+     */
+    protected $pattern;
+
+    /**
+     * Get the middleware registered for the group
+     *
+     * @return callable[]
+     */
+    public function getMiddleware()
+    {
+        return $this->middleware;
+    }
+
+    /**
+     * Get the route pattern
+     *
+     * @return string
+     */
+    public function getPattern()
+    {
+        return $this->pattern;
+    }
+
+    /**
+     * Set container for use with resolveCallable
+     *
+     * @param ContainerInterface $container
+     *
+     * @return self
+     */
+    public function setContainer(ContainerInterface $container)
+    {
+        $this->container = $container;
+        return $this;
+    }
+
+    /**
+     * Prepend middleware to the middleware collection
+     *
+     * @param callable|string $callable The callback routine
+     *
+     * @return static
+     */
+    public function add($callable)
+    {
+        $this->middleware[] = new DeferredCallable($callable, $this->container);
+        return $this;
+    }
+
+    /**
+     * Set the route pattern
+     *
+     * @param string $newPattern
+     */
+    public function setPattern($newPattern)
+    {
+        $this->pattern = $newPattern;
+    }
+}
diff --git a/vendor/slim/slim/Slim/Route.php b/vendor/slim/slim/Slim/Route.php
new file mode 100644
index 0000000..6a44b3f
--- /dev/null
+++ b/vendor/slim/slim/Slim/Route.php
@@ -0,0 +1,381 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Exception;
+use Throwable;
+use InvalidArgumentException;
+use Psr\Http\Message\ServerRequestInterface;
+use Psr\Http\Message\ResponseInterface;
+use Slim\Exception\SlimException;
+use Slim\Handlers\Strategies\RequestResponse;
+use Slim\Interfaces\InvocationStrategyInterface;
+use Slim\Interfaces\RouteInterface;
+
+/**
+ * Route
+ */
+class Route extends Routable implements RouteInterface
+{
+    use MiddlewareAwareTrait;
+
+    /**
+     * HTTP methods supported by this route
+     *
+     * @var string[]
+     */
+    protected $methods = [];
+
+    /**
+     * Route identifier
+     *
+     * @var string
+     */
+    protected $identifier;
+
+    /**
+     * Route name
+     *
+     * @var null|string
+     */
+    protected $name;
+
+    /**
+     * Parent route groups
+     *
+     * @var RouteGroup[]
+     */
+    protected $groups;
+
+    private $finalized = false;
+
+    /**
+     * Output buffering mode
+     *
+     * One of: false, 'prepend' or 'append'
+     *
+     * @var boolean|string
+     */
+    protected $outputBuffering = 'append';
+
+    /**
+     * Route parameters
+     *
+     * @var array
+     */
+    protected $arguments = [];
+
+    /**
+     * The callable payload
+     *
+     * @var callable
+     */
+    protected $callable;
+
+    /**
+     * Create new route
+     *
+     * @param string|string[]   $methods The route HTTP methods
+     * @param string            $pattern The route pattern
+     * @param callable          $callable The route callable
+     * @param RouteGroup[]      $groups The parent route groups
+     * @param int               $identifier The route identifier
+     */
+    public function __construct($methods, $pattern, $callable, $groups = [], $identifier = 0)
+    {
+        $this->methods  = is_string($methods) ? [$methods] : $methods;
+        $this->pattern  = $pattern;
+        $this->callable = $callable;
+        $this->groups   = $groups;
+        $this->identifier = 'route' . $identifier;
+    }
+
+    /**
+     * Finalize the route in preparation for dispatching
+     */
+    public function finalize()
+    {
+        if ($this->finalized) {
+            return;
+        }
+
+        $groupMiddleware = [];
+        foreach ($this->getGroups() as $group) {
+            $groupMiddleware = array_merge($group->getMiddleware(), $groupMiddleware);
+        }
+
+        $this->middleware = array_merge($this->middleware, $groupMiddleware);
+
+        foreach ($this->getMiddleware() as $middleware) {
+            $this->addMiddleware($middleware);
+        }
+
+        $this->finalized = true;
+    }
+
+    /**
+     * Get route callable
+     *
+     * @return callable
+     */
+    public function getCallable()
+    {
+        return $this->callable;
+    }
+
+    /**
+     * This method enables you to override the Route's callable
+     *
+     * @param string|\Closure $callable
+     */
+    public function setCallable($callable)
+    {
+        $this->callable = $callable;
+    }
+
+    /**
+     * Get route methods
+     *
+     * @return string[]
+     */
+    public function getMethods()
+    {
+        return $this->methods;
+    }
+
+    /**
+     * Get parent route groups
+     *
+     * @return RouteGroup[]
+     */
+    public function getGroups()
+    {
+        return $this->groups;
+    }
+
+    /**
+     * Get route name
+     *
+     * @return null|string
+     */
+    public function getName()
+    {
+        return $this->name;
+    }
+
+    /**
+     * Get route identifier
+     *
+     * @return string
+     */
+    public function getIdentifier()
+    {
+        return $this->identifier;
+    }
+
+    /**
+     * Get output buffering mode
+     *
+     * @return boolean|string
+     */
+    public function getOutputBuffering()
+    {
+        return $this->outputBuffering;
+    }
+
+    /**
+     * Set output buffering mode
+     *
+     * One of: false, 'prepend' or 'append'
+     *
+     * @param boolean|string $mode
+     *
+     * @throws InvalidArgumentException If an unknown buffering mode is specified
+     */
+    public function setOutputBuffering($mode)
+    {
+        if (!in_array($mode, [false, 'prepend', 'append'], true)) {
+            throw new InvalidArgumentException('Unknown output buffering mode');
+        }
+        $this->outputBuffering = $mode;
+    }
+
+    /**
+     * Set route name
+     *
+     * @param string $name
+     *
+     * @return self
+     *
+     * @throws InvalidArgumentException if the route name is not a string
+     */
+    public function setName($name)
+    {
+        if (!is_string($name)) {
+            throw new InvalidArgumentException('Route name must be a string');
+        }
+        $this->name = $name;
+        return $this;
+    }
+
+    /**
+     * Set a route argument
+     *
+     * @param string $name
+     * @param string $value
+     *
+     * @return self
+     */
+    public function setArgument($name, $value)
+    {
+        $this->arguments[$name] = $value;
+        return $this;
+    }
+
+    /**
+     * Replace route arguments
+     *
+     * @param array $arguments
+     *
+     * @return self
+     */
+    public function setArguments(array $arguments)
+    {
+        $this->arguments = $arguments;
+        return $this;
+    }
+
+    /**
+     * Retrieve route arguments
+     *
+     * @return array
+     */
+    public function getArguments()
+    {
+        return $this->arguments;
+    }
+
+    /**
+     * Retrieve a specific route argument
+     *
+     * @param string $name
+     * @param string|null $default
+     *
+     * @return mixed
+     */
+    public function getArgument($name, $default = null)
+    {
+        if (array_key_exists($name, $this->arguments)) {
+            return $this->arguments[$name];
+        }
+        return $default;
+    }
+
+    /********************************************************************************
+     * Route Runner
+     *******************************************************************************/
+
+    /**
+     * Prepare the route for use
+     *
+     * @param ServerRequestInterface $request
+     * @param array $arguments
+     */
+    public function prepare(ServerRequestInterface $request, array $arguments)
+    {
+        // Add the arguments
+        foreach ($arguments as $k => $v) {
+            $this->setArgument($k, $v);
+        }
+    }
+
+    /**
+     * Run route
+     *
+     * This method traverses the middleware stack, including the route's callable
+     * and captures the resultant HTTP response object. It then sends the response
+     * back to the Application.
+     *
+     * @param ServerRequestInterface $request
+     * @param ResponseInterface      $response
+     *
+     * @return ResponseInterface
+     */
+    public function run(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        // Finalise route now that we are about to run it
+        $this->finalize();
+
+        // Traverse middleware stack and fetch updated response
+        return $this->callMiddlewareStack($request, $response);
+    }
+
+    /**
+     * Dispatch route callable against current Request and Response objects
+     *
+     * This method invokes the route object's callable. If middleware is
+     * registered for the route, each callable middleware is invoked in
+     * the order specified.
+     *
+     * @param ServerRequestInterface $request  The current Request object
+     * @param ResponseInterface      $response The current Response object
+     * @return \Psr\Http\Message\ResponseInterface
+     * @throws \Exception  if the route callable throws an exception
+     */
+    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)
+    {
+        $this->callable = $this->resolveCallable($this->callable);
+
+        /** @var InvocationStrategyInterface $handler */
+        $handler = isset($this->container) ? $this->container->get('foundHandler') : new RequestResponse();
+
+        // invoke route callable
+        if ($this->outputBuffering === false) {
+            $newResponse = $handler($this->callable, $request, $response, $this->arguments);
+        } else {
+            try {
+                ob_start();
+                $newResponse = $handler($this->callable, $request, $response, $this->arguments);
+                $output = ob_get_clean();
+            // @codeCoverageIgnoreStart
+            } catch (Throwable $e) {
+                ob_end_clean();
+                throw $e;
+            // @codeCoverageIgnoreEnd
+            } catch (Exception $e) {
+                ob_end_clean();
+                throw $e;
+            }
+        }
+
+        if ($newResponse instanceof ResponseInterface) {
+            // if route callback returns a ResponseInterface, then use it
+            $response = $newResponse;
+        } elseif (is_string($newResponse)) {
+            // if route callback returns a string, then append it to the response
+            if ($response->getBody()->isWritable()) {
+                $response->getBody()->write($newResponse);
+            }
+        }
+
+        if (!empty($output) && $response->getBody()->isWritable()) {
+            if ($this->outputBuffering === 'prepend') {
+                // prepend output buffer content
+                $body = new Http\Body(fopen('php://temp', 'r+'));
+                $body->write($output . $response->getBody());
+                $response = $response->withBody($body);
+            } elseif ($this->outputBuffering === 'append') {
+                // append output buffer content
+                $response->getBody()->write($output);
+            }
+        }
+
+        return $response;
+    }
+}
diff --git a/vendor/slim/slim/Slim/RouteGroup.php b/vendor/slim/slim/Slim/RouteGroup.php
new file mode 100644
index 0000000..705ac45
--- /dev/null
+++ b/vendor/slim/slim/Slim/RouteGroup.php
@@ -0,0 +1,47 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use Closure;
+use Slim\Interfaces\RouteGroupInterface;
+
+/**
+ * A collector for Routable objects with a common middleware stack
+ *
+ * @package Slim
+ */
+class RouteGroup extends Routable implements RouteGroupInterface
+{
+    /**
+     * Create a new RouteGroup
+     *
+     * @param string   $pattern  The pattern prefix for the group
+     * @param callable $callable The group callable
+     */
+    public function __construct($pattern, $callable)
+    {
+        $this->pattern = $pattern;
+        $this->callable = $callable;
+    }
+
+    /**
+     * Invoke the group to register any Routable objects within it.
+     *
+     * @param App $app The App to bind the callable to.
+     */
+    public function __invoke(App $app = null)
+    {
+        $callable = $this->resolveCallable($this->callable);
+        if ($callable instanceof Closure && $app !== null) {
+            $callable = $callable->bindTo($app);
+        }
+
+        $callable();
+    }
+}
diff --git a/vendor/slim/slim/Slim/Router.php b/vendor/slim/slim/Slim/Router.php
new file mode 100644
index 0000000..8311628
--- /dev/null
+++ b/vendor/slim/slim/Slim/Router.php
@@ -0,0 +1,455 @@
+<?php
+/**
+ * Slim Framework (https://slimframework.com)
+ *
+ * @link      https://github.com/slimphp/Slim
+ * @copyright Copyright (c) 2011-2017 Josh Lockhart
+ * @license   https://github.com/slimphp/Slim/blob/3.x/LICENSE.md (MIT License)
+ */
+namespace Slim;
+
+use FastRoute\Dispatcher;
+use Psr\Container\ContainerInterface;
+use InvalidArgumentException;
+use RuntimeException;
+use Psr\Http\Message\ServerRequestInterface;
+use FastRoute\RouteCollector;
+use FastRoute\RouteParser;
+use FastRoute\RouteParser\Std as StdParser;
+use Slim\Interfaces\RouteGroupInterface;
+use Slim\Interfaces\RouterInterface;
+use Slim\Interfaces\RouteInterface;
+
+/**
+ * Router
+ *
+ * This class organizes Slim application route objects. It is responsible
+ * for registering route objects, assigning names to route objects,
+ * finding routes that match the current HTTP request, and creating
+ * URLs for a named route.
+ */
+class Router implements RouterInterface
+{
+    /**
+     * Container Interface
+     *
+     * @var ContainerInterface
+     */
+    protected $container;
+
+    /**
+     * Parser
+     *
+     * @var \FastRoute\RouteParser
+     */
+    protected $routeParser;
+
+    /**
+     * Base path used in pathFor()
+     *
+     * @var string
+     */
+    protected $basePath = '';
+
+    /**
+     * Path to fast route cache file. Set to false to disable route caching
+     *
+     * @var string|False
+     */
+    protected $cacheFile = false;
+
+    /**
+     * Routes
+     *
+     * @var Route[]
+     */
+    protected $routes = [];
+
+    /**
+     * Route counter incrementer
+     * @var int
+     */
+    protected $routeCounter = 0;
+
+    /**
+     * Route groups
+     *
+     * @var RouteGroup[]
+     */
+    protected $routeGroups = [];
+
+    /**
+     * @var \FastRoute\Dispatcher
+     */
+    protected $dispatcher;
+
+    /**
+     * Create new router
+     *
+     * @param RouteParser   $parser
+     */
+    public function __construct(RouteParser $parser = null)
+    {
+        $this->routeParser = $parser ?: new StdParser;
+    }
+
+    /**
+     * Set the base path used in pathFor()
+     *
+     * @param string $basePath
+     *
+     * @return self
+     */
+    public function setBasePath($basePath)
+    {
+        if (!is_string($basePath)) {
+            throw new InvalidArgumentException('Router basePath must be a string');
+        }
+
+        $this->basePath = $basePath;
+
+        return $this;
+    }
+
+    /**
+     * Set path to fast route cache file. If this is false then route caching is disabled.
+     *
+     * @param string|false $cacheFile
+     *
+     * @return self
+     */
+    public function setCacheFile($cacheFile)
+    {
+        if (!is_string($cacheFile) && $cacheFile !== false) {
+            throw new InvalidArgumentException('Router cacheFile must be a string or false');
+        }
+
+        $this->cacheFile = $cacheFile;
+
+        if ($cacheFile !== false && !is_writable(dirname($cacheFile))) {
+            throw new RuntimeException('Router cacheFile directory must be writable');
+        }
+
+
+        return $this;
+    }
+
+    /**
+     * @param ContainerInterface $container
+     */
+    public function setContainer(ContainerInterface $container)
+    {
+        $this->container = $container;
+    }
+
+    /**
+     * Add route
+     *
+     * @param  string[] $methods Array of HTTP methods
+     * @param  string   $pattern The route pattern
+     * @param  callable $handler The route callable
+     *
+     * @return RouteInterface
+     *
+     * @throws InvalidArgumentException if the route pattern isn't a string
+     */
+    public function map($methods, $pattern, $handler)
+    {
+        if (!is_string($pattern)) {
+            throw new InvalidArgumentException('Route pattern must be a string');
+        }
+
+        // Prepend parent group pattern(s)
+        if ($this->routeGroups) {
+            $pattern = $this->processGroups() . $pattern;
+        }
+
+        // According to RFC methods are defined in uppercase (See RFC 7231)
+        $methods = array_map("strtoupper", $methods);
+
+        // Add route
+        $route = $this->createRoute($methods, $pattern, $handler);
+        $this->routes[$route->getIdentifier()] = $route;
+        $this->routeCounter++;
+
+        return $route;
+    }
+
+    /**
+     * Dispatch router for HTTP request
+     *
+     * @param  ServerRequestInterface $request The current HTTP request object
+     *
+     * @return array
+     *
+     * @link   https://github.com/nikic/FastRoute/blob/master/src/Dispatcher.php
+     */
+    public function dispatch(ServerRequestInterface $request)
+    {
+        $uri = '/' . ltrim($request->getUri()->getPath(), '/');
+
+        return $this->createDispatcher()->dispatch(
+            $request->getMethod(),
+            $uri
+        );
+    }
+
+    /**
+     * Create a new Route object
+     *
+     * @param  string[] $methods Array of HTTP methods
+     * @param  string   $pattern The route pattern
+     * @param  callable $callable The route callable
+     *
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    protected function createRoute($methods, $pattern, $callable)
+    {
+        $route = new Route($methods, $pattern, $callable, $this->routeGroups, $this->routeCounter);
+        if (!empty($this->container)) {
+            $route->setContainer($this->container);
+        }
+
+        return $route;
+    }
+
+    /**
+     * @return \FastRoute\Dispatcher
+     */
+    protected function createDispatcher()
+    {
+        if ($this->dispatcher) {
+            return $this->dispatcher;
+        }
+
+        $routeDefinitionCallback = function (RouteCollector $r) {
+            foreach ($this->getRoutes() as $route) {
+                $r->addRoute($route->getMethods(), $route->getPattern(), $route->getIdentifier());
+            }
+        };
+
+        if ($this->cacheFile) {
+            $this->dispatcher = \FastRoute\cachedDispatcher($routeDefinitionCallback, [
+                'routeParser' => $this->routeParser,
+                'cacheFile' => $this->cacheFile,
+            ]);
+        } else {
+            $this->dispatcher = \FastRoute\simpleDispatcher($routeDefinitionCallback, [
+                'routeParser' => $this->routeParser,
+            ]);
+        }
+
+        return $this->dispatcher;
+    }
+
+    /**
+     * @param \FastRoute\Dispatcher $dispatcher
+     */
+    public function setDispatcher(Dispatcher $dispatcher)
+    {
+        $this->dispatcher = $dispatcher;
+    }
+
+    /**
+     * Get route objects
+     *
+     * @return Route[]
+     */
+    public function getRoutes()
+    {
+        return $this->routes;
+    }
+
+    /**
+     * Get named route object
+     *
+     * @param string $name        Route name
+     *
+     * @return Route
+     *
+     * @throws RuntimeException   If named route does not exist
+     */
+    public function getNamedRoute($name)
+    {
+        foreach ($this->routes as $route) {
+            if ($name == $route->getName()) {
+                return $route;
+            }
+        }
+        throw new RuntimeException('Named route does not exist for name: ' . $name);
+    }
+
+    /**
+     * Remove named route
+     *
+     * @param string $name        Route name
+     *
+     * @throws RuntimeException   If named route does not exist
+     */
+    public function removeNamedRoute($name)
+    {
+        $route = $this->getNamedRoute($name);
+
+        // no exception, route exists, now remove by id
+        unset($this->routes[$route->getIdentifier()]);
+    }
+
+    /**
+     * Process route groups
+     *
+     * @return string A group pattern to prefix routes with
+     */
+    protected function processGroups()
+    {
+        $pattern = "";
+        foreach ($this->routeGroups as $group) {
+            $pattern .= $group->getPattern();
+        }
+        return $pattern;
+    }
+
+    /**
+     * Add a route group to the array
+     *
+     * @param string   $pattern
+     * @param callable $callable
+     *
+     * @return RouteGroupInterface
+     */
+    public function pushGroup($pattern, $callable)
+    {
+        $group = new RouteGroup($pattern, $callable);
+        array_push($this->routeGroups, $group);
+        return $group;
+    }
+
+    /**
+     * Removes the last route group from the array
+     *
+     * @return RouteGroup|bool The RouteGroup if successful, else False
+     */
+    public function popGroup()
+    {
+        $group = array_pop($this->routeGroups);
+        return $group instanceof RouteGroup ? $group : false;
+    }
+
+    /**
+     * @param $identifier
+     * @return \Slim\Interfaces\RouteInterface
+     */
+    public function lookupRoute($identifier)
+    {
+        if (!isset($this->routes[$identifier])) {
+            throw new RuntimeException('Route not found, looks like your route cache is stale.');
+        }
+        return $this->routes[$identifier];
+    }
+
+    /**
+     * Build the path for a named route excluding the base path
+     *
+     * @param string $name        Route name
+     * @param array  $data        Named argument replacement data
+     * @param array  $queryParams Optional query string parameters
+     *
+     * @return string
+     *
+     * @throws RuntimeException         If named route does not exist
+     * @throws InvalidArgumentException If required data not provided
+     */
+    public function relativePathFor($name, array $data = [], array $queryParams = [])
+    {
+        $route = $this->getNamedRoute($name);
+        $pattern = $route->getPattern();
+
+        $routeDatas = $this->routeParser->parse($pattern);
+        // $routeDatas is an array of all possible routes that can be made. There is
+        // one routedata for each optional parameter plus one for no optional parameters.
+        //
+        // The most specific is last, so we look for that first.
+        $routeDatas = array_reverse($routeDatas);
+
+        $segments = [];
+        foreach ($routeDatas as $routeData) {
+            foreach ($routeData as $item) {
+                if (is_string($item)) {
+                    // this segment is a static string
+                    $segments[] = $item;
+                    continue;
+                }
+
+                // This segment has a parameter: first element is the name
+                if (!array_key_exists($item[0], $data)) {
+                    // we don't have a data element for this segment: cancel
+                    // testing this routeData item, so that we can try a less
+                    // specific routeData item.
+                    $segments = [];
+                    $segmentName = $item[0];
+                    break;
+                }
+                $segments[] = $data[$item[0]];
+            }
+            if (!empty($segments)) {
+                // we found all the parameters for this route data, no need to check
+                // less specific ones
+                break;
+            }
+        }
+
+        if (empty($segments)) {
+            throw new InvalidArgumentException('Missing data for URL segment: ' . $segmentName);
+        }
+        $url = implode('', $segments);
+
+        if ($queryParams) {
+            $url .= '?' . http_build_query($queryParams);
+        }
+
+        return $url;
+    }
+
+
+    /**
+     * Build the path for a named route including the base path
+     *
+     * @param string $name        Route name
+     * @param array  $data        Named argument replacement data
+     * @param array  $queryParams Optional query string parameters
+     *
+     * @return string
+     *
+     * @throws RuntimeException         If named route does not exist
+     * @throws InvalidArgumentException If required data not provided
+     */
+    public function pathFor($name, array $data = [], array $queryParams = [])
+    {
+        $url = $this->relativePathFor($name, $data, $queryParams);
+
+        if ($this->basePath) {
+            $url = $this->basePath . $url;
+        }
+
+        return $url;
+    }
+
+    /**
+     * Build the path for a named route.
+     *
+     * This method is deprecated. Use pathFor() from now on.
+     *
+     * @param string $name        Route name
+     * @param array  $data        Named argument replacement data
+     * @param array  $queryParams Optional query string parameters
+     *
+     * @return string
+     *
+     * @throws RuntimeException         If named route does not exist
+     * @throws InvalidArgumentException If required data not provided
+     */
+    public function urlFor($name, array $data = [], array $queryParams = [])
+    {
+        trigger_error('urlFor() is deprecated. Use pathFor() instead.', E_USER_DEPRECATED);
+        return $this->pathFor($name, $data, $queryParams);
+    }
+}
diff --git a/vendor/slim/slim/composer.json b/vendor/slim/slim/composer.json
new file mode 100644
index 0000000..554a838
--- /dev/null
+++ b/vendor/slim/slim/composer.json
@@ -0,0 +1,58 @@
+{
+    "name": "slim/slim",
+    "type": "library",
+    "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
+    "keywords": ["framework","micro","api","router"],
+    "homepage": "https://slimframework.com",
+    "license": "MIT",
+    "authors": [
+        {
+            "name": "Josh Lockhart",
+            "email": "hello@joshlockhart.com",
+            "homepage": "https://joshlockhart.com"
+        },
+        {
+            "name": "Andrew Smith",
+            "email": "a.smith@silentworks.co.uk",
+            "homepage": "http://silentworks.co.uk"
+        },
+        {
+            "name": "Rob Allen",
+            "email": "rob@akrabat.com",
+            "homepage": "http://akrabat.com"
+        },
+        {
+            "name": "Gabriel Manricks",
+            "email": "gmanricks@me.com",
+            "homepage": "http://gabrielmanricks.com"
+        }
+    ],
+    "require": {
+        "php": ">=5.5.0",
+        "pimple/pimple": "^3.0",
+        "psr/http-message": "^1.0",
+        "nikic/fast-route": "^1.0",
+        "container-interop/container-interop": "^1.2",
+        "psr/container": "^1.0"
+    },
+    "require-dev": {
+        "squizlabs/php_codesniffer": "^2.5",
+        "phpunit/phpunit": "^4.0"
+    },
+    "provide": {
+        "psr/http-message-implementation": "1.0"
+    },
+    "autoload": {
+        "psr-4": {
+            "Slim\\": "Slim"
+        }
+    },
+    "scripts": {
+        "test": [
+            "@phpunit",
+            "@phpcs"
+        ],
+        "phpunit": "php vendor/bin/phpunit",
+        "phpcs": "php vendor/bin/phpcs"
+    }
+}
